<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Translator | Mirreal Note]]></title>
  <link href="http://blog.mirreal.net/blog/categories/translator/atom.xml" rel="self"/>
  <link href="http://blog.mirreal.net/"/>
  <updated>2017-12-11T23:51:17+08:00</updated>
  <id>http://blog.mirreal.net/</id>
  <author>
    <name><![CDATA[Patrick Ran]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[React 整洁代码最佳实践]]></title>
    <link href="http://blog.mirreal.net/blog/2017/12/01/clean-code-vs-dirty-code-react-best-practices/"/>
    <updated>2017-12-01T08:53:45+08:00</updated>
    <id>http://blog.mirreal.net/blog/2017/12/01/clean-code-vs-dirty-code-react-best-practices</id>
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="http://americanexpress.io/clean-code-dirty-code/">Clean Code vs. Dirty Code: React Best Practices</a></p>

<p>作者：Donavon West</p></blockquote>

<p>本文主要介绍了适用于现代 React 软件开发的整洁代码实践，顺便谈谈 ES6/ES2015 带来的一些好用的“语法糖”。</p>

<h2>什么是整洁代码，为什么要在乎？</h2>

<p>整洁代码代表的是一种一致的编码风格，目的是让代码更易于编写，阅读和维护。通常情况下，开发者在解决问题的时候，一旦问题解决就发起一个 Pull Request（译注：合并请求，在 Gitlab 上叫 Merge Request）。但我认为，这时候工作并没有真正完成，我们不能仅仅满足于代码可以工作。</p>

<p>这时候其实就是整理代码的最好时机，可以通过删除死代码（僵尸代码），重构以及删除注释掉的代码，来保持代码的可维护性。不妨问问自己，“从现在开始再过六个月，其他人还能理解这些代码吗？”简而言之，对于自己编写的代码，你应该保证能很自豪地拿给别人看。</p>

<p>至于为什么要在乎这点？因为我们常说一个优秀的开发者大都比较”懒“。在遇到需要重复做某些事情的情况下，他们会去找到一个自动化（或更好的）解决方案来完成这些任务。</p>

<h3>整洁代码能够通过“味道测试”</h3>

<p>整洁代码应该可以通过“味道测试”。什么意思呢？我们在看代码的时候，包括我们自己写的或或是别人的，会说：“这里不太对劲。”如果感觉不对，那可能就真的是有问题的。如果你觉得你正在试图把一个方形钉子装进一个圆形的洞里，那么就暂停一下，然后休息一下。多次尝试之后，你会找到一个更好的解决方案。</p>

<h3>整洁代码是符合 DRY 原则的</h3>

<p>DRY 是一个缩略词，意思是“不要重复自己”（Don’t Repeat Yourself）。如果发现多个地方在做同样的事情，那么这时候就应该合并重复代码。如果在代码中看到了模式，那么表明需要实行 DRY。</p>

<pre><code class="js">// Dirty
const MyComponent = () =&gt; (
  &lt;div&gt;
    &lt;OtherComponent type="a" className="colorful" foo={123} bar={456} /&gt;
    &lt;OtherComponent type="b" className="colorful" foo={123} bar={456} /&gt;    
  &lt;/div&gt;
);
</code></pre>

<pre><code class="js">// Clean
const MyOtherComponent = ({ type }) =&gt; (
  &lt;OtherComponent type={type} className="colorful" foo={123} bar={456} /&gt;
);
const MyComponent = () =&gt; (
  &lt;div&gt;
    &lt;MyOtherComponent type="a" /&gt;
    &lt;MyOtherComponent type="b" /&gt;
  &lt;/div&gt;
);
</code></pre>

<p>有时候，比如在上面的例子中，实行 DRY 原则反而可能会增加代码量。但是，DRY 通常也能够提高代码的可维护性。</p>

<p>注意，很容易陷入过分使用 DRY 原则的陷阱，应该学会适可而止。</p>

<h3>整洁代码是可预测和可测试的</h3>

<p>编写单元测试不仅仅只是一个好想法，而且应该是强制性的。不然，怎么能确保新功能不会在其他地方引起 Bug 呢？</p>

<p>许多 React 开发人员选择 <a href="https://facebook.github.io/jest/">Jest</a> 作为一个零配置测试运行器，然后生成代码覆盖率报告。如果对测试前后对比可视化感兴趣，请查看美国运通的 <a href="https://github.com/americanexpress/jest-image-snapshot">Jest Image snanshot</a>。</p>

<h3>整洁代码是自注释的</h3>

<p>以前发生过这种情况吗？你写了一些代码，并且包含详细的注释。后来你发现一个 bug，于是回去修改代码。但是，你有没有改变注释来体现新的逻辑？也许会，也许不会。下一个看你代码的人可能因为注意到这些注释而掉进一个陷阱。</p>

<p>注释只是为了解释复杂的想法，也就是说，不要对显而易见的代码进行注释。同时，更少的注释也减少了视觉上的干扰。</p>

<pre><code class="js">// Dirty
const fetchUser = (id) =&gt; (
  fetch(buildUri`/users/${id}`) // Get User DTO record from REST API
    .then(convertFormat) // Convert to snakeCase
    .then(validateUser) // Make sure the the user is valid
);
</code></pre>

<p>在整洁代码的版本中，我们对一些函数进行重命名，以便更好地描述它们的功能，从而消除注释的必要性，减少视觉干扰。并且避免后续因代码与注释不匹配导致的混淆。</p>

<pre><code class="js">// Clean
const fetchUser = (id) =&gt; (
  fetch(buildUri`/users/${id}`)
    .then(snakeToCamelCase)
    .then(validateUser)
);
</code></pre>

<h3>命名</h3>

<p>在我之前的文章 <a href="http://americanexpress.io/faccs-are-an-antipattern">将函数作为子组件是一种反模式</a>，强调了命名的重要性。每个开发者都应该认真考虑变量名，函数名，甚至是文件名。</p>

<p>这里列举一下命名原则：</p>

<ul>
<li><p>布尔变量或返回布尔值的函数应该以“is”，“has”或“should”开头。</p>

<pre><code class="js">// Dirty
const done = current &gt;= goal;
</code></pre>

<pre><code class="js">// Clean
const isComplete = current &gt;= goal;
</code></pre></li>
<li><p>函数命名应该体现做了什么，而不是是怎样做的。换言之，不要在命名中体现出实现细节。假如有天出现变化，就不需要因此而重构引用该函数的代码。比如，今天可能会从 REST API 加载配置，但是可能明天就会将其直接写入到 JavaScript 中。</p>

<pre><code class="js">// Dirty
const loadConfigFromServer = () =&gt; {
  ...
};
</code></pre>

<pre><code class="js">// Clean
const loadConfig = () =&gt; {
  ...
};
</code></pre></li>
</ul>


<h3>整洁代码遵循成熟的设计模式和最佳实践</h3>

<p>计算机已经存在很长一段时间了。多年以来，程序员通过解决某些特定问题，发现了一些固有套路，被称为设计模式。换言之，有些算法已经被证明是可以工作的，所以应该站在前人的肩膀上，避免犯同样的错误。</p>

<p>那么，什么是最佳实践，与设计模式类似，但是适用范围更广，不仅仅针对编码算法。比如，“应该对代码进行静态检查”或者“当编写一个库时，应该将 React 作为 <code>peerDependency</code>”，这些都可以称为最佳实践。</p>

<p>构建 React 应用程序时，应该遵循以下最佳实践：</p>

<ul>
<li>使用小函数，每个函数具备单一功能，即所谓的单一职责原则（Single responsibility principle）。确保每个函数都能完成一项工作，并做得很好。这样就能将复杂的组件分解成许多较小的组件。同时，将具备更好的可测试性。</li>
<li>小心抽象泄露（leaky abstractions）。换言之，不要强迫消费方去了解内部代码实现细节。</li>
<li>遵循严格的代码检查规则。这将有助于编写整洁，一致的代码。</li>
</ul>


<h3>整洁代码不需要花长时间来编写</h3>

<p>总会听到这样的说法：编写整洁代码会降低生产力。简直是在胡说八道。是的，可能刚开始需要放慢速度，但最终会随着编写更少的代码而节奏加快。</p>

<p>而且，不要小看代码评审导致的重写重构，以及修复问题花费的时间。如果把代码分解成小的模块，每个模块都是单一职责，那么很可能以后再也不用去碰大多数模块了。时间就省下来了，也就是说 “write it and forget it”。</p>

<h2>槽糕代码与整洁代码的实例</h2>

<h3>使用 DRY 原则</h3>

<p>看看下面的代码示例。如上所述，从你的显示器退后一步，发现什么模式了吗？注意 <code>Thingie</code> 组件与 <code>ThingieWithTitle</code> 组件除了 <code>Title</code> 组件几乎完全相同，这是实行 DRY 原则的最佳情形。</p>

<pre><code class="js">// Dirty
import Title from './Title';

export const Thingie = ({ description }) =&gt; (
  &lt;div class="thingie"&gt;
    &lt;div class="description-wrapper"&gt;
      &lt;Description value={description} /&gt;
    &lt;/div&gt;
  &lt;/div&gt;
);

export const ThingieWithTitle = ({ title, description }) =&gt; (
  &lt;div&gt;
    &lt;Title value={title} /&gt;
    &lt;div class="description-wrapper"&gt;
      &lt;Description value={description} /&gt;
    &lt;/div&gt;
  &lt;/div&gt;
);
</code></pre>

<p>在这里，我们将 <code>children</code> 传递给 <code>Thingie</code>。然后创建 <code>ThingieWithTitle</code>，这个组件包含 <code>Thingie</code>，并将 <code>Title</code> 作为其子组件传给 <code>Thingie</code>。</p>

<pre><code class="js">// Clean
import Title from './Title';

export const Thingie = ({ description, children }) =&gt; (
  &lt;div class="thingie"&gt;
    {children}
    &lt;div class="description-wrapper"&gt;
      &lt;Description value={description} /&gt;
    &lt;/div&gt;
  &lt;/div&gt;
);

export const ThingieWithTitle = ({ title, ...others }) =&gt; (
  &lt;Thingie {...others}&gt;
    &lt;Title value={title} /&gt;
  &lt;/Thingie&gt;
);
</code></pre>

<h3>默认值</h3>

<p>看看下面的代码。使用逻辑或将 <code>className</code> 的默认值设置成 “icon-large”，看起来像是上个世纪的人才会写的代码。</p>

<pre><code class="js">// Dirty
const Icon = ({ className, onClick }) =&gt; {
  const additionalClasses = className || 'icon-large';

  return (
    &lt;span
      className={`icon-hover ${additionalClasses}`}
      onClick={onClick}&gt;
    &lt;/span&gt;
  );
};
</code></pre>

<p>这里我们使用 ES6 的默认语法来替换 <code>undefined</code> 时的值，而且还能使用 ES6 的箭头函数表达式写成单一语句形式，从而去除对 <code>return</code> 的依赖。</p>

<pre><code class="js">// Clean
const Icon = ({ className = 'icon-large', onClick }) =&gt; (
  &lt;span className={`icon-hover ${className}`} onClick={onClick} /&gt;
);
</code></pre>

<p>在下面这个更整洁的版本中，使用 React 中的 API 来设置默认值。</p>

<pre><code class="js">// Cleaner
const Icon = ({ className, onClick }) =&gt; (
  &lt;span className={`icon-hover ${className}`} onClick={onClick} /&gt;
);

Icon.defaultProps = {
  className: 'icon-large',
};
</code></pre>

<p>为什么这样显得更加整洁？而且它真的会更好吗？三个版本不是都在做同样的事情吗？某种意义上来说，是对的。让 React 设置 prop 默认值的好处是，可以产生更高效的代码，而且在基于 <code>Class</code> 的生命周期组件中允许通过 <code>propTypes</code> 检查默认值。还有一个优点是：将默认逻辑从组件本身抽离出来。</p>

<p>例如，你可以执行以下操作，将所有默认属性放到一个地方。当然，并不是建议你这样做，只是说具有这样的灵活性。</p>

<pre><code class="js">import defaultProps from './defaultProps';
// ...
Icon.defaultProps = defaultProps.Icon;
</code></pre>

<h3>从渲染分离有状态的部分</h3>

<p>将有状态的数据加载逻辑与渲染逻辑混合可能增加组件复杂性。更好的方式是，写一个负责完成数据加载的有状态的容器组件，然后编写另一个负责显示数据的组件。这被称为 <a href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0">容器模式</a>。</p>

<p>在下面的示例中，用户数据加载和显示功能放在一个组件中。</p>

<pre><code class="js">// Dirty
class User extends Component {
  state = { loading: true };

  render() {
    const { loading, user } = this.state;
    return loading
      ? &lt;div&gt;Loading...&lt;/div&gt;
      : &lt;div&gt;
          &lt;div&gt;
            First name: {user.firstName}
          &lt;/div&gt;
          &lt;div&gt;
            First name: {user.lastName}
          &lt;/div&gt;
          ...
        &lt;/div&gt;;
  }

  componentDidMount() {
    fetchUser(this.props.id)
      .then((user) =&gt; { this.setState({ loading: false, user })})
  }
}
</code></pre>

<p>在整洁版本中，加载数据和显示数据已经分离。这不仅使代码更容易理解，而且能减少测试的工作量，因为可以独立测试每个部分。而且由于 <code>RenderUser</code> 是一个无状态组件，所以结果是可预测的。</p>

<pre><code class="js">// Clean
import RenderUser from './RenderUser';

class User extends Component {
  state = { loading: true };

  render() {
    const { loading, user } = this.state;
    return loading ? &lt;Loading /&gt; : &lt;RenderUser user={user} /&gt;;
  }

  componentDidMount() {
    fetchUser(this.props.id)
      .then(user =&gt; { this.setState({ loading: false, user })})
  }
}
</code></pre>

<h3>使用无状态组件</h3>

<p>React v0.14.0 中引入了无状态函数组件（SFC），被简化成纯渲染组件，但有些开发者还在使用过去的方式。例如，以下组件就应该转换为 SFC。</p>

<pre><code class="js">// Dirty
class TableRowWrapper extends Component {
  render() {
    return (
      &lt;tr&gt;
        {this.props.children}
      &lt;/tr&gt;
    );
  }
}
</code></pre>

<p>整洁版本清除了很多可能导致干扰的信息。通过 React 核心的优化，使用无状态组件将占用更少的内存，因为没有创建 Component 实例。</p>

<pre><code class="js">// Clean
const TableRowWrapper = ({ children }) =&gt; (
  &lt;tr&gt;
    {children}
  &lt;/tr&gt;
);
</code></pre>

<h3>剩余/扩展属性（rest/spread）</h3>

<p>大约在一年前，我还推荐大家多用 <code>Object.assign</code>。但时代变化很快，在 ES2016/ES7 中引入新特性 <a href="https://github.com/tc39/proposal-object-rest-spread">rest/spread</a>。</p>

<p>比如这样一种场景，当传递给一些 props 给一个组件，只希望在组件本身使用 <code>className</code>，但是需要将其他所有 props 传递到子组件。这时，你可能会这样做：</p>

<pre><code class="js">// Dirty
const MyComponent = (props) =&gt; {
  const others = Object.assign({}, props);
  delete others.className;

  return (
    &lt;div className={props.className}&gt;
      {React.createElement(MyOtherComponent, others)}
    &lt;/div&gt;
  );
};
</code></pre>

<p>这不是一个非常优雅的解决方案。但是使用 rest/spread，就能轻而易举地实现，</p>

<pre><code class="js">// Clean
const MyComponent = ({ className, ...others }) =&gt; (
  &lt;div className={className}&gt;
    &lt;MyOtherComponent {...others} /&gt;
  &lt;/div&gt;
);
</code></pre>

<p>我们将剩余属性展开并作为新的 props 传递给 <code>MyOtherComponent</code> 组件。</p>

<h3>合理使用解构</h3>

<p>ES6 引入 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">解构</a>（destructuring） 的概念，这是一个非常棒的特性，用类似对象或数组字面量的语法获取一个对象的属性或一个数组的元素。</p>

<h4>对象解构</h4>

<p>在这个例子中，<code>componentWillReceiveProps</code> 组件接收 <code>newProps</code> 参数，然后将其 <code>active</code> 属性设置为新的 <code>state.active</code>。</p>

<pre><code class="js">// Dirty
componentWillReceiveProps(newProps) {
  this.setState({
    active: newProps.active
  });
}
</code></pre>

<p>在整洁版本中，我们解构 <code>newProps</code>成 <code>active</code>。这样我们不仅不需要引用 <code>newProps.active</code>，而且也可以使用 ES6 的简短属性特性来调用 <code>setState</code>。</p>

<pre><code>// Clean
componentWillReceiveProps({ active }) {
  this.setState({ active });
}
</code></pre>

<h4>数组解构</h4>

<p>一个经常被忽视的 ES6 特性是数组解构。以下面的代码为例，它获取 <code>locale</code> 的值，比如“en-US”，并将其分成 <code>language</code>（en）和 <code>country</code>（US）。</p>

<pre><code class="js">// Dirty
const splitLocale = locale.split('-');
const language = splitLocale[0];
const country = splitLocale[1];
</code></pre>

<p>在整洁版本，使用 ES6 的数组解构特性可以自动完成上述过程：</p>

<pre><code class="js">// Clean
const [language, country] = locale.split('-');
</code></pre>

<h2>所以结论是</h2>

<p>希望这篇文章能有助于你看到编写整洁代码的好处，甚至可以直接使用这里介绍的一些代码示例。一旦你习惯编写整洁代码，将很快就会体会到 “write it and forget it” 的生活方式。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[魔幻语言 JavaScript 系列之 Call、bind 以及上下文]]></title>
    <link href="http://blog.mirreal.net/blog/2017/11/09/call-apply-and-context-in-javascript/"/>
    <updated>2017-11-09T14:24:57+08:00</updated>
    <id>http://blog.mirreal.net/blog/2017/11/09/call-apply-and-context-in-javascript</id>
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="http://blog.bloomca.me/2017/11/08/the-most-clever-line-of-javascript.html">The Most Clever Line of JavaScript</a></p>

<p>作者：<a href="https://twitter.com/blooomca">Seva Zaikov</a></p></blockquote>

<h2>原文</h2>

<p>最近 <a href="https://twitter.com/vedroarbuzov">一个朋友</a> 发给我一段非常有趣的 JavaScript 代码，是他在某个 <a href="https://github.com/pelias/openstreetmap/blob/313f208ea323232919e42bf88871d8e19ddacec3/stream/address_extractor.js#L54">开源库中</a> 看到的：</p>

<pre><code class="javascript">addressParts.map(Function.prototype.call, String.prototype.trim);
</code></pre>

<p>一开始，我觉得这是一个“不错的尝试”。但是，印象中 <code>map</code> 好像只接受一个参数，这里却出现第二个参数，所以去查看了 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map">MDN文档</a>，才知道可以传一个上下文（context）作为第二个参数。在这时候，我还无法解释这段代码，运行完之后感到更加困惑了，因为它竟然能如预期那样工作。</p>

<p>我花了至少半个小时来尝试理解这段代码，这是一个很有趣的例子，可以用来说明 JavaScript 是一门多么魔幻的语言，即使已经写了好几年的 JS。当然，你可以选择自己去弄清楚，如果想看看我的理解，请继续阅读。</p>

<p>那么，它到底是如何工作的呢？让我们从一种更简单的实现开始（实际上这种实现代码更短，并且更易读:)）：</p>

<pre><code class="javascript">addressParts.map(str =&gt; str.trim());
</code></pre>

<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call">Function.prototype.call</a> 是 JavaScript 函数原型中的一个函数，它调用函数，使用第一个参数作为 <code>this</code> 参数，并传递剩余参数作为被调用函数的参数。举个例子：</p>

<pre><code class="javascript">// this function has `Function` in prototype chain
// so `call` is available
function multiply(x, y) {
  return x * y;
}

multiply.call(null, 3, 5); // 15
multiply(3, 5); // same, 15
</code></pre>

<p><code>map</code> 第二个参数的典型用法如下所示，假设有一个基于类的 React 组件，其功能是渲染一个按钮列表：</p>

<pre><code class="javascript">class ExampleComponent extends Component {
  renderButton({ title, name }) {
    // without proper `this` it will fail
    const { isActive } = this.props;
    return (
      &lt;Button key={title} title={title}&gt;
        {name}
      &lt;/Button&gt;
    );
  }

  render() {
    const { buttons } = this.props;

    // without second param our function won't be able
    // to access `this` inside
    const buttonsMarkup = buttons.map(this.renderButton, this);
  }
}
</code></pre>

<p>但是，以我的经验来看，这种使用第二个参数的做法并不常见，更常见的做法是使用类属性或装饰器来避免绑定。</p>

<blockquote><p>译者注：<code>map</code> 第二个参数的用法等同于
<code>javascript
const buttonsMarkup = buttons.map(this.renderButton.bind(this);
</code></p></blockquote>

<p>还有一个类似的方法 &ndash; <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply">Function.prototype.apply</a>，工作原理与 <code>call</code> 相同，只是第二个参数应该是一个数组（译者注：或者是一个类数组），它将被转换成一个参数列表，用逗号分隔。所以，让我们看看如何使用它来计算最大值：</p>

<pre><code class="javascript">Math.max(1, 2, 3); // if we know all numbers upfront
// we can call it like that

Math.max([1, 2, 3]); // won't work!

Math.max.apply(null, [1, 2, 3]); // will work!

// however, ES2015 array destructuring works as well:
Math.max(...[1, 2, 3]);
</code></pre>

<p>现在，我们重新创建一个可以解决问题的函数调用方式。我们想删除字符串两端的空白字符，这个方法位于 <code>String.prototype</code> ，所以我们使用 <code>.</code> 操作符来调用它（虽然，字符串是原始值（primitive），但是当我们进行方法调用时，会在内部被转换成对象）。我们继续：</p>

<pre><code class="javascript">// let's try to imagine how trim method is implemented
// on String.prototype
String.prototype.trim = function() {
  // string itself is contained inside `this`!
  const str = this;
  // this is a very naive implementation
  return str.replace(/(^\s+)|(\s+$)/g, '');
};

// let's try to use `.call` method to invoke `trim`
" aa ".trim.call(thisArg);

// but `this` is our string itself!
// so, next two calls are equivalent:
" aa ".trim.call(" aa ");
String.prototype.trim.call(" aa ");
</code></pre>

<p>我们现在距离答案更近一步，但是仍然没有解释清楚最初那段代码：</p>

<pre><code class="javascript">addressParts.map(Function.prototype.call, String.prototype.trim);
</code></pre>

<p>让我们自己来实现 <code>Function.prototype.call</code>：</p>

<pre><code class="javascript">Function.prototype.call = function(thisArg, ...args) {
  // `this` in our case is actually our function!
  const fn = this;

  // also, pretty naive implementation
  return fn.bind(thisArg)(...args);
};
</code></pre>

<p>现在，我们可以来理一理所有的东西。当我们在 <code>.map</code> 里面声明函数的时候，我们给 <code>Function.prototype.call</code> 绑定<code>String.prototype.trim</code> 作为 <code>this</code> 上下文，然后我们在数组中的每个元素上调用这个函数，把每个字符串作为 <code>thisArg</code> 参数的值传递给 <code>call</code>。这意味着，<code>String.prototype.trim</code> 将使用字符串作为 <code>this</code> 上下文来调用。我们已经知道这样做是有效的，看看下面的例子：</p>

<pre><code class="javascript">String.prototype.trim.call(" aa "); // "aa"
</code></pre>

<p>问题解决了！但是，我认为这并不是一个好的做法，至于应该如何使用一种好的方式来完成这件事， 很简单，只需传递一个匿名函数就能搞定：</p>

<pre><code class="javascript">addressParts.map(str =&gt; str.trim()); // same effect
</code></pre>

<h2>也谈谈 JavaScript 中的 call、apply 和 bind</h2>

<p>作者在最后这一段可能讲得有些简略，尤其是对于 <code>bind</code> 的用法，谈谈我的理解思路：</p>

<pre><code class="javascript">// 我们从常用的 slice 说起
// 相信很多人都写过这样的代码
// 我们称之为方法借用
Array.prototype.slice.call([1, 2, 3], 1) // [ 2, 3]

// 也会有人这样写
[].slice.call([1, 2, 3], 1) // [2, 3]

// 但上面的例子其实不是其真实的使用场景，因为 [1, 2, 3] 本身就是一个 array，可以直接调用 slice
[1, 2, 3].slice(1) // [2, 3]

// 之前比较常见的场景是处理 argumnents，通过这种方式将这种类数组转换成真正的数组
Array.prototype.slice.call(arguments)

// 回到最上面的例子，我们已经知道使用 call 可以让你在某个特定上下文(context)调用函数(fn)
// fn.call(context [, ...args])
// 而对 call 来说，它的上下文就是 fn
// 所以 call 本身也是有上下文的，那我们为什么不可以直接给 call 指定一个上下文，就像这样：
Function.prototype.call.call(Array.prototype.slice, [1, 2, 3], 1) // [2, 3]

// 或者是这样，apply 接受一个数组
Function.prototype.call.apply(Array.prototype.slice, [[1, 2, 3], 1]) // [2, 3]

// 当然，也可以使用一下 bind，这样会返回一个新的函数
// 我们直接将 slice 绑定到 call 的上下文
var slice = Function.prototype.call.bind(Array.prototype.slice)
slice([1, 2, 3], 1) // [2, 3]

// 我们来稍微改动一下，跟上述 slice 的例子一致
var trim = Function.prototype.call.bind(String.prototype.trim)

// 上述 slice 等同于 Array.prototype.slice.call
// 所以这里的 trim，等同于 String.prototype.trim.call
// 那么
trim(' node') // 'node'

// 现在，在 map 里使用 trim
addressParts.map(Function.prototype.call.bind(String.prototype.trim))

// 回到最初的那段代码，这里面包含一个隐式的 bind 操作，与上面的代码等效
// 问题到这里就已经解决
addressParts.map(Function.prototype.call, String.prototype.trim)


// 如作者所言，这样的代码确实不容易阅读，不过对于我们理解 call、bind 以及 context 的概念仍是个很好的例子
// 我们还可以写得更复杂
// 不用担心，下面这段代码什么新东西都没有，不过是给 map 绑定到 call 而已
Function.prototype.call.bind(Array.prototype.map)(addressParts, Function.prototype.call, String.prototype.trim)
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[编写扁平化的代码]]></title>
    <link href="http://blog.mirreal.net/blog/2017/11/02/writing-flat-and-declarative-code/"/>
    <updated>2017-11-02T11:20:03+08:00</updated>
    <id>http://blog.mirreal.net/blog/2017/11/02/writing-flat-and-declarative-code</id>
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="https://peeke.nl/writing-flat-code">Writing flat &amp; declarative code</a></p>

<p>作者：<a href="https://twitter.com/peeke__">Peeke Kuepers</a></p></blockquote>

<p>&ndash; <em>给你的代码增加一点点函数式编程的特性</em></p>

<p><strong>最近我对函数式编程非常感兴趣。这个概念让我着迷：应用数学来增强抽象性和强制纯粹性，以避免副作用，并实现代码的良好可复用性。同时，函数式编程非常复杂。</strong></p>

<p>函数式编程有一个非常陡峭的学习曲线，因为它来源于数学中的<a href="https://github.com/MostlyAdequate/mostly-adequate-guide/blob/master/ch5.md#category-theory">范畴论</a>。接触不久之后，就将遇到诸如组合（composition）、恒等（identity），函子（functor）、单子（monad），以及逆变（contravariant）等术语。我根本不太了解这些概念，可能这也是我从来没有在实践中运用函数式编程的原因。</p>

<p>我开始思考：在常规的命令式编程和完全的函数式编程之间是否可能会有一些中间形式？既允许在代码库引入函数式编程的一些很好的特性，同时暂时保留已有的旧代码。</p>

<p>对我而言，函数式编程最大的作用就是强制你编写声明性代码：代码描述你做什么，而不是在描述如何做。这样就可以轻松了解特定代码块的功能，而无需了解其真正的运行原理。事实证明，编写声明式代码是函数式编程中最简单的部分之一。</p>

<h2>循环</h2>

<blockquote><p>&hellip;一个循环就是一个命令式控制结构，难以重用，并且难以插入到其他操作中。此外，它还得不断变化代码来响应新的迭代需求。</p>

<p>&ndash; Luis Atencio</p></blockquote>

<p>所以，让我们先看一下循环，循环是命令式编程的一个很好的例子。循环涉及很多语法，都是描述它们的行为是如何工作，而不是它们在做什么。例如，看看这段代码：</p>

<pre><code class="javascript">function helloworld(arr) {
    for (let i = 1; i &lt; arr.length; i++) {
        arr[i] *= 2
        if (arr[i] % 2 === 0) {
            doSomething(arr[i])
        }
    }
}
</code></pre>

<p>这段代码在做什么呢？它将数组内除第一个数字 （<code>let i = 1</code>）的其他所有数字乘以 2，如果是偶数的话（<code>if (arr % 2 === 0)</code>），就进行某些操作。在此过程中，原始数组的值会被改变。但这通常是不必要的，因为数组可能还会在代码库中的其他地方用到，所以刚才所做的改变可能会导致意外的结果。</p>

<p>但最主要的原因是，这段代码看起来很难一目了然。它是命令式的，for 循环告诉我们如何遍历数组，在里面，使用一个 if 语句有条件地调用一个函数。</p>

<p>我们可以通过使用数组方法以声明式的方式重写这段代码。数组方法直接表达所做的事，比较常见的方法包括：<code>forEach</code>，<code>map</code>，<code>filter</code>，<code>reduce</code> 和 <code>slice</code>。</p>

<p>结果就像下面这样：</p>

<pre><code class="javascript">function helloworld(arr) {
    const evenNumbers = n =&gt; n % 2 === 0

    arr
        .slice(1)
        .map(v =&gt; v * 2)
        .filter(evenNumbers)
        .forEach(v =&gt; doSomething(v))    
}
</code></pre>

<p>在这个例子中，我们使用一种很好的，扁平的链式结构去描述我们在做什么，明确表明意图。此外，我们避免了改变原始数组，从而避免不必要的副作用，因为大多数数组方法会返回一个新数组。当箭头函数开始变得越来越复杂时，可以地将其提取到一个特定的函数中，比如 <code>evenNumbers</code>， 从而尽量保持结构简单易读。</p>

<p>在上面的例子，链式调用并没有返回值，而是以 forEach 结束。然而，我们可以轻松地剥离最后一部分，并返回结果，以便我们可以在其他地方处理它。如果还需要返回除数组以外的任何东西，可以使用 <code>reduce</code> 函数。</p>

<p>对于接下来的一个例子，假设我们有一组 JSON 数据，其中包含在一个虚构歌唱比赛中不同国家获得的积分：</p>

<pre><code class="json">[
    {
        "country": "NL",
        "points": 12
    },
    {
        "country": "BE",
        "points": 3
    },
    {
        "country": "NL",
        "points": 0
    },
    ...
]
</code></pre>

<p>我们想计算荷兰（NL）获得的总积分，根据印象中其强大的音乐能力，我们可以认为这是一个非常高的分数，但我们想要更精确地确认这一点。</p>

<p>使用循环可能会是这样：</p>

<pre><code class="javascript">function countVotes(votes) {
    let score = 0;

    for (let i = 0; i &lt; votes.length; i++) {
        if (votes[i].country === 'NL') {
            score += votes[i].points;
        }
    }

    return score;
}
</code></pre>

<p>使用数组方法重构，我们得到一个更干净的代码片段：</p>

<pre><code class="javascript">function countVotes(votes) {
    const sum = (a, b) =&gt; a + b;

    return votes
        .filter(vote =&gt; vote.country === 'NL')
        .map(vote =&gt; vote.points)
        .reduce(sum);
}
</code></pre>

<p>有时候 <code>reduce</code> 可能有点难以阅读，将 <code>reduce</code> 函数提取出来会在理解上有帮助。在上面的代码片段中，我们定义了一个 <code>sum</code> 函数来描述函数的作用，因此方法链仍然保持很好的可读性。</p>

<h2>if else 语句</h2>

<p>接下来，我们来聊聊大家都很喜欢的 if else 语句，if else 语句也是命令式代码里一个很好的例子。为了使我们的代码更具声明式，我们将使用三元表达式。</p>

<p>一个三元表达式是 if else 语句的替代语法。以下两个代码块具有相同的效果：</p>

<pre><code class="javascript">// Block 1
if (condition) {
    doThis();
} else {
    doThat();
}

// Block 2
const value = condition ? doThis() : doThat();
</code></pre>

<p>当在定义（或返回）一个常量时，三元表达式非常有用。使用 if else 语句会将该变量的使用范围限制在语句内，通过使用三元语句，我们可以避免这个问题：</p>

<pre><code class="javascript">if (condition) {
    const a = 'foo';
} else {
    const a = 'bar';
}

const b = condition ? 'foo' : 'bar';

console.log(a); // Uncaught ReferenceError: a is not defined
console.log(b); // 'bar'
</code></pre>

<p>现在，我们来看看如何应用这一点来重构一些更重要的代码：</p>

<pre><code class="javascript">const box = element.getBoundingClientRect();

if (box.top - document.body.scrollTop &gt; 0 &amp;&amp; box.bottom - document.body.scrollTop &lt; window.innerHeight) {
    reveal();
} else {
    hide();
}
</code></pre>

<p>那么，上面的代码发生了什么呢？if 语句检查元素当前是否在页面的可见部分内，这个信息在代码的任何地方都没有表达出来。基于此布尔值，再调用 <code>reveal()</code> 或者 <code>hide()</code> 函数。</p>

<p>将这个 if 语句转换成三元表达式迫使我们将条件移动到它自己的变量中。这样我们可以将三元表达式组合在一行上，现在通过变量的名称来传达布尔值表示的内容，这样还不错。</p>

<pre><code class="javascript">const box = element.getBoundingClientRect();
const isInViewport =
    box.top - document.body.scrollTop &gt; 0 &amp;&amp;
    box.bottom - document.body.scrollTop &lt; window.innerHeight;

isInViewport ? reveal() : hide();
</code></pre>

<p>通过这个例子，重构带来的好处可能看起来不大。接下来会有一个相比更复杂的例子：</p>

<pre><code class="javascript">elements
    .forEach(element =&gt; {
        const box = element.getBoundingClientRect();

        if (box.top - document.body.scrollTop &gt; 0 &amp;&amp; box.bottom - document.body.scrollTop &lt; window.innerHeight) {
            reveal();
        } else {
            hide();
        }

    });
</code></pre>

<p>这很不好，打破了我们优雅的扁平的调用链，从而使代码更难读。我们再次使用三元操作符，而在使用它的时候，使用 <code>isInViewport</code> 检查，并跟它自己的动态函数分开。</p>

<pre><code class="javascript">const isInViewport = element =&gt; {
    const box = element.getBoundingClientRect();
    const topInViewport = box.top - document.body.scrollTop &gt; 0;
    const bottomInViewport = box.bottom - document.body.scrollTop &lt; window.innerHeight;
    return topInViewport &amp;&amp; bottomInViewport;
};

elements
    .forEach(elem =&gt; isInViewport(elem) ? reveal() : hide());
</code></pre>

<p>此外，现在我们将 <code>isInViewport</code> 移动到一个独立函数，可以很容易地把它放在它自己的 helper 类/对象之内：</p>

<pre><code class="javascript">import { isInViewport } from 'helpers';

elements
    .forEach(elem =&gt; isInViewport(elem) ? reveal() : hide());
</code></pre>

<p>虽然上面的例子依赖于所处理的是数组，但是在不明确是在数组的情况下，也可以采用这种编码风格。</p>

<p>例如，看看下面的函数，它通过三条规则来验证密码的有效性。</p>

<pre><code class="javascript">import { passwordRegex as requiredChars } from 'regexes'
import { getJson } from 'helpers'

const validatePassword = async value =&gt; {
  if (value.length &lt; 6) return false
  if (!requiredChars.test(value)) return false

  const forbidden = await getJson('/forbidden-passwords')
  if (forbidden.includes(value)) return false

  return value
}

validatePassword(someValue).then(persist)
</code></pre>

<p>如果我们使用数组包装初始值，就可以使用在上面的例子中里面所用到的所有数组方法。此外，我们已经将验证函数打包成 <code>validationRules</code> 使其可重用。</p>

<pre><code class="javascript">import { minLength, matchesRegex, notBlacklisted } from 'validationRules'
import { passwordRegex as requiredChars } from 'regexes'
import { getJson } from 'helpers'

const validatePassword = async value =&gt; {
  const result = Array.from(value)
    .filter(minLength(6))
    .filter(matchesRegex(requiredChars))
    .filter(await notBlacklisted('/forbidden-passwords'))
    .shift()

  if (result) return result
  throw new Error('something went wrong...')
}

validatePassword(someValue).then(persist)
</code></pre>

<p>目前在 JavaScript 中有一个 <a href="https://github.com/tc39/proposal-pipeline-operator">管道操作符</a> 的提案。使用这个操作符，就不用再把原始值换成数组了。可以直接在前面的值调用管道操作符之后的函数，有点像 <code>Array</code> 的 <code>map</code> 功能。修改之后的代码大概就像这样：</p>

<pre><code class="javascript">import { minLength, matchesRegex, notBlacklisted } from 'validationRules'
import { passwordRegex as requiredChars } from 'regexes'
import { getJson } from 'helpers'

const validatePassword = async value =&gt;
  value
    |&gt; minLength(6)
    |&gt; matchesRegex(requiredChars)
    |&gt; await notBlacklisted('/forbidden-passwords')

try { someValue |&gt; await validatePassword |&gt; persist }
catch(e) {
  // handle specific error, thrown in validation rule
}
</code></pre>

<p>但需要注意的是，这仍然是一个非常早期的提案，不过可以稍微期待一下。</p>

<h2>事件</h2>

<p>最后，我们来看看事件处理。一直以来，事件处理很难以扁平化的方式编写代码。可以 <code>Promise</code> 化来保持一种链式的，扁平化的编程风格，但 <code>Promise</code> 只能 <code>resolve</code> 一次，而事件绝对会多次触发。</p>

<p>在下面的示例中，我们创建一个类，它对用户的每个输入值进行检索，结果是一个自动补全的数组。首先检查字符串是否长于给定的阈值长度。如果满足条件，将从服务器检索自动补全的结果，并将其渲染成一系列标签。</p>

<p>注意代码的不“纯”，频繁地使用 <code>this</code> 关键字。几乎每个函数都在访问 <code>this</code> 这个关键字：</p>

<blockquote><p>译注：作者在这里使用 &ldquo;this keyword&#8221;，有一种双关的意味</p></blockquote>

<pre><code class="javascript">import { apiCall } from 'helpers'

class AutoComplete {

  constructor (options) {

    this._endpoint = options.endpoint
    this._threshold = options.threshold
    this._inputElement = options.inputElement
    this._containerElement = options.list

    this._inputElement.addEventListener('input', () =&gt;
      this._onInput())

  }

  _onInput () {

    const value = this._inputElement.value

    if (value &gt; this._options.threshold) {
      this._updateList(value)
    }

  }

  _updateList (value) {

    apiCall(this._endpoint, { value })
      .then(items =&gt; this._render(items))
      .then(html =&gt; this._containerElement = html)

  }

  _render (items) {

    let html = ''

    items.forEach(item =&gt; {
      html += `&lt;a href="${ item.href }"&gt;${ item.label }&lt;/a&gt;`
    })

    return html

  }

}
</code></pre>

<p>通过使用 <code>Observable</code>，我们将用一种更好的方式对这段代码进行重写。可以简单将 <code>Observable</code> 理解成一个能够多次 <code>resolve</code> 的 <code>Promise</code>。</p>

<blockquote><p>Observable 类型可用于基于推送模型的数据源，如 DOM 事件，定时器和套接字</p></blockquote>

<p><code>Observable</code> 提案目前处于 Stage-1。在下面 <code>listen</code> 函数的实现是从 GitHub 上的<a href="https://github.com/tc39/proposal-observable">提案</a>中直接复制的，主要是将事件监听器转换成 <code>Observable</code>。可以看到，我们可以将整个 <code>AutoComplete</code> 类重写为单个方法的函数链。</p>

<pre><code class="javascript">import { apiCall, listen } from 'helpers';
import { renderItems } from 'templates';

function AutoComplete ({ endpoint, threshold, input, container }) {

  listen(input, 'input')
    .map(e =&gt; e.target.value)
    .filter(value =&gt; value.length &gt;= threshold)
    .forEach(value =&gt; apiCall(endpoint, { value }))
    .then(items =&gt; renderItems(items))
    .then(html =&gt; container.innerHTML = html)

}
</code></pre>

<p>由于大多数 <code>Observable</code> 库的实现过于庞大，我很期待 ES 原生的实现。<code>map</code>，<code>filter</code> 和 <code>forEach</code>方法还不是规范的一部分，但是在 <a href="https://github.com/zenparsing/zen-observable">zen-observable</a> 已经在扩展 API 实现，而 zen-observable 本身是 ES Observables 的一种实现 。</p>

<p>&ndash;</p>

<p>我希望你会对这些“扁平化”模式感兴趣。就个人而言，我很喜欢以这种方式重写我的程序。你接触到的每一段代码都可以更易读。使用这种技术获得的经验越多，就越来越能认识到这一点。记住这个简单的法则：</p>

<p><strong>The flatter the better!</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ES6 Promise：模式与反模式]]></title>
    <link href="http://blog.mirreal.net/blog/2017/09/29/es6-promises-patterns-and-anti-patterns/"/>
    <updated>2017-09-29T16:50:11+08:00</updated>
    <id>http://blog.mirreal.net/blog/2017/09/29/es6-promises-patterns-and-anti-patterns</id>
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="https://medium.com/datafire-io/es6-promises-patterns-and-anti-patterns-bbb21a5d0918">ES6 Promises: Patterns and Anti-Patterns</a>
作者：Bobby Brennan</p></blockquote>

<p>当几年前，第一次使用 NodeJS 的时候，对现在被称为“ <a href="http://callbackhell.com/">回调地狱</a> ”的写法感到很困扰。幸运的是，现在是 2017 年了，NodeJS 已经采用大量 JavaScript 的最新特性，从 <a href="http://node.green/">v4</a> 开始已经支持 Promise。</p>

<p>尽管 Promise 可以让代码更加简洁易读，但对于只熟悉回调函数的人来说，可能对此还是会有所怀疑。在这里，将列出我在使用Promise 时学到的一些基本模式，以及踩的一些坑。</p>

<p><em>注意：<strong>在本文中</strong>将使用<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">箭头函数</a> ，如果你还不是很熟悉，其实很简单，建议<a href="http://exploringjs.com/es6/ch_arrow-functions.html">先读一下使用它们的好处</a></em></p>

<h2>模式与最佳实践</h2>

<h4>使用 Promise</h4>

<p>如果使用的是已经支持 Promise 的第三方库，那么使用起来非常简单。只需关心两个函数：<code>then()</code> 和 <code>catch()</code>。例如，有一个客户端 API 包含三个方法，<code>getItem()</code>，<code>updateItem()</code>，和<code>deleteItem()</code>，每一个方法都返回一个 Promise：</p>

<pre><code class="javascript">Promise.resolve()
  .then(_ =&gt; {
    return api.getItem(1)
  })
  .then(item =&gt; {
    item.amount++
    return api.updateItem(1, item);
  })
  .then(update =&gt; {
    return api.deleteItem(1);
  })
  .catch(e =&gt; {
    console.log('error while working on item 1');
  })
</code></pre>

<p>每次调用 <code>then()</code> 会在 Promise 链中创建一个新的步骤，如果链中的任何一个地方出现错误，就会触发接下来的 <code>catch()</code> 。<code>then()</code> 和 <code>catch()</code> 都可以返回一个值或者一个新的 Promise，结果将被传递到 Promise 链的下一个<code>then()</code>。</p>

<p>为了比较，这里使用回调函数来实现相同逻辑：</p>

<pre><code class="javascript">api.getItem(1, (err, data) =&gt; {
  if (err) throw err;
  item.amount++;
  api.updateItem(1, item, (err, update) =&gt; {
    if (err) throw err;
    api.deleteItem(1, (err) =&gt; {
      if (err) throw err;
    })
  })
})
</code></pre>

<p>要注意的第一个区别是，使用回调函数，我们必须在过程的<strong>每个</strong>步骤中进行错误处理，而不是用单个的 catch-all 来处理。回调函数的第二个问题更直观，每个步骤都要水平缩进，而使用 Promise 的代码则有显而易见的顺序关系。</p>

<h4>回调函数 Promise 化</h4>

<p>需要学习的第一个技巧是如何将回调函数转换为 Promise。你可能正在使用仍然基于回调的库，或是自己的旧代码，不过不用担心，因为只需要几行代码就可以将其包装成一个 Promise。这是将 Node 中的一个回调方法 <code>fs.readFile</code> 转换为 Promise的示例：</p>

<pre><code class="javascript">function readFilePromise(filename) {
  return new Promise((resolve, reject) =&gt; {
    fs.readFile(filename, 'utf8', (err, data) =&gt; {
      if (err) reject(err);
      else resolve(data);
    })
  })
}

readFilePromise('index.html')
  .then(data =&gt; console.log(data))
  .catch(e =&gt; console.log(e))
</code></pre>

<p>关键部分是 Promise 构造函数，它接收一个函数作为参数，这个函数有两个函数参数：<code>resolve</code> 和 <code>reject</code>。在这个函数里完成所有工作，完成之后，在成功时调用 <code>resolve</code>，如果有错误则调用 <code>reject</code>。</p>

<p>需要注意的是只有<strong>一个</strong><code>resolve</code> 或者 <code>reject</code> 被调用，即应该只被调用一次。在我们的示例中，如果 <code>fs.readFile</code> 返回错误，我们将错误传递给 <code>reject</code>，否则将文件数据传递给<code>resolve</code>。</p>

<h4>Promise 的值</h4>

<p>ES6 有两个很方便的辅助函数，用于通过普通值创建 Promise：<code>Promise.resolve()</code> 和 <code>Promise.reject()</code>。例如，可能需要在同步处理某些情况时一个返回 Promise 的函数：</p>

<pre><code class="javascript">function readFilePromise(filename) {
  if (!filename) {
    return Promise.reject(new Error("Filename not specified"));
  }
  if (filename === 'index.html') {
    return Promise.resolve('&lt;h1&gt;Hello!&lt;/h1&gt;');
  }
  return new Promise((resolve, reject) =&gt; {/*...*/})
}
</code></pre>

<p>注意，虽然可以传递任何东西（或者不传递任何值）给 <code>Promise.reject()</code>，但是好的做法是传递一个<code>Error</code>。</p>

<h4>并行运行</h4>

<p><code>Promise.all</code>是一个并行运行 Promise 数组的方法，也就是说是同时运行。例如，我们有一个要从磁盘读取文件的列表。使用上面创建的 <code>readFilePromise</code> 函数，将如下所示：</p>

<pre><code class="javascript">let filenames = ['index.html', 'blog.html', 'terms.html'];

Promise.all(filenames.map(readFilePromise))
  .then(files =&gt; {
    console.log('index:', files[0]);
    console.log('blog:', files[1]);
    console.log('terms:', files[2]);
  })
</code></pre>

<p>我甚至不会使用传统的回调函数来尝试编写与之等效的代码，那样会很凌乱，而且也容易出错。</p>

<h4>串行运行</h4>

<p>有时同时运行一堆 Promise 可能会出现问题。比如，如果尝试使用 <code>Promise.all</code> 的 API ​​去检索一堆资源，则可能会在达到速率限制时开始响应<a href="https://httpstatuses.com/429">429错误</a>。</p>

<p>一种解决方案是串行运行 Promise，或一个接一个地运行。但是在 ES6 中没有提供类似 <code>Promise.all</code> 这样的方法（为什么？），但我们可以使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce?v=b"><code>Array.reduce</code></a> 来实现：</p>

<pre><code class="javascript">let itemIDs = [1, 2, 3, 4, 5];

itemIDs.reduce((promise, itemID) =&gt; {
  return promise.then(_ =&gt; api.deleteItem(itemID));
}, Promise.resolve());
</code></pre>

<p>在这种情况下，我们需要等待每次调用 <code>api.deleteItem()</code> 完成之后才能进行下一次调用。这种方法，比为每个 itemID 写 <code>.then()</code> 更简洁更通用：</p>

<pre><code class="javascript">Promise.resolve()
  .then(_ =&gt; api.deleteItem(1))
  .then(_ =&gt; api.deleteItem(2))
  .then(_ =&gt; api.deleteItem(3))
  .then(_ =&gt; api.deleteItem(4))
  .then(_ =&gt; api.deleteItem(5));
</code></pre>

<h4>Race</h4>

<p>ES6 提供的另一个很方便的函数是 <code>Promise.race</code>。跟 <code>Promise.all</code> 一样，接收一个 Promise 数组，并同时运行它们，但不同的是，会在一旦<strong>任何</strong> Promise 完成或失败的情况下返回，并放弃所有其他的结果。</p>

<p>例如，我们可以创建一个在几秒钟之后超时的 Promise：</p>

<pre><code class="javascript">function timeout(ms) {
  return new Promise((resolve, reject) =&gt; {
    setTimeout(reject, ms);
  })
}

Promise.race([readFilePromise('index.html'), timeout(1000)])
  .then(data =&gt; console.log(data))
  .catch(e =&gt; console.log("Timed out after 1 second"))
</code></pre>

<p>需要注意的是，其他 Promise 仍将继续运行 ，只是看不到结果而已。</p>

<h4>捕获错误</h4>

<p>捕获错误最常见的方式是添加一个  <code>.catch()</code> 代码块，这将捕获前面所有 <code>.then()</code> 代码块中的错误  ：</p>

<pre><code class="javascript">Promise.resolve()
  .then(_ =&gt; api.getItem(1))
  .then(item =&gt; {
    item.amount++;
    return api.updateItem(1, item);
  })
  .catch(e =&gt; {
    console.log('failed to get or update item');
  })
</code></pre>

<p>在这里，只要有 <code>getItem</code> 或者 <code>updateItem</code> 失败，<code>catch()</code>就会被触发。但是如果我们想分开处理 <code>getItem</code> 的错误怎么办？只需再插入一个<code>catch()</code> 就可以，它也可以返回另一个 Promise。</p>

<pre><code class="javascript">Promise.resolve()
  .then(_ =&gt; api.getItem(1))
  .catch(e =&gt; api.createItem(1, {amount: 0}))
  .then(item =&gt; {
    item.amount++;
    return api.updateItem(1, item);
  })
  .catch(e =&gt; {
    console.log('failed to update item');
  })
</code></pre>

<p>现在，如果<code>getItem()</code>失败，我们通过第一个 <code>catch</code> 介入并创建一条新的记录。</p>

<h4>抛出错误</h4>

<p>应该将 <code>then()</code> 语句中的所有代码视为 <code>try</code> 块内的所有代码。<code>return Promise.reject()</code> 和 <code>throw new Error()</code> 都会导致下一个 <code>catch()</code> 代码块的运行。</p>

<p>这意味着运行时错误也会触发 <code>catch()</code>，所以不要去假设错误的来源。例如，在下面的代码中，我们可能希望该 <code>catch()</code> 只能获得 <code>getItem</code> 抛出的错误，但是如示例所示，它还会在我们的 <code>then()</code> 语句中捕获运行时错误。</p>

<pre><code class="javascript">api.getItem(1)
  .then(item =&gt; {
    delete item.owner;
    console.log(item.owner.name);
  })
  .catch(e =&gt; {
    console.log(e); // Cannot read property 'name' of undefined
  })
</code></pre>

<h4>动态链</h4>

<p>有时，我们想要动态地构建 Promise 链，例如，在满足特定条件时，插入一个额外的步骤。在下面的示例中，在读取给定文件之前，我们可以选择创建一个锁定文件：</p>

<pre><code class="javascript">function readFileAndMaybeLock(filename, createLockFile) {
  let promise = Promise.resolve();

  if (createLockFile) {
    promise = promise.then(_ =&gt; writeFilePromise(filename + '.lock', ''))
  }

  return promise.then(_ =&gt; readFilePromise(filename));
}
</code></pre>

<p>一定要通过重写 <code>promise = promise.then(/*...*/)</code> 来更新 <code>Promise</code> 的值。参看接下来反模式中会提到的 <strong>多次调用 then()</strong>。</p>

<h2>反模式</h2>

<p>Promise 是一个整洁的抽象，但很容易陷入某些陷阱。以下是我遇到的一些最常见的问题。</p>

<h4>重回回调地狱</h4>

<p>当我第一次从回调函数转到 Promise 时，发现很难摆脱一些旧习惯，仍像使用回调函数一样嵌套 Promise：</p>

<pre><code class="javascript">api.getItem(1)
  .then(item =&gt; {
    item.amount++;
    api.updateItem(1, item)
      .then(update =&gt; {
        api.deleteItem(1)
          .then(deletion =&gt; {
            console.log('done!');
          })
      })
  })
</code></pre>

<p>这种嵌套是完全没有必要的。有时一两层嵌套可以帮助组合相关任务，但是最好总是使用 <code>.then()</code> 重写成 Promise 垂直链  。</p>

<h4>没有返回</h4>

<p>我遇到的一个经常会犯的错误是在一个 Promise 链中忘记 <code>return</code> 语句。你能发现下面的 bug 吗？</p>

<pre><code class="javascript">api.getItem(1)
  .then(item =&gt; {
    item.amount++;
    api.updateItem(1, item);
  })
  .then(update =&gt; {
    return api.deleteItem(1);
  })
  .then(deletion =&gt; {
    console.log('done!');
  })
</code></pre>

<p>因为我们没有在第4行的 <code>api.updateItem()</code> 前面写 <code>return</code>，所以 <code>then()</code> 代码块会立即 resolove，导致 <code>api.deleteItem()</code> 可能在<code>api.updateItem()</code> 完成之前就被调用。</p>

<p>在我看来，这是 ES6 Promise 的一个大问题，往往会引发意想不到的行为。问题是，  <code>.then()</code> 可以返回一个值，也可以返回一个新的 Promise，<code>undefined</code> 完全是一个有效的返回值。就个人而言，如果我负责 Promise API，我会在 <code>.then()</code> 返回   <code>undefined</code> 时抛出运行时错误，但现在我们需要特别注意 <code>return</code> 创建的 Promise。</p>

<h4>多次调用 <code>.then()</code></h4>

<p>根据规范，在同一个 Promise 上多次调用 <code>then()</code> 是完全有效的，并且回调将按照其注册顺序被调用。但是，我并未见过需要这样做的场景，并且在使用返回值和错误处理时可能会产生一些意外行为：</p>

<pre><code class="javascript">let p = Promise.resolve('a');
p.then(_ =&gt; 'b');
p.then(result =&gt; {
  console.log(result) // 'a'
})

let q = Promise.resolve('a');
q = q.then(_ =&gt; 'b');
q = q.then(result =&gt; {
  console.log(result) // 'b'
})
</code></pre>

<p>在这个例子中，因为我们在每次调用 <code>then()</code> 不更新 <code>p</code> 的值，所以我们看不到 <code>'b'</code> 返回。但是每次调用 <code>then()</code> 时更新 <code>q</code>，所以其行为更可预测。</p>

<p>这也适用于错误处理：</p>

<pre><code class="javascript">let p = Promise.resolve();
p.then(_ =&gt; {throw new Error("whoops!")})
p.then(_ =&gt; {
  console.log('hello!'); // 'hello!'
})

let q = Promise.resolve();
q = q.then(_ =&gt; {throw new Error("whoops!")})
q = q.then(_ =&gt; {
  console.log('hello'); // We never reach here
})
</code></pre>

<p>在这里，我们期望的是抛出一个错误来打破 Promise 链，但由于没有更新 <code>p</code> 的值，所以第二个 <code>then()</code> 仍会被调用。</p>

<p>有可能在一个 Promise 上多次调用 <code>.then()</code> 有很多理由  ，因为它允许将 Promise 分配到几个新的独立的 Promise 中，但是还没发现真实的使用场景。</p>

<h4>混合使用回调和 Promise</h4>

<p>很容易进入一种陷阱，在使用基于 Promise 库的同时，仍在基于回调的项目中工作。始终避免在 <code>then()</code> 或 <code>catch()</code> 使用回调函数 ，否则 Promise 会吞噬任何后续的错误，将其作为 Promise 链的一部分。例如，以下内容看起来是一个挺合理的方式，使用回调函数来包装一个 Promise：</p>

<pre><code class="javascript">function getThing(callback) {
  api.getItem(1)
    .then(item =&gt; callback(null, item))
    .catch(e =&gt; callback(e));
}

getThing(function(err, thing) {
  if (err) throw err;
  console.log(thing);
})
</code></pre>

<p>这里的问题是，如果有错误，我们会收到关于“Unhandled promise rejection”的警告，即使我们添加了一个 <code>catch()</code> 代码块。这是因为，<code>callback()</code> 在 <code>then()</code> 和 <code>catch()</code> 都会被调用，使之成为 Promise 链的一部分。</p>

<p>如果必须使用回调来包装 Promise，可以使用  <code>setTimeout</code> （或者是 NodeJS 中的 <code>process.nextTick</code>）来打破 Promise：</p>

<pre><code class="javascript">function getThing(callback) {
  api.getItem(1)
    .then(item =&gt; setTimeout(_ =&gt; callback(null, item)))
    .catch(e =&gt; setTimeout(_ =&gt; callback(e)));
}

getThing(function(err, thing) {
  if (err) throw err;
  console.log(thing);
})
</code></pre>

<h4>不捕获错误</h4>

<p>JavaScript 中的错误处理有点奇怪。虽然支持熟悉的 <code>try/catch</code> 范例，但是没有办法强制调用者以 Java 的方式处理错误。然而，使用回调函数，使用所谓的“errbacks”，即第一个参数是一个错误回调变得很常见。这迫使调用者至少承认错误的可能性。例如，<code>fs</code> 库：</p>

<pre><code class="javascript">fs.readFile('index.html', 'utf8', (err, data) =&gt; {
  if (err) throw err;
  console.log(data);
})
</code></pre>

<p>使用 Promise，又将很容易忘记需要进行错误处理，特别是对于敏感操作（如文件系统和数据库访问）。目前，如果没有捕获到 reject 的 Promise，将在 NodeJS 中看到非常丑的警告：</p>

<pre><code class="text">(node:29916) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1): Error: whoops!
(node:29916) DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.
</code></pre>

<p>确保在主要的事件循环中任何 Promise 链的末尾添加 <code>catch()</code> 以避免这种情况。</p>

<h2>总结</h2>

<p>希望这是一篇有用的关于常见 Promise 模式和反模式的概述。如果你想了解更多，这里有一些有用的资源：</p>

<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Mozilla 的 ES6 Promise 文档</a></li>
<li><a href="https://developers.google.com/web/fundamentals/getting-started/primers/promises">来自 Google 的 Promise 介绍</a></li>
<li><a href="http://www.datchley.name/es6-promises/">Dave Atchley 的 ES6 Promise 概述</a></li>
</ul>


<p>更多的 Promise <a href="http://www.datchley.name/promise-patterns-anti-patterns/">模式</a>和<a href="https://hackernoon.com/javascript-promises-best-practices-anti-patterns-b32309f65551">反模式</a></p>

<p><a href="https://medium.com/datafire-io">或者阅读来自 DataFire 团队的内容</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在 Node.js 中使用原生 ES 模块]]></title>
    <link href="http://blog.mirreal.net/blog/2017/09/13/using-es-modules-natively-in-node-dot-js/"/>
    <updated>2017-09-13T16:19:59+08:00</updated>
    <id>http://blog.mirreal.net/blog/2017/09/13/using-es-modules-natively-in-node-dot-js</id>
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="http://2ality.com/2017/09/native-esm-node.html">Using ES modules natively in Node.js</a></p>

<p>作者：<a href="https://twitter.com/rauschma">Axel Rauschmayer</a></p></blockquote>

<p>从版本 8.5.0 开始，Node.js 开始支持原生 ES 模块，可以通过命令行选项打开该功能。新功能很大程度上得归功于 <a href="https://twitter.com/bradleymeck">Bradley Farias</a>。</p>

<h2>1.演示</h2>

<p>这个示例的代码目录结构如下：</p>

<pre><code>esm-demo/
    lib.mjs
    main.mjs
</code></pre>

<p>lib.mjs：</p>

<pre><code class="javascript">export function add(x, y) {
    return x + y;
}
</code></pre>

<p>main.mjs：</p>

<pre><code class="javascript">import {add} from './lib.mjs';

console.log('Result: '+add(2, 3));
</code></pre>

<p>运行演示：</p>

<pre><code class="sh">$ node --experimental-modules main.mjs
Result: 5
</code></pre>

<h2>2.清单：需要注意的事情</h2>

<h3>ES 模块：</h3>

<ul>
<li><p>不能动态导入模块。但是 <a href="http://2ality.com/2017/01/import-operator.html">动态 import()</a> 的相关工作正在进行中，应该很快就能提供支持。</p></li>
<li><p>没有元变量，如 <code>__dirname</code> 和 <code>__filename</code>。但是，有一个的类似功能的提案：“<a href="https://github.com/tc39/proposal-import-meta">import.meta</a>”。看起来可能是这样：</p></li>
</ul>


<pre><code class="javascript">console.log(import.meta.url);
</code></pre>

<ul>
<li>现在所有模块标识符都是 URL（这部分在 Node.js 是新增的）：

<ul>
<li>文件 - 带文件扩展名的相对路径： <code>../util/tools.mjs</code></li>
<li>库 - 没有文件扩展名，也没有路径 <code>lodash</code></li>
<li>如何更好地使 npm 库在浏览器中也可用（不使用 bundler）仍有待观察。一种可能性是引入 RequireJS 风格的配置数据，将路径映射到实际路径。目前，在浏览器中使用 bare path 的模块标识符是非法的。</li>
</ul>
</li>
</ul>


<h3>与 CJS 模块的互操作性</h3>

<ul>
<li>你可以导入 CJS 模块，但它们总是只有默认的导出 - 即 <code>module.exports</code> 的值。让 CJS 模块支持命名导出已经在做了，但可能需要一段时间。如果你能帮忙，<a href="https://twitter.com/bradleymeck/status/906210545145184257">可以来做</a>。</li>
</ul>


<pre><code class="javascript">import fs1 from 'fs';
console.log(Object.keys(fs1).length); // 86

import * as fs2 from 'fs';
console.log(Object.keys(fs2)); // ['default']
</code></pre>

<ul>
<li>不能在 ES 模块中使用 require()。主要原因是：

<ul>
<li>路径解析工作稍有不同：ESM 不支持 <code>NODE_PATH</code> 和 <code>require.extensions</code>。而且，它的标识符始终是 URL 也会导致一些细微差异。</li>
<li>ES 模块始终以异步方式加载，这确保了与 Web 的最大兼容性。这种加载风格并不能通过 require() 混合使用同步加载 CJS 模块。</li>
<li>禁止同步模块加载也可以为 Top-level await 导入 ES 模块保留后路（一个当前正在考虑的功能）。</li>
</ul>
</li>
</ul>


<h2>3.早期版本的 Node.js 上的 ES 模块</h2>

<p>如果要在 8.5.0 之前的 Node.js 版本上使用 ES 模块，请参阅 John-David Dalton 的 <a href="https://github.com/standard-things/esm">@std/esm</a>。</p>

<p>提示：如果不启用任何可解锁的额外功能，将在 Node.js 保持 100％ 兼容原生 ES 模块.</p>

<h2>FAQ</h2>

<h3>什么时候可以不带命令行选项使用ES 模块？</h3>

<p>目前的计划是在 Node.js 10 LTS 中默认可使用 ES 模块。</p>

<h2>进一步阅读  </h2>

<p>有关 Node.js 和浏览器中 ES 模块的更多信息：</p>

<ul>
<li>“<a href="http://2ality.com/2017/01/babel-esm-spec-mode.html">Making transpiled ES modules more spec-compliant</a>” [using ES modules natively vs. transpiling them via Babel]</li>
<li>“<a href="http://2ality.com/2017/05/es-module-specifiers.html">Module specifiers: what’s new with ES modules?</a>” [Why <code>.mjs</code>? How are module specifiers resolved? Etc.]</li>
<li>“<a href="http://exploringjs.com/es6/ch_modules.html">Modules</a>” [in-depth chapter on ES modules in “Exploring ES6”]</li>
</ul>


<p>即将到来的 ECMAScript 提案：</p>

<ul>
<li>博客: “<a href="http://2ality.com/2017/01/import-operator.html">ES proposal: <code>import()</code> – dynamically importing ES modules</a>”</li>
<li>提案: “<a href="https://github.com/tc39/proposal-import-meta"><code>import.meta</code></a>”</li>
</ul>

]]></content>
  </entry>
  
</feed>
