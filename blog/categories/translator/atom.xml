<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Translator | Mirreal Note]]></title>
  <link href="http://blog.mirreal.net/blog/categories/translator/atom.xml" rel="self"/>
  <link href="http://blog.mirreal.net/"/>
  <updated>2017-09-17T17:45:07+08:00</updated>
  <id>http://blog.mirreal.net/</id>
  <author>
    <name><![CDATA[Mirreal Ellison]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[面向初学者的高阶组件介绍]]></title>
    <link href="http://blog.mirreal.net/blog/2017/07/19/higher-order-components-for-beginners/"/>
    <updated>2017-07-19T18:59:37+08:00</updated>
    <id>http://blog.mirreal.net/blog/2017/07/19/higher-order-components-for-beginners</id>
    <content type="html"><![CDATA[<blockquote><p>作者：Brandon Newton</p>

<p>原文：<a href="https://btnwtn.com/articles/higher-order-components-for-beginners">Higher-Order Components (HOCs) for Beginners</a></p>

<p>谈点：一篇面向初学者的 HOC 介绍。高阶组件听起来挺唬人的，只看名字恐怕不是那么容易明白究竟是何物，而且通常来讲高阶组件并不是组件，而是接受组件作为参数，并且返回组件的函数。早期利用 ES5 的 mixin 语法来做的事，基本都可以使用高阶组件代替，而且能做的还有更多。</p></blockquote>

<h2>前言</h2>

<p>写这篇文章的起因是其他关于高阶组件（Higher-Order Components）的文章，包含官方文档，都令初学者感到相当困惑。我知道有高阶组件这样一个东西，但不知道它到底有什么用。所以，想通过一篇文章来对高阶组件有一个更好的理解。</p>

<p>在此之前，我们需要先来讲一下 JavaScript 中的函数。</p>

<h2>ES6 箭头函数简介</h2>

<p>接下来将提供一些箭头函数的简单示例，如果之前没有使用过，可以认为它们与普通函数基本一致。下面的代码会展示箭头函数与普通函数的区别。</p>

<pre><code class="javascript">function () {
  return 42
}

// same as:
() =&gt; 42

// same as:
() =&gt; {
  return 42
}

function person(name) {
  return { name: name }
}

// same as:
(name) =&gt; {
  return { name: name }
}
</code></pre>

<p>阅读 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">MDN 的箭头函数文档</a> 了解更多信息。</p>

<h2>作为值的函数与部分调用</h2>

<p>就像是数字、字符串、布尔值 一样，函数也是值，意味着可以像传递其他数据一样传递函数，可以将函数作为参数传递给另外一个函数。</p>

<pre><code class="javascript">const execute = (someFunction) =&gt; someFunction()

execute(() =&gt; alert('Executed'))
</code></pre>

<p>也可以在在函数中返回一个函数：</p>

<pre><code class="javascript">const getOne = () =&gt; () =&gt; 1

getOne()()
</code></pre>

<p>之所以在 <code>getOne</code> 后面有两个 <code>()</code> ，是因为第一个返回的返回值是一个函数。如下：</p>

<pre><code class="javascript">const getOne = () =&gt; () =&gt; 1

getOne
//=&gt; () =&gt; () =&gt; 1

getOne()
//=&gt; () =&gt; 1

getOne()()
//=&gt; 1
</code></pre>

<p>从函数返回函数可以帮助我们追踪初始输入函数。例如，下面的函数接受一个数字作为参数，并返回一个将该参数乘以新参数的函数：</p>

<pre><code class="javascript">const multiply = (x) =&gt; (y) =&gt; x * y

multiply(5)(20)
</code></pre>

<p>这个示例跟上述 <code>getOne</code> 一样，在下面这个例子，让 x = 5，y = 20。</p>

<pre><code class="javascript">const multiply = (x) =&gt; (y) =&gt; x * y

multiply
//=&gt; (x) =&gt; (y) =&gt; x * y

multiply(5)
//=&gt; (y) =&gt; 5 * y

multiply(5)(20)
//=&gt; 5 * 20
</code></pre>

<p>在只传入一个参数调用 <code>multiply</code> 函数时，即部分调用该函数。比如，<code>multiply(5)</code> 讲得到一个将其输入值乘以 5 的函数，<code>multiply(7)</code> 将得到一个将其输入值乘以 7 的函数。依此类推。通过部分调用可以创建一个预定义功能的新函数：</p>

<pre><code class="javascript">const multiply = (x) =&gt; (y) =&gt; x * y

const multiplyByFive = multiply(5)
const multiplyBy100 = multiply(100)

multiplyByFive(20)
//=&gt; 100
multiply(5)(20)
//=&gt; 100

multiplyBy100(5)
//=&gt; 500
multiply(100)(5)
//=&gt; 500
</code></pre>

<p>一开始看起来似乎没什么用，但是，通过部分调用这种方式可以编写可读性更高，更易于理解的代码。举个例子，可以用一种更清晰的方式来代替 <a href="https://www.styled-components.com/docs/basics#adapting-based-on-props">style-components</a> 的函数插入语法。</p>

<pre><code class="javascript">// before
const Button = styled.button`
  background-color: ${({ theme }) =&gt; theme.bgColor}
  color: ${({ theme }) =&gt; theme.textColor}
`

&lt;Button theme={themes.primary}&gt;Submit&lt;/Button&gt;
// after
const fromTheme = (prop) =&gt; ({ theme }) =&gt; theme[prop]

const Button = styled.button`
  background-color: ${fromTheme("bgColor")}
  color: ${fromTheme("textColor")}
`

&lt;Button theme={themes.primary}&gt;Submit&lt;/Button&gt;
</code></pre>

<p>我们创建一个接受一个字符串作为参数的函数 <code>fromTheme("textColor")</code>：它返回一个接受具有 <code>theme</code> 属性的对象的函数：<code>({ theme }) =&gt; theme[prop]</code>，然后再通过初始传入的字符串 <code>"textColor"</code> 进行查找。我们可以做得更多，写类似的 <code>backgroundColor</code> 和 <code>textColor</code> 这种部分调用 <code>fromTheme</code> 的函数：</p>

<pre><code class="javascript">const fromTheme = (prop) =&gt; ({ theme }) =&gt; theme[prop]
const backgroundColor = fromTheme("bgColor")
const textColor = fromTheme("textColor")

const Button = styled.button`
  background-color: ${backgroundColor}
  color: ${textColor}
`

&lt;Button theme={themes.primary}&gt;Submit&lt;/Button&gt;
</code></pre>

<h2>高阶函数</h2>

<p>高阶函数的定义是，接受函数作为参数的函数。如果曾经使用过类似 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map">map</a> 这样的函数，可能已经很熟悉高阶函数。如果不熟悉 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map">map</a>，它是一个数组遍历的方法，接受一个函数作为参数应用到数组中的每个元素。例如，可以像这样对一个数组作平方：</p>

<pre><code class="javascript">const square = (x) =&gt; x * x

[1, 2, 3].map(square)
//=&gt; [ 1, 4, 9 ]
</code></pre>

<p>可以实现一个我们自己的 <code>map</code> 版本来说明这个概念：</p>

<pre><code class="javascript">const map = (fn, array) =&gt; {
  const mappedArray = []

  for (let i = 0; i &lt; array.length; i++) {
    mappedArray.push(
      // apply fn with the current element of the array
      fn(array[i])
    )
  }

  return mappedArray
}
</code></pre>

<p>然后再使用我们的 map 版本来对一个数组作平方：</p>

<pre><code class="javascript">const square = (x) =&gt; x * x

console.log(map(square, [1, 2, 3, 4, 5]))
//=&gt; [ 1, 4, 9, 16, 25 ]
</code></pre>

<blockquote><p>译者注：我们也可以将 map 方法从对象中解耦出来：</p>

<pre><code class="javascript">const map = (fn, array) =&gt; Array.prototype.map.call(array, fn)
</code></pre>

<p>这样也可以像上述例子一样调用。
或者更函数式的做法，再来点柯里化：</p>

<pre><code class="javascript">const map = array =&gt; fn =&gt; Array.prototype.map.call(array, fn)
</code></pre></blockquote>

<p>或者是返回一个 <code>&lt;li&gt;</code>的 React 元素数组：</p>

<pre><code class="javascript">const HeroList = ({ heroes }) =&gt; (
  &lt;ul&gt;
    {map((hero) =&gt; (
      &lt;li key={hero}&gt;{hero}&lt;/li&gt;
    ), heroes)}
  &lt;/ul&gt;
)

&lt;HeroList heroes=[
  "Wonder Woman",
  "Black Widow",
  "Spider Man",
  "Storm",
  "Deadpool"
]/&gt;
/*=&gt; (
  &lt;ul&gt;
    &lt;li&gt;Wonder Woman&lt;/li&gt;
    &lt;li&gt;Black Widow&lt;/li&gt;
    &lt;li&gt;Spider Man&lt;/li&gt;
    &lt;li&gt;Storm&lt;/li&gt;
    &lt;li&gt;Deadpool&lt;/li&gt;
  &lt;/ul&gt;
)*/
</code></pre>

<h2>高阶组件</h2>

<p>我们知道，高阶函数是接受函数作为参数的函数。在 React 中，任何返回 <a href="https://facebook.github.io/react/docs/jsx-in-depth.html">JSX</a> 的函数都被称为无状态函数组件，简称为函数组件。基本的函数组件如下所示：</p>

<pre><code class="javascript">const Title = (props) =&gt; &lt;h1&gt;{props.children}&lt;/h1&gt;

&lt;Title&gt;Higher-Order Components(HOCs) for React Newbies&lt;/Title&gt;
//=&gt; &lt;h1&gt;Higher-Order Components(HOCs) for React Newbies&lt;/h1&gt;
</code></pre>

<p>高阶组件则是<em>接受组件作为参数并返回组件的函数</em>。如何使用传入组件完全取决于你，甚至可以完全忽视它：</p>

<pre><code class="javascript">// Technically an HOC
const ignore = (anything) =&gt; (props) =&gt; &lt;h1&gt;:)&lt;/h1&gt;

const IgnoreHeroList = ignore(HeroList)
&lt;IgnoreHeroList /&gt;
//=&gt; &lt;h1&gt;:)&lt;/h1&gt;
</code></pre>

<p>可以编写一个将输入转换成大写的 HOC：</p>

<pre><code class="javascript">const yell = (PassedComponent) =&gt;
  ({ children, ...props }) =&gt;
    &lt;PassedComponent {...props}&gt;
      {children.toUpperCase()}!
    &lt;/PassedComponent&gt;

const Title = (props) =&gt; &lt;h1&gt;{props.children}&lt;/h1&gt;
const AngryTitle = yell(Title)

&lt;AngryTitle&gt;Whatever&lt;/AngryTitle&gt;
//=&gt; &lt;h1&gt;WHATEVER!&lt;/h1&gt;
</code></pre>

<p>你也可以返回一个有状态组件，因为 JavaScript 中的类不过是函数的语法糖。这样就可以使用到 React 生命周期的方法，比如 <code>componentDidMount</code>。这是 HOCs 真正有用的地方。我们现在可以做一些稍微有趣点的事，比如将 HTTP 请求的结果传递给函数组件。</p>

<pre><code class="javascript">const withGists = (PassedComponent) =&gt;
  class WithGists extends React.Component {
    state = {
      gists: []
    }

    componentDidMount() {
      fetch("https://api.github.com/gists/public")
      .then((r) =&gt; r.json())
      .then((gists) =&gt; this.setState({
        gists: gists
      }))
    }

    render() {
      return (
        &lt;PassedComponent
          {...this.props}
          gists={this.state.gists}
        /&gt;
      )
    }
  }


const Gists = ({ gists }) =&gt; (
  &lt;pre&gt;{JSON.stringify(gists, null, 2)}&lt;/pre&gt;
)

const GistsList = withGists(Gists)

&lt;GistsList /&gt;
//=&gt; Before api request finishes:
// &lt;Gists gists={[]} /&gt;
//
//=&gt; After api request finishes:
// &lt;Gists gists={[
//  { /* … */ },
//  { /* … */ },
//  { /* … */ }
// ]} /&gt;
</code></pre>

<p><code>withGists</code> 会传递 gist api 调用的结果，并且你可以在任何组件上使用。<a href="https://codesandbox.io/embed/o2YpJnpDj">点击这里</a> 可以看到一个更加完整的例子。</p>

<h2>结论：高阶组件是 🔥🔥🔥</h2>

<p>react-redux 也是使用 HOC， <a href="https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options">connect</a> 将应用 store 的值传递到“已连接” 的组件。它还会执行一些错误检查和组件生命周期优化，如果手动完成将导致编写大量重复代码。</p>

<p>如果你发现自己在不同地方编写了大量的代码，那么也可以将代码重构成可重用的 HOC。</p>

<p>HOCs 非常具有表现力，可以使用它们创造很多很酷的东西。</p>

<p>尽可能地保持你的 HOC 简单，<em>不要编写需要阅读长篇大论才能理解的代码</em>。</p>

<h3>附加练习</h3>

<p>下面有一些练习，来巩固对 HOC 的理解：</p>

<ul>
<li>写一个反转其输入的 HOC</li>
<li>编写一个HOC，将 API 中的数据提供给组件</li>
<li>写一个HOC来实现 <a href="https://facebook.github.io/react/docs/react-component.html#shouldcomponentupdate"><code>shouldComponentUpdate</code></a>，<a href="https://facebook.github.io/react/docs/optimizing-performance.html#avoid-reconciliation">以避免更新</a>。</li>
<li>编写一个 HOC，使用 <a href="https://facebook.github.io/react/docs/react-api.html#react.children.toarray"><code>React.Children.toArray</code></a> 对传入组件子元素进行排序。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CSS Animations vs Web Animations API]]></title>
    <link href="http://blog.mirreal.net/blog/2017/06/26/css-animations-vs-web-animations-api-slash/"/>
    <updated>2017-06-26T20:47:08+08:00</updated>
    <id>http://blog.mirreal.net/blog/2017/06/26/css-animations-vs-web-animations-api-slash</id>
    <content type="html"><![CDATA[<blockquote><p>作者：Ollie Williams</p>

<p>原文：<a href="https://css-tricks.com/css-animations-vs-web-animations-api/">CSS Animations vs Web Animations API</a></p></blockquote>

<p>在  JavaScript 有一个原生动画 API 叫 Web Animations API，在这篇文章中简称为 WAAPI。MDN 上已经有 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API">很好的文档</a>，而且，Dan Wilson 为此写了 <a href="http://danielcwilson.com/blog/2015/07/animations-part-1/">一个很棒的文章系列</a>。</p>

<p>在本文中，我们一起来对比一下 WAAPI 和 CSS 动画。</p>

<h2>关于浏览器支持</h2>

<p>尽管浏览器原生支持仍然有限，但 WAAPI 有一个全面和强大的 <a href="https://github.com/web-animations/web-animations-js">polyfill</a>，使得现在就能在生产环境使用。</p>

<p>同样地，可以在 <a href="https://github.com/web-animations/web-animations-js">Can I Use</a> 查看浏览器兼容性数据。然而，这并没有提供很好的信息来支持 WAAPI 的所有子功能。这里有一个检查工具：</p>

<p>See the Pen <a href="https://codepen.io/danwilson/pen/xGBKVq/">WAAPI Browser Support Test</a> by Dan Wilson (<a href="https://codepen.io/danwilson">@danwilson</a>) on <a href="https://codepen.io/">CodePen</a>.</p>

<p>要想再没有 polyfill 的情况下体验所有功能，请使用 Firefox Nightly。</p>

<h2>WAAPI 的基础知识</h2>

<p>如果你曾经使用 jQuery  的 <code>.animate()</code>，那么应该会觉得 WAAPI 的基本语法看起来很熟悉。</p>

<pre><code class="javascript">var element = document.querySelector('.animate-me');
element.animate(keyframes, 1000);
</code></pre>

<p><code>animate</code> 方法接受两个参数：关键帧和持续时间。与 jQuery 相比的优势是，不仅是浏览器内置，而且性能也更好。</p>

<p>第一个参数，关键帧，是一个对象数组，每个对象都是动画中的一个关键帧。看这个简单的例子：</p>

<pre><code class="javascript">var keyframes = [
  { opacity: 0 },
  { opacity: 1 }
];
</code></pre>

<p>第二个参数，持续时间，指的是想要动画持续多久，在上面的例子中是 1000 毫秒。接下来看一个更令人兴奋的例子。</p>

<h2>用 WAAPI 重新创建一个 animista 的 CSS 动画</h2>

<p>这里有一些从 <a href="http://animista.net/">animista</a> 拉取的 CSS 代码，被称为 slide-in-blurred-top 的入场动画。看起来很漂亮</p>

<p>在 <a href="http://animista.net/play/entrances/slide-in-blurred/slide-in-blurred-top">实际PERF</a> 比这个 GIF 效果好很多。</p>

<p>以下是 CSS 中的关键帧：</p>

<pre><code class="css">0% {
  transform: translateY(-1000px) scaleY(2.5) scaleX(.2);
  transform-origin: 50% 0;
  filter: blur(40px);
  opacity: 0;
}
100% {
  transform: translateY(0) scaleY(1) scaleX(1);
  transform-origin: 50% 50%;
  filter: blur(0);
  opacity: 1;
}
</code></pre>

<p>在 WAAPI 中代码基本相同：</p>

<pre><code class="javascript">var keyframes = [
  {
    transform: 'translateY(-1000px) scaleY(2.5) scaleX(.2)',
    transformOrigin: '50% 0',
    filter: 'blur(40px)',
    opacity: 0
  },
  {
    transform: 'translateY(0) scaleY(1) scaleX(1)',
    transformOrigin: '50% 50%',
    filter: 'blur(0)',
    opacity: 1
  }
];
</code></pre>

<p>可以看出，将关键帧应用到需要动画的元素上是多么容易：</p>

<pre><code class="javascript">element.animate(keyframes, 700);
</code></pre>

<p>为了简单起见，只指定了持续时间。但是，我们可以使用这个第二个参数来传递更多的选项，至少也应该指定一个缓动效果。以下是所有可用选项的完整列表，其中包含一些示例值：</p>

<pre><code class="javascript">var options = {
  iterations: Infinity,
  iterationStart: 0,
  delay: 0,
  endDelay: 0,
  direction: 'alternate',
  duration: 700,
  fill: 'forwards',
  easing: 'ease-out',
}
element.animate(keyframes, options);
</code></pre>

<p>加上这些选项，我们的动画将从头开始，没有任何延迟，在动画完成后往返循环播放。</p>

<p>不爽的是，对于熟悉 CSS 动画的人来说，一些术语跟我们习惯的有所不同。好处是打字会更快一些！</p>

<ul>
<li>使用 <code>easing</code> 而不是 <code>animation-timing-function</code></li>
<li>不是 <code>animation-iteration-count</code>，而是 <code>iterations</code>。如果我们希望动画永远重复，使用 <code>Infinity</code> 而不是 <code>infinite</code>。有点混乱， <code>Infinity</code> 不带引号。<code>Infinity</code> 是一个 JavaScript 关键字，而其他值都是字符串。</li>
<li>我们使用毫秒而不是秒，对于之前写过许多 JavaScript 的人来说，这应该是一样的。（你也可以在 CSS 动画中使用毫秒数，但很少有人使用。）</li>
</ul>


<p>我们来仔细看看一个选项：<code>iterationStart</code>。</p>

<p>当我第一次碰到 <code>iterationStart</code> 有点困惑。为什么要从指定的迭代开始，而不是只要减少迭代次数？当使用十进制数时，此选项非常有用。例如，可以将其设置为  <code>.5</code>，动画将开始一半。要做一个完整的动画需要两个一半，所以如果迭代次数设置为 1，并且将 <code>iterationStart</code> 设置为  <code>.5</code>，动画将从一半到动画结束播放，然后从动画开头开始，结束于中间！</p>

<p>值得注意的是，也可以将迭代次数设置为小于 1。例如：</p>

<pre><code class="javascript">var option = {
  iterations: .5,
  iterationStart: .5
}
</code></pre>

<p>这样，动画会从中间开始，一直播放到最后。</p>

<p>endDelay：如果要将多个动画串在一起，但是希望在一个动画的结尾和后续动画的开始之间存在差距，这时 endDelay 就很有用。这是一个有用的视频，由 Patrick Brosset 来解释。</p>

<p><a href="https://www.youtube.com/embed/hWe-qukNrN8">一个 YouTube 的视频</a></p>

<h2>缓动（easing）</h2>

<p>在任何动画中，缓动都是最重要的元素之一。WAAPI 为我们提供了两种不同的方式设置缓动 - 在我们的关键帧数组或我们的选项对象内。</p>

<p>在 CSS 中，如果使用 <code>animation-timing-function: ease-in-out</code> 你可能会认为动画会缓慢开始，然后缓慢结束。实际上，这些缓动应用在关键帧之间，而不是整个动画。这可以对动画的感觉进行细粒度的控制。WAAPI 也提供这种功能。</p>

<pre><code class="javascript">var keyframes = [
  { opacity: 0, easing: 'ease-in' },
  { opacity: 0.5, easing: 'ease-out' },
  { opacity: 1 }
]
</code></pre>

<p>值得注意的是，在 CSS 和 WAAPI 中，不应该传入最后一帧的缓动值，因为这将不起作用。可是很多人会犯这种错误。</p>

<p>有时候，在整个动画中添加缓动效果更为直观。这在 CSS 是不可能的，但现在可以在 WAAPI 中实现。</p>

<pre><code class="javascript">var options = {
  duration: 1000,
  easing: 'ease-in-out',
}
</code></pre>

<p>可以看到这两种缓动在 CodePen 上的区别：</p>

<p><a href="https://codepen.io/cssgrid/pen/OmrVeQ">点我查看</a></p>

<h2>缓动 vs 线性</h2>

<p>值得注意的是 CSS 动画和 WAAPI 之间的另一个区别：<strong>在 CSS 中 默认值是 ease，而在 WAAPI 默认是 linear。</strong> ease 实际上是 <code>ease-in-out</code> 的一个版本，当你想偷懒时这是一个非常好的选择。同时，线性代表致命的沉闷和无生命 - 一致的速度看起来机械和不自然。它被选为默认值，可能因为它是最中立的选项。然而，在使用 WAAPI 时，更好是使用缓动，以免动画看起来很乏味和机械。</p>

<h2>性能</h2>

<p>WAAPI 提供与 CSS 动画相同的性能改进，尽管这并不意味着一定就是平滑的动画。</p>

<p>希望这个 API 的性能优化做到，使我们可以避免使用 <code>will-change</code>和 <code>translateZ</code> 成为可能。但是，至少在目前的浏览器实现中，这些属性在处理性能问题方面仍然是有帮助，有必要的。</p>

<p>但是，如果你的动画有延迟，则无需担心使用 <code>will-change</code>。web animations 规范的主要作者对 <a href="https://damp-lake-50659.herokuapp.com/">Animation for Work Slack community</a> 提出了一些有趣的建议，希望他不介意我在这里重复：</p>

<blockquote><p>如果有一个正向的延迟，不需要使用 <code>will-change</code>，因为浏览器将在延迟开始时进行分层，当动画启动时，它将准备就绪。</p></blockquote>

<h2>WAAPI 对战 CSS 动画？</h2>

<p>WAAPI 为我们提供了一套已经在 CSS 中实现的 JavaScript 语法。然而，它们不应该被视为对手。如果我们坚持使用 CSS 完成动画和转换，那么我们可以在 WAAPI 进行动画交互。</p>

<h2>动画对象</h2>

<p><code>.animate()</code> 方法不仅处理元素的动画，它也返回一些东西。</p>

<pre><code class="javascript">var myAnimation = element.animate(keyframes, options);
</code></pre>

<p>在控制台中查看的动画对象</p>

<p>如果我们在控制台中查看返回值，会发现这是一个动画对象。这为我们提供了各种各样的功能，其中一些是不言自明，比如 <code>myAnimation.pause()</code>。通过更改 <code>animation-play-state</code> 属性，我们可以通过 CSS 动画实现类似的结果，但 WAAPI 语法比 <code>element.style.animationPlayState = "paused"</code> 更简洁。我们也可以通过 <code>myAnimation.reverse()</code> 轻松反转动画，同样地，跟我们使用脚本更改 CSS 的 <code>animation-direction</code> 属性相比，稍微有点进步。</p>

<p>然而，到目前为止，使用 JavaScript 操作 <code>@keyframe</code> 并不是件容易的的事。即使是重新启动动画这样简单的事，也是需要一些技巧的，就像 Chris Coyier <a href="https://css-tricks.com/restart-css-animation/">先前写过的那样</a>。使用 WAAPI，我们可以简单地使用 <code>myAnimation.play()</code> ，如果动画已经完成，将从一开始就重播动画，或者如果我们暂停播放，则从中间迭代播放动画。</p>

<p>我们甚至可以轻松地改变动画的速度。</p>

<pre><code class="javascript">myAnimation.playbackRate = 2; // speed it up
myAnimation.playbackRate = .4; // use a number less than one to slow it down
</code></pre>

<h2>getAnimations()</h2>

<p>这个方法将返回所有动画对象的数组，包含使用 WAAPI 定义的动画和 CSS 转换或动画。</p>

<pre><code class="javascript">element.getAnimations() // returns any animations or transitions applied to our element using  CSS or WAAPI
</code></pre>

<p>如果你喜欢使用 CSS 来定义和使用动画，<code>getAnimations()</code>  允许 API​​ 与 <code>@keyframes</code> 结合使用。你可以继续使用 CSS 进行大部分动画工作，然后在需要 API 时获得使用 API 的优势。</p>

<p>即使一个 DOM 元素只使用到一个动画，<code>getAnimations()</code> 也将始终返回一个数组。我们使用那个单一的动画对象来处理。</p>

<pre><code class="javascript">var h2 = document.querySelector("h2");
var myCSSAnimation = h2.getAnimations()[0];
</code></pre>

<p>我们也可以在 CSS 动画中使用 web animation API :)</p>

<pre><code class="javascript">myCSSAnimation.playbackRate = 4;
myCSSAnimation.reverse();
</code></pre>

<h2>Promise 和 Event</h2>

<p>很多通过 CSS 触发的事件，现在我们已经可以使用 JavaScript 代码来完成：   <code>animationstart</code>，<code>animationend</code>，<code>animationiteration</code> 和 <code>transitionend</code>。之前经常需要监听动画或转换的结束，以便从 DOM 中删除应用的元素。</p>

<p>在动画对象可以使用 WAAPI 来完成 <code>animationend</code> 或 <code>transitionend</code> 做的事情：</p>

<pre><code class="javascript">myAnimation.onfinish = function() {
  element.remove();
}
</code></pre>

<p>WAAPI 为我们提供了两个选择：event 和 promise。动画对象的 <code>.finished</code> 方法会返回一个在动画结束时的 promise。下面这段代码是上面例子的 promise 版本：</p>

<pre><code class="javascript">myAnimation.finished.then(() =&gt;
  element.remove())
</code></pre>

<p>我们来看看来自 Mozilla 开发者网络中的一个稍微复杂点的例子。<code>Promise.all</code> 接受一个 promise 的数组，一旦所有 promise 完成才会运行回调函数。可以看出，<code>element.getAnimations()</code> 返回的是一个动画对象数组。我们可以将数组中的所有动画对象 map 到每个动画对象的 <code>.finished</code>上，这样就获得需要的 promise 数组。</p>

<p>在这个例子中，只有在页面上的所有动画完成后，我们的函数才能运行。</p>

<pre><code class="javascript">Promise.all(document.getAnimations().map(animation =&gt;
  animation.finished)).then(function() {           
    // do something cool
  })
</code></pre>

<h2>未来</h2>

<p>本文中提到的功能只是一个开始。从目前的规范和实施来看，未来会有一个很强大动画 API。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[喜欢用 Git 做的一些小事]]></title>
    <link href="http://blog.mirreal.net/blog/2017/06/12/little-things-i-like-to-do-with-git/"/>
    <updated>2017-06-12T18:00:00+08:00</updated>
    <id>http://blog.mirreal.net/blog/2017/06/12/little-things-i-like-to-do-with-git</id>
    <content type="html"><![CDATA[<blockquote><p>作者：<a href="https://twitter.com/csswizardry">@csswizardry</a></p>

<p>原文：<a href="https://csswizardry.com/2017/05/little-things-i-like-to-do-with-git/">Little Things I Like to Do with Git</a></p>

<p>随便说点：这篇文章主要从管理者的角度谈论了使用 git 的心得，使用大量篇幅介绍 <code>git log</code> 的一些方法和技巧。</p>

<p>同样地，发现很多人其实并没有深入全面地去了解过 git 的用法，作为一名开发人员，大多数时候只要会使用 <code>git pull</code>，<code>git add</code>，<code>git commit</code>，<code>git push</code> 似乎就足够，还有很大一部分人只使用特定的图形化工具。但事实上真的是这样吗，可能在遇到某个稍微高级一点的问题或者需求就手足无措。对于某个特定个体而言，很多场景我们未必会遇到，即使碰到也可以现场寻求搜索工具的帮助，这也是一种学习方式，无意否定这种方式，但最大的问题就是只见一叶而难以窥见森林。在这里推荐一个小工具 <a href="https://github.com/Gazler/githug">githug</a>，通过一种比较轻松的游戏的方式来一探全貌。</p></blockquote>

<p>在跟我的朋友 Tim 聊天的时候，谈到我有多喜欢 Git。作为经常使用的一个工具，它强大而优雅。在这里，介绍一下我个人使用得最多，同时也是最有用的一些小技巧。</p>

<h2>管理者面板</h2>

<p>无论你认为在工作中的游戏化（gamification）和竞争是好是坏，对于这个话题在不同的时间可能是完全不同的结论。但如果你对团队成员在项目中的提交数量感兴趣，使用 <code>shortlog</code> 就可以找到答案：</p>

<p>（请忽略我）</p>

<p>（我只是占位的）</p>

<pre><code class="sh">$ git shortlog -sn
    80  Harry Roberts
    34  Samantha Peters
     3  Tom Smith
</code></pre>

<p><code>shortlog</code> 可以视作对 <code>git log</code> 的概要。</p>

<ul>
<li><code>-s</code>选项将隐藏提交描述，仅提供提交计数摘要</li>
<li><code>-n</code> 选项将根据每个作者的提交数对输出进行排序，而不是默认的按作者字母顺序。</li>
</ul>


<p>上面显示的是项目生命周期的所有提交，但是如果想查看在特定时间内的情况，可以使用 <code>--since</code> 和 <code>--until</code> 选项：</p>

<pre><code class="sh">$ git shortlog -sn --since='10 weeks' --until='2 weeks'
    59  Harry Roberts
    24  Samantha Peters
</code></pre>

<p>我为此配置了别名 <code>$ git stats</code></p>

<h2>责任人</h2>

<p>Git 有一个非常有用的 <code>blame</code> 功能，允许我们查看特定代码段的负责开发人员：</p>

<pre><code class="sh"># See who last changed lines 5 through 10 of the buttons’ CSS:
$ git blame -L5,10 _components.buttons.scss
</code></pre>

<p>这一条放在这里讲好像有点过头，像是我们在找开发人员哪些地方做错了。但也不完全是这样，另一方面，他们可能已经做了一些我们想要了解的特别厉害或是印象深刻的事情。我们原本会问，哇！我之前还没有看到这个功能，还想知道是谁做的。</p>

<p>由于是从 SVN 转到 Git，我使用 <code>praise</code> 作为 <code>blame</code> 的别名，这样二者都可以使用：</p>

<pre><code class="sh">$ git config --global alias.praise blame
</code></pre>

<p>即，我也可以这样做：</p>

<pre><code class="sh"># Find out who implemented Resource Hints and buy them a coffee:
$ git praise -L18,23 _includes/head.html
</code></pre>

<p>只是一点小变化，但效果不错。</p>

<h2>隐藏空白提示</h2>

<p>当使用 <code>diff</code> 或 <code>show</code> 查看具有大量空白变化的版本对比时，会有很多视觉噪音干扰我们，使得很难看到更重要的变化内容。</p>

<p>幸运的是，去除这种空白提示非常容易，在 <code>git diff</code> 和 <code>git show</code> 使用 <code>-w</code> 选项就可以轻松搞定。比如，之前：</p>

<pre><code> a {
   color: $color-links;

-&amp;:hover {
-  color: $color-links-hover;
-}
+  &amp;:hover {
+    color: $color-links-hover;
+    text-decoration: underline;
+  }

}
</code></pre>

<p>使用 <code>-w</code> 之后：</p>

<pre><code> a {
   color: $color-links;

   &amp;:hover {
     color: $color-links-hover;
+    text-decoration: underline;
   }

}
</code></pre>

<p>现在可以很容易看出，唯一有意义的变化是增加了 <code>text-decoration: underline;</code>，而其余​​的 <code>diff</code> 是有点误导性的。</p>

<h2>仅显示单词的变化而不是整行</h2>

<p>写代码跟写文章不同，查看变化的单词而不是整行通常会更有用; 这在编辑 markdown 文档时尤其有用，就像现在。</p>

<p>幸运的是，我们只要使用 <code>--word-diff</code> 选项就能显示单词的变化：</p>

<pre><code class="sh">$ git diff --word-diff
</code></pre>

<p>跟不使用 <code>--word-diff</code> 选项的区别还是很大的：</p>

<pre><code>-My friend Tom recently gave an excellent talk
+My good friend Tom gave an excellent talk
</code></pre>

<p>如果启用 <code>--word-diff</code>，我们能得到更便于理解和更有用的概览：</p>

<pre><code>My {+good+} friend Tom [-recently-] gave an excellent talk
</code></pre>

<p>注意只有变化的文本被突出显示（通过 <code>{+ +}</code> 和 <code>[- -]</code>)</p>

<h2>查看最近工作的分支</h2>

<p>在任何给定的项目，在许多不同的分支之间切换是很常见的，并且跟踪它们可能相当棘手。我们可以让 Git 帮助我们解决这个问题：</p>

<pre><code class="sh">$ git for-each-ref --count=10 --sort=-committerdate refs/heads/ --format="%(refname:short)"
</code></pre>

<p>通过这个命令可以知道最近在工作的 10（&ndash;count=10）个分支，按照上次工作的时间排序。只显示本地分支（<code>refs/heads/</code>），并通过 <code>--format</code> 选项获得更友好的呈现方式。</p>

<p>这是一个有点冗长的命令，所以我为此配置别名 <code>$ git recent</code>。</p>

<pre><code class="sh">git config --global alias.recent "for-each-ref --count=10 --sort=-committerdate refs/heads/ --format=\"%(refname:short)\""
</code></pre>

<h2>看到每个人都在做什么</h2>

<p>有时候，特别是对于团队领导，了解团队成员在所有分支的行为概览是很有用的。再一次地，Git 可以让这一切变得很容易：</p>

<pre><code class="sh">$ git log --all --oneline --no-merges
</code></pre>

<p>这可以得到一份关于所有人的日志报告简化版（带有 <code>--no-merges</code> 选项）</p>

<p>我们也可以通过 <code>--since</code> 选项来限制返回的提交数量：</p>

<pre><code class="sh">$ git log --all --since='2 weeks' --oneline --no-merges
</code></pre>

<p>这样我们可以看到，在过去的两个星期里，每个人都在做什么。</p>

<p>可以配置一个别名 <code>$ git overview</code></p>

<pre><code class="sh">git config --global alias.overview "log --all --since='2 weeks' --oneline --no-merges"
</code></pre>

<h2>提醒你自己已经做了什么</h2>

<p>当你回到一个比较旧的项目，或是在长时间休息之后回到办公室，可能不知道你最后在做什么工作，这种情况时常发生。我们可以通过 Git 轻松获得我们在项目中的工作情况：</p>

<pre><code class="sh">$ git log --all --oneline --no-merges --author=&lt;your email address&gt;
</code></pre>

<p>和上一条很类似，只是我们将日志限制于我们自己的提交，也可以增加 <code>--since</code> 限制。</p>

<p>这也有一个别名 <code>$ git recap</code>。</p>

<pre><code class="sh">git config --global alias.recap "log --all --oneline --no-merges --author=name@mail.com"
</code></pre>

<h2>今天的工作</h2>

<p>同样地，不在这里讨论如何衡量开发人员的生产力，但我觉得让客户知道我在任何一天的工作情况是很有用的。不是要你保留完成任务的详细列表，我们可以使用 Git 获取所有这些信息：</p>

<pre><code class="sh">$ git log --since=00:00:00 --all --no-merges --oneline --author=&lt;your email address&gt;
</code></pre>

<p>这将记录（<code>log</code>） 你工作的所有（<code>--all</code>）分支，谁（<code>--author</code>）从（<code>--since</code>）午夜开始都做了什么，（不包括合并提交 <code>--no-merges</code>），并提供一个简单的一行 （<code>--oneline</code>） 概述。</p>

<p>我有这个别名 <code>$ git today</code>。</p>

<pre><code class="sh">git config --global alias.today "log --since=00:00:00 --all --no-merges --oneline --author=name@mail.com"
</code></pre>

<h2>生成更改日志</h2>

<p>维护一份 CHANGELOG 可能有点乏味，我们必须查看自上次发布以来所做的所有工作，然后提取其中有用的部分。幸运的是，我们可以使用 Git 来给我们一个好的开头：</p>

<pre><code class="sh">$ git log --oneline --no-merges &lt;last tag&gt;..HEAD
</code></pre>

<p>注意：<code>HEAD</code> 是可选的，如果你省略（即&hellip; &ndash;no-merges <last tag>..），<code>HEAD</code> 会是隐含的，当然这样可以节省几次敲击键盘的时间。</p>

<p>这将创建一个简化的日志，显示最后一个发布版本和 <code>HEAD</code> 之间的所有提交（不包括合并提交）。</p>

<p>例如：</p>

<pre><code class="sh">$ git log --oneline --no-merges 1.0.0..
1257b95 [refs #00019] Bump version
2b9b28e [refs #00019] Add auto width class
17b8eb1 [refs #00015] Tidy up README.md
bbe7d05 [refs #00012] Rename Supercell main mixin
</code></pre>

<p>这告诉我，自从上次发布（1.0.0）到当前项目状态（<code>HEAD</code>），已经完成哪些工作。这对于 CHANGELOG 来说是一个很好的参考。</p>

<p>注意：不仅仅适用于 tag，还可以使用提交哈希。</p>

<h2>检查需要拉取哪些变化</h2>

<p>如果你在一段时间内不在项目，可能需要先检查上游的变更，然后再将这些更新下载到本地分支。</p>

<pre><code class="sh">$ git log --oneline --no-merges HEAD..&lt;remote&gt;/&lt;branch&gt;
</code></pre>

<p>注意：同样地，<code>HEAD</code> 在这里是可选的，省略将使其隐含。</p>

<p>例如，让我们来看看你在度假时在特性分支做了什么：</p>

<pre><code class="sh">$ git checkout feature/fonts
$ git fetch
$ git log --oneline --no-merges ..origin/feature/fonts
</code></pre>

<p>我使用这个别名 <code>$ git upstream</code>。</p>

<h2>检查即将上传的内容</h2>

<p>最好的情况是可以经常提交和上传，但如果某种原因导致有大量的本地提交尚未上传，可以快速回顾一下都是什么。</p>

<p>为了做到这一点，我们反转之前的命令就能轻松实现：</p>

<pre><code class="sh">$ git log --oneline --no-merges &lt;remote&gt;/&lt;branch&gt;..HEAD
</code></pre>

<p>例如：</p>

<pre><code class="sh">$ git fetch
$ git log --oneline --no-merges origin/feature/fonts..HEAD
</code></pre>

<p>注意：同样地，<code>HEAD</code> 在这里是可选的，省略将使其隐含。</p>

<p>这将记录 <code>HEAD</code> 需要上传到 <code>&lt;remote&gt;/&lt;branch&gt;</code> 的提交。</p>

<p>我使用这个别名 <code>$ git local</code>。</p>

<h2>查看复杂日志</h2>

<p>上面的每一个例子都使用简化的日志，因为只想快速了解发生了什么。对于更多细节，我使用带有 <code>--graph</code> 选项的日志和一些额外的选项：</p>

<pre><code class="sh">$ git log --graph --all --decorate --stat --date=iso
</code></pre>

<p>这将给出所有（<code>--all</code>）分支基于 <code>--graph</code> 的提交记录 <code>--stat</code>（添加，删除）日志。<code>--decorate</code> 选项会告诉我们提交信息适用于那些分支，还包含一个更加严格的日期格式。</p>

<p>我使用这个别名 <code>$ git graph</code>。</p>

<pre><code class="sh">git config --global alias.graph "log --graph --all --decorate --stat --date=iso"
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[编写现代 JavaScript 代码]]></title>
    <link href="http://blog.mirreal.net/blog/2017/06/02/writing-modern-javascript-code/"/>
    <updated>2017-06-02T18:00:00+08:00</updated>
    <id>http://blog.mirreal.net/blog/2017/06/02/writing-modern-javascript-code</id>
    <content type="html"><![CDATA[<blockquote><p>原文作者：<a href="https://twitter.com/scastiel">Sébastien Castiel</a></p>

<p>原文链接：<a href="https://dev.to/scastiel/writing-modern-javascript-code">Writing modern JavaScript code</a></p>

<p>说点什么：这是一篇很朴素的文章，讲的道理都懂，但实际上，在工作中遇到类似的情形却未必如此，编写可维护，可阅读，更安全的代码是我们应有的责任。</p></blockquote>

<p>是不是还认为 JavaScript 是一门用于在光标悬浮时改变页面元素的语言？这些日子已经不复存在，每一种语言都在随着时间推移而发展，我们使用语言的方式同样也在发展。看一下你一两年前写的代码：会感到羞愧吗？如果是的话，这篇文章应该很适合你。</p>

<p>这里会列出一些所谓的最佳实践，目的是让你的 JavaScript 代码更容易编写，阅读和维护。</p>

<h2>使用可格式化代码的 linter</h2>

<p>第一个建议是使用 linter 工具，可以帮助你检查在不同文件是否遵守一致的规则，尤其是当不同开发人员在同一个项目上工作：缩进，括号中的空格，替换 <code>==</code> 为 <code>===</code> &hellip;</p>

<p>但更重要的是，尽可能使用 linter 工具自动修复代码。<a href="http://eslint.org/">ESLint</a> 就做得很好（带有 <code>--fix</code> 选项），而且与所有主流 IDE 完美集成，可以在保存时自动修复文件。</p>

<p>还可以使用 <a href="https://github.com/prettier/prettier">Prettier</a>，不过这款工具更注重格式化而不是静态检查，但处理后的结果基本相同。</p>

<p>下一步将介绍与 linter 工具一起使用的规则：</p>

<h2>为你的 linter 定制现代化的规则</h2>

<p>如果不知道你的代码需要什么样的规则，可以参考：<a href="https://standardjs.com/">StandardJS</a>。这是一个<strong>非常</strong>严格的 linter，无法修改配置，但里面的每一条规则已经越来越多地被社区接纳。比如：</p>

<ul>
<li>使用 2 个空格缩进（我曾经使用 4 个空格，但实际使用起来 2 个空格很不错）</li>
<li>不使用分号（一开始可能会觉得奇怪，但几天后就再也回不去了）</li>
<li>在关键字（如 if）和花括号使用空格，在括号不使用空格</li>
<li><a href="https://standardjs.com/rules.html">等等</a>。</li>
</ul>


<p>StandardJS 是一个独立的 Node 模块，可以进行 lint 和修复代码，但如果要在现有的大型项目中使用，并且想要停用一些规则（因为有些地方可能需要作大量修改），还可以使用 <a href="https://github.com/feross/eslint-config-standard">ESLint 预定配置</a>。比如，我就停用了规则 <a href="http://eslint.org/docs/rules/no-mixed-operators">no-mixed-operators</a> 和 <a href="https://github.com/benmosher/eslint-plugin-import/blob/master/docs/rules/no-webpack-loader-syntax.md">import / no-webpack-loader-syntax</a>。</p>

<h2>使用 ES2015+ 的新特性</h2>

<p>如果你在使用 JavaScript 开发，根本没办法不听说 ES2015 +（或 ES6，ES7 &hellip;）的特性。有的已经是我离不开的：</p>

<ul>
<li>箭头函数：对于函数式编程，比如写 <code>x =&gt; x * 2</code> 这样的函数非常有用（见下一点）</li>
<li>类：停止使用原型函数，使用类更酷炫（但不要滥用，JavaScript 比任何面向对象的语言好多了）</li>
<li>对数组和对象的操作：</li>
</ul>


<pre><code class="javascript">function doSomething() {
  const a = doSomethingElse()
  const b = doSomethingWithA(a)
  const otherResults = { c: '😺', d: '🐶' }
  return { a, b, ...otherResults } // equivalent to { a: a, b: b }
}
const { a, c, ...rest } = doSomething() // Also works with arrays!
// `rest` looks like { b: ..., d: '🐶' }
</code></pre>

<ul>
<li>使用 <code>async/await</code> 编写更简单的异步处理：</li>
</ul>


<pre><code class="javascript">// Please try to write the same code with classic promises ;)
async function doSomething() {
  const a = await getValueForA()
  const b = await getValueForBFromA(a)
  const [c, d] = await Promise.all([
    // parallel execution
    getValueForC(), getValueForDFromB(b)
  ])
  const total = await calculateTotal(a, b, c, d)
  return total / 1000
}
</code></pre>

<p>想知道如何使用这些特性呢？<a href="https://blog.castiel.me/posts/002-use-the-coolest-es6-features-everywhere.html">我的另一篇文章能给一些建议</a>。（顺便说一下，使用最新版本的 Node.js，可能不再需要 Babel 就能使用这些新特性）</p>

<h2>使用函数式编程</h2>

<p>函数式编程最近很热门，取得不少成就，而且不仅仅是在 JavaScript 中。为什么呢？函数式编程能使代码更具可预测性，确定性，更安全，一旦习惯这种方式，代码会更容易维护。这里有一些简单的建议：</p>

<p>首先，停止使用 for 循环，在大多数（可能是所有？）情况下根本不需要。例如：</p>

<pre><code class="javascript">const arr = [{ name: 'first', value: 13 }, { name: 'second', value: 7 }]

// Instead of:
const res = {}
for (let i = 0; i &lt; arr.length; i++) {
  const calculatedValue = arr[i].value * 10
  if (calculatedValue &gt; 100) {
    res[arr[i].name] = calculatedValue
  }
}

// Prefer:
const res = arr
  .map(elem =&gt; ({ name: elem.name, calculatedValue: elem.value * 10 }))
  .filter(elem =&gt; elem.calculatedValue &gt; 100)
  .reduce((acc, elem) =&gt; ({
    [elem.name]: elem.calculatedValue,
    ...acc
  }), {})
</code></pre>

<p>好吧，这实际上是一个非常极端的例子，对于不习惯函数式编程的人而言，可能看起来更加复杂。但我们可以稍微简化一下：</p>

<pre><code class="javascript">const enrichElementWithCalculatedValue =
  elem =&gt; ({ name: elem.name, calculatedValue: elem.value * 10 })
const filterElementsByValue = value =&gt;
  elem =&gt; elem.calculatedValue &gt; value
const aggregateElementInObject = (acc, elem) =&gt; ({
  ...acc
})
const res = arr
  .map(enrichElementWithCalculatedValue)
  .filter(filterElementsByValue(100))
  .reduce(aggregateElementInObject, {})
</code></pre>

<p>在这里，我们定义了三个函数，其功能基本上与其名字一致。第二个建议：创建局部函数（即使是在已经存在的函数中）来说明代码的功能，不需要使用注释。</p>

<p>注意，三个局部函数不修改它们的执行上下文。没有外部变量被修改，没有其他服务被调用&hellip;在函数式编程中，它们被称为<em>纯函数</em>。纯函数具有很大的优势：</p>

<ul>
<li>很容易测试，因为从给定参数只有一个可能的结果，不管被调用了多少次;</li>
<li>无论应用状态如何，都能保证相同的结果;</li>
<li>应用状态在函数调用之前和之后保持不变。</li>
</ul>


<p>所以我的第三个建议是：尽可能地使用纯函数。</p>

<h2>其他的一些建议</h2>

<ul>
<li>习惯于使用异步代码，并多使用 promise，看看 <a href="http://reactivex.io/rxjs/">RxJS</a> 的 observales（有<a href="http://reactivex.io/learnrx/">一个很棒的教程关于从函数式编程到响应式编程</a>）</li>
<li>写测试！这应该是很明显的，但是据我所知很多项目都有未经测试的代码，尽管测试 JavaScript（前端或后端）并不困难。</li>
<li>使用最新的语言特性：比如不要再写 <code>arr.indexOf(elem) !== -1</code>，而应该写成 <code>arr.includes(elem)</code>。</li>
<li>大量阅读技术文章：<a href="https://www.reddit.com/r/javascript/">JavaScript subreddit</a> 是了解目前社区最酷做法的一个很好的来源。</li>
</ul>


<p>总而言之，最好的建议就是：<strong>总是重构你的代码</strong>。比如改进你一年前写过的模块？借此机会，用 <code>const</code> 取代 <code>var</code>，使用箭头函数或 <code>async/await</code> 简化代码&hellip;&hellip;和你喜欢的代码工作一件很愉悦的事。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript 模块化现状]]></title>
    <link href="http://blog.mirreal.net/blog/2017/05/29/the-state-of-javascript/"/>
    <updated>2017-05-29T18:00:00+08:00</updated>
    <id>http://blog.mirreal.net/blog/2017/05/29/the-state-of-javascript</id>
    <content type="html"><![CDATA[<blockquote><p>原文作者：Johannes Ewald <a href="https://twitter.com/Jhnnns">@Jhnnns</a></p>

<p>原文链接：<a href="https://medium.com/webpack/the-state-of-javascript-modules-4636d1774358">The state of JavaScript modules</a></p>

<p>已获原作者授权翻译及发布</p></blockquote>

<p>ESM, CJS, UMD, AMD — 到底应该选择哪一个？</p>

<p>最近 <a href="https://twitter.com/addyosmani/status/859296190323597313">在 twitter</a> 上有很多关于 <a href="http://2ality.com/2014/09/es6-modules-final.html">ES Module</a> 现状的讨论，<a href="https://twitter.com/bradleymeck/status/863061949021650944">尤其是在 Node.js 上</a>，他们计划引入新的文件扩展名 <code>*.mjs</code>。人们有足够理由对此感到 <a href="https://twitter.com/tankredhase/status/861864123922907136">担忧和不确定</a>，因为这个话题异常复杂，接下来会尽力阐述清楚问题。</p>

<h2>来自远古的恐惧</h2>

<p>大多数前端开发者应该还记得 <a href="https://medium.com/@trek/last-week-i-had-a-small-meltdown-on-twitter-about-npms-future-plans-around-front-end-packaging-b424dd8d367a">Javascript 依赖管理的黑暗时期</a>。那个时候，你需要把一个库复制粘贴到 vendor 文件夹，然后作为一个全局变量引入，要自己去按次序组合所有东西，可能还要管理命名空间。</p>

<p>在过去的那些年，我们能深刻体会到公共模块格式化和中央模块管理的价值。</p>

<p>在今天，不管是发布还是使用一个库都要容易得多，只需要使用 <code>npm publish</code> 和 <code>npm install</code> 命令就行。这就是人们会那么紧张两种模块系统兼容性问题的原因：他们不想失去已有的舒适区。</p>

<p>接下来我会解释和总结现有实现的情况，以及为什么 Node 生态迁移到 ES Module（ESM）会那么难。在最后，总结这些变化对 webpack 使用者和模块作者有什么影响。</p>

<h2>现有实现</h2>

<p>目前，ESM 有三种方式的实现：</p>

<ul>
<li>浏览器</li>
<li>webpack 以及类似的构建工具</li>
<li>Node（未完成，<a href="https://twitter.com/rauschma/status/866334160218095617">但可能在年底作为一个实验功能</a>）</li>
</ul>


<p>为了更好地理解现在的讨论，首先要知道 ES2015 包含两种模式：</p>

<ul>
<li><code>script</code> 用于具有全局命名空间的常规脚本</li>
<li><code>module</code> 用于具有明确导入和导出的模块化代码</li>
</ul>


<p>如果你试图在 <code>script</code> 标签使用 <code>import</code> 或者 <code>export</code> 语句，会抛出一个 SyntaxError。这种语句在全局环境下没有任何意义。另一方面，<code>module</code> 模式即意味着<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Strict_mode">严格模式</a>，禁止使用某些语言特性，比如 <code>with</code> 语句。因此，需要在脚本被解析和执行之前定义模式。</p>

<h2>浏览器中的 ESM</h2>

<p>截至到 2017 年 5 月，所有主流浏览器都开始做了 ESM 的实现工作。不过，大部分仍处于在实验性质。这里不会做详细介绍，因为 <a href="https://jakearchibald.com/2017/es-modules-in-browsers/">Jake Archibald 已经写了一篇很厉害的文章</a>。</p>

<p>除了一些小的困难，在浏览器中实现起来非常容易，因为以前并没有模块系统。想要指定 <code>module</code> 模式，需要在 <code>script</code> 标签添加 <code>type="module"</code> 属性，如下所示：</p>

<p>&#8220;`html</p>

<script type="module" src="main.js"></script>


<pre><code>
在一个模块中，现在只能使用有效的 `URL` 作为模块标识符。模块标识符是用于 require 或 import 其他模块的字符串。为了确保未来兼容 CJS 模块标识符，“纯” 导入标识符（如 `import "lodash"`）现在还不支持。模块标识符必须是绝对 `URL` 或者是以 `/`，  `./`,  `../` 开头：
</code></pre>

<p>// Supported:
import {foo} from &lsquo;<a href="https://jakearchibald.com/utils/bar.js">https://jakearchibald.com/utils/bar.js</a>&rsquo;;
import {foo} from &lsquo;/utils/bar.js&rsquo;;
import {foo} from &lsquo;./bar.js&rsquo;;
import {foo} from &lsquo;../bar.js&rsquo;;</p>

<p>// Not supported:
import {foo} from &lsquo;bar.js&rsquo;;
import {foo} from &lsquo;utils/bar.js&rsquo;;
// Example from <a href="https://jakearchibald.com/2017/es-modules-in-browsers/">https://jakearchibald.com/2017/es-modules-in-browsers/</a>
&#8220;`</p>

<p>同样需要注意的是，一旦处在一个模块中，每个导入也将被解析为 <code>module</code>，而且没有办法 <code>import</code> 一个 <code>script</code>。</p>

<h2>ESM 与 webpack</h2>

<p>类似 webpack 这样的构建工具通常会尝试用 <code>module</code> 模式解析代码，有问题再切回到 <code>script</code> 模式。这些工具最终会生成一段 <code>script</code>，通常是在一定程度上模拟 CJS 和 ESM 行为的模块运行时。</p>

<p>我们以这两个简单的 ESM 为例：</p>

<pre><code class="javascript">// a.js
export let number = 42;
export function incr() {
    number++;
}
</code></pre>

<pre><code class="javascript">// test.js
import { number } from "./a";

console.log(number);
</code></pre>

<p>webpack 使用函数包装器封装模块范围和对象引用来模拟 <a href="http://2ality.com/2015/07/es6-module-exports.html">ESM 实时绑定</a>。每次编译，还包括一个模块运行时，负责引导和缓存模块。此外，将模块标识转换为数字模块 ID。这样可以减少打包的大小和引导时间。</p>

<p>这是什么意思呢？我们来看看编译输出：</p>

<pre><code class="javascript">(function(modules) {
    // This is the module runtime.
    // It's only included once per compilation.
    // Other chunks share the same runtime.
    var installedModules = {};
    // The require function
    function __webpack_require__(moduleId) {
        ...
    }
    ...
    // Load entry module and return exports
    return __webpack_require__(__webpack_require__.s = 1);
})
([ // An array that maps module ids to functions
    // a.js as module id 0
    function (module, __webpack_exports__, __webpack_require__) {
        "use strict";
        Object.defineProperty(__webpack_exports__, "a", {
            configurable: false,
            enumerable: true,
            get: () =&gt; number
        });

        let number = 42;

        function incr() {
            number++;
        }
    },
    // test.js as module id 1
    function (module, __webpack_exports__, __webpack_require__) {
        "use strict";
        var __WEBPACK_IMPORTED_MODULE_0__a__ = __webpack_require__(0);

        // Object reference as "live binding"
        console.log(__WEBPACK_IMPORTED_MODULE_0__a__["a" /* number */]);
    }
]);
</code></pre>

<p>简化的 webpack 输出，模拟 ES Modules 行为</p>

<p>结果已经简化并删除了一些与此示例无关的代码。你会发现，webpack 在 <code>exports</code> 对象上将所有 <code>export</code> 语句替换成 <code>Object.defineProperty</code>，并使用属性访问器替换对引入值的所有引用。还要注意每个 ESM 开始时的 <code>"use strict"</code> 指令，这是由 webpack 自动添加，在 ESM 中必须是严格模式。</p>

<p>这种实现只是模拟，因为它试图模仿 ESM 和 CJS 的行为 &ndash; 但不是与其完全保持一致。比如，这种模拟并不符合某些边缘情况。看下面这个模块：</p>

<pre><code class="javascript">console.log(this);
</code></pre>

<p>如果你通过加上 <code>babel-preset-es2015</code> 的 Babel 来运行，结果是：</p>

<pre><code class="javascript">"use strict";
console.log(undefined);
</code></pre>

<p>从输出结果可以看出，Babel 假设默认是 ESM，因为 <code>module</code> 模式即代表严格模式，在严格模式下会将 <code>this</code> 初始化为 <code>undefined</code>。</p>

<p>然而，使用 webpack，结果是：</p>

<pre><code class="javascript">(function(module, exports) {

console.log(this);

})
</code></pre>

<p>在引导模块时，<code>this</code> 将指向 <code>exports</code> ，与 Node.js 使用的 CJS 行为一致。这是因为语法上不确定是 <code>script</code> 还是 <code>module</code>，解析器无法判断该模块是 ESM 还是 CJS。在不明确的时候，webpack 会模拟 CJS，因为它仍然是最受欢迎的模块风格。</p>

<p>这种模拟其实已经包含了很多情况，因为模块作者通常会避免这种代码。然而，“很多情况”对于像 Node.js 这样的平台是不够的，因为它需要保证所有有效的 JavaScript 代码都能正常运行。</p>

<h2>Node.js 中的 ESM</h2>

<p>Node.js 在执行 ESM 时遇到了麻烦，因为仍然需要支持 CJS，语法看起来相似，但运行时行为完全不同。<a href="https://github.com/nodejs/CTC">Node.js 核心技术委员会</a>（CTC）成员 James M Snell 撰写了<a href="https://hackernoon.com/node-js-tc-39-and-modules-a1118aecf95e">一篇很好的文章来解释 CJS 与 ESM 之间的差异</a>。</p>

<p>归结起来，CJS 是一个动态模块系统，ESM 是静态模块系统。</p>

<h3>CJS</h3>

<ul>
<li>允许动态同步 <code>require()</code></li>
<li>导出仅在模块执行后才知道</li>
<li>导出可以在模块初始化后添加，替换和删除</li>
</ul>


<h3>ESM</h3>

<ul>
<li>只允许静态同步 <code>import</code></li>
<li>在模块执行之前，导入和导出已经关联</li>
<li>导入和导出是不可变的</li>
</ul>


<p>由于  CJS 早于 ES2015，所以一直在 <code>script</code> 模式下解析，封装通过使用函数包装器实现。在 Node.js 中加载 CJS，实际上会执行与此类似的代码：</p>

<pre><code class="javascript">const module = {
    exports: {}
};
const require = makeRequireFunction();
const filename = "...";
const dirname = "...";
(function (exports, require, module, __filename, __dirname) {
/* YOUR CODE */
})(module.exports, require, module, filename, dirname);
</code></pre>

<p>对 Node.js 的 CommonJS 模块的简单函数包装</p>

<p>问题出现了，将两个模块系统集成到同一个运行时时，ESM 和 CJS 之间的循环依赖可能会迅速导致类似死锁的情况。</p>

<p>而且，由于现有 CJS 模块数量庞大，也不能直接放弃对 CJS 的支持。为了避免 Node.js 生态的中断，有两点已经很明显：</p>

<ul>
<li>现有的 CJS 代码必须以相同的方式继续工作</li>
<li>两个模块系统都必须同时且尽可能无缝地工作</li>
</ul>


<h3>目前的权衡</h3>

<p>2017 年 3 月，经过几个月的讨论，CTC 终于找到了一种解决问题的办法。由于在 ES 规范和引擎不改变的情况下无法进行无缝集成，<a href="https://github.com/bmeck/node-eps/blob/a1eab9bf023bbe13a79ddb18f0622a5d57215f9b/002-es-modules.md">CTC 决定开始一些权衡之后的实现工作</a>：</p>

<h4>1.ESM 必须是 <code>*.mjs</code> 文件扩展名</h4>

<p>这是由于上面提及的模糊语法问题，无法通过解析来确切知晓 JavaScript 代码是什么类型。为了 Node.js 向后兼容的目标，作者需要加入一种新模式。<a href="https://github.com/nodejs/node/wiki/ES6-Module-Detection-in-Node#detection-problem">已经有关于各种替代品的讨论</a>，但使用不同文件扩展名是解决目前问题的最佳权衡。</p>

<h4>2.CJS 只能异步导入 ESM import()</h4>

<p>Node.js 将异步加载 ESM，以便尽可能接近浏览器的行为。因此，同步的 <code>require()</code> 在 ESM 是不可能的，并且依赖于 ESM 的每个功能都需要异步：</p>

<pre><code class="javascript">const driverPromise = import("dbdriver");

exports.readFromDb = async (query) =&gt; {
   return (await driverPromise).read(query);
};
</code></pre>

<h4>3. CJS 向 ESM 暴露一个不可变的默认导出</h4>

<p>使用 Babel 或 Webpack，我们通常将 CJS 重构为 ESM，如下所示：</p>

<pre><code class="javascript">// CJS
const { a, b } = require("c");
// ESM
import { a, b } from "c";
</code></pre>

<p>再一次地，他们的语法看起来很相似，但忽略了 CJS 中没有命名导出的事实。只有一个叫做 <code>default</code> 的导出，等同于在 CJS 模块完成计算后一个不可变的 <code>module.exports</code> 。从技术上讲，有可能将 <code>module.exports</code> 解构成命名导入，但这需要对标准作更大的变更。<a href="https://github.com/bmeck/node-eps/blob/a1eab9bf023bbe13a79ddb18f0622a5d57215f9b/002-es-modules.md#461-default-imports">这就是现在 CTC 决定采取这种方式的原因</a>。</p>

<h4>4.模块范围的变量类似 <code>module</code>，<code>require</code> 以及 <code>__filename</code> 在 ESM 不存在</h4>

<p>Node.js 和浏览器会实现一些 ESM 的特性，<a href="https://github.com/whatwg/html/issues/1013">但标准化过程仍在进行中</a>。</p>

<p>鉴于将 CJS 和 ESM 集成到一个运行时的工程挑战，CTC 在评估边缘情况和权衡方面做了非常好的工作。比如使用不同的文件扩展名是就是一个很简单的解决方案。</p>

<p>实际上，一个文件扩展名可以认为是一个二进制文件如何解释的提示。如果一个 <code>module</code> 不是 <code>script</code>，我们应该使用不同的文件扩展名。其他工具（如 linter 或 IDE ）也可以获取相同信息。</p>

<p>当然，引入新的文件扩展名有成本，但是一旦服务器和其他应用程序确认 <code>*.mjs</code> 为JavaScript，我们很快就会忘记这个争议。</p>

<h2>将 * .mjs 作为 Node.js 的 Python 3？</h2>

<p>考虑到所有这些限制，人们可能会问，这种过渡将对现在的生态造成什么样的损害。虽然 CTC 会努力解决问题，但社区如何采用这一点仍然存在很大不确定性。这种不确定性 <a href="https://twitter.com/sindresorhus/status/861987349529452545">被众多知名的 NPM 模块作者</a> 再次强调，他们声称将不会在模块中使用 <code>*.mjs</code>。</p>

<p><a href="http://blog.thezerobit.com/2014/05/25/python-3-is-killing-python.html">Python 3 is killing Python</a></p>

<p>很难预测社区如何反应，但是应该不会对现在的生态造成大破坏，甚至能看到从 CJS 平稳过渡到 ESM。主要有两个原因：</p>

<h3>1.与 CJS 严格向后兼容</h3>

<p>那些不喜欢 ESM 的模块作者可以继续使用 CJS，保证自己不被排挤出局。这样他们自己的代码不会受到采用 ESM 的影响，降低迁移到另一个运行时的可能性，让 NPM 迁移到新生态变得容易。从 CJS 到 ESM 的重构给包维护者带来额外工作，不能指望所有人都有时间。</p>

<h3>2. CJS 在 ESM 中的无缝整合</h3>

<p>从 ESM 导入 CJS 模块非常简单。需要注意的是，CJS 仅导出一个默认值。一旦处于 ESM，甚至可能根本不会注意到依赖关系使用的模块风格，尤其是与在 CJS 中使用 <code>await import()</code>相比。</p>

<p>由于 ESM 的这个优点以及其他有点，比如开箱即用的 <a href="https://webpack.js.org/guides/tree-shaking/">tree shaking</a> 和浏览器兼容性，预计在未来几年内，我们可以看到向 ESM 的缓慢而稳定的过渡。CJS 的特性，如动态 <code>require()</code> 和猴子补丁导出，在 Node.js 社区一直是有争议的，不比 ESM 带来的好处。</p>

<h2>这些对我来说意味着什么？</h2>

<p>因为最近这些事情，很容易对目前存在的所有选择和限制感到困惑。在接下来，整理了开发人员面临的典型问题以及我们的回答：</p>

<h3>现在需要重构现有的代码吗？</h3>

<p><strong>不需要</strong>。Node.js 才刚刚开始实现 ESM，仍然有大量的工作要做。<a href="https://medium.com/the-node-js-collection/an-update-on-es6-modules-in-node-js-42c958b890c">James M Snell 预计至少还需要一年时间</a>，还有很多变化的余地，所以现在重构是不安全的。</p>

<h3>应该在新代码中使用 ESM 吗？</h3>

<ul>
<li><strong>如果你已经有或者打算使用像 webpack 这样的构建工具，答案是肯定的</strong>。这将更容易完成代码库的过渡，并使 tree shaking 成为可能。但要小心：一旦 Node.js 支持原生 ESM，可能需要重构其中的一些部分。</li>
<li><strong>如果你正在编写一个库，答案是也肯定的</strong>，你的模块使用者将受益于 tree shaking。</li>
<li><strong>如果你不想进行构建操作，或者正在编写一个 Node.js 应用程序，还是用 CJS 吧</strong>。</li>
</ul>


<h3>现在应该使用 .mjs 吗？</h3>

<p><strong>不要这样做</strong>，目前没有什么好处，工具支持依然薄弱。建议一旦原生 ESM 支持登陆 Node.js，尽快开始迁移。记住，<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types">浏览器只关心 MIME 类型，而不是文件扩展名</a>。</p>

<h3>应该关心浏览器兼容性吗？</h3>

<p>是的，需要在一定程度上关注这个问题。 不应该在导入语句中省略 <code>.js</code> 扩展名，因为浏览器需要完整的 URL，无法像 Node.js 这样执行路径查询。同样，应该避免 <code>index.js</code> 文件。不过，人们并不会很快在浏览器中使用 NPM 软件包，因为仍然不能 bare 导入。</p>

<h3>作为库作者该怎么办？</h3>

<p>用 ESM 编写代码，并使用 <a href="https://rollupjs.org/">Rollup</a> 或 Webpack 转换成单个 CJS 模块，然后在 <code>package.json</code> 将 <code>main</code> 字段指向此 CJS 包，并将 <a href="https://github.com/rollup/rollup/wiki/pkg.module"><code>module</code></a> 字段指向原始 ESM。如果还使用 ESM 之外的其他新语言功能，则应编译成 ES5，并提供 CJS 和 ESM 的打包。这样，你的库用户仍然可以从 tree shaking 获利而无需对代码进行转换。</p>

<p>看一下这些完成 tree shaking 的模块</p>

<h2>总结</h2>

<p>关于 ES 模块有很多不确定性。由于目前 Node.js 在实现上的权衡，开发人员担心可能会破坏 Node.js 的生态。</p>

<p>这些还不会发生，有两个原因：<strong>CJS 的严格的后向兼容和 CJS 在 ESM 中的无缝集成</strong>。</p>

<p>在 Node.js 发布原生 ESM 支持之前，应该仍然使用 Rollup 和 Webpack 等工具。它们在一定程度上模拟了 ESM 环境，但要注意它们不完全符合规范。此外，使用打包仍然是个<a href="https://peerigon.github.io/talks/2016-08-26-jsconf-is-future-frontend-tooling/#36">很好的选择</a>，一旦可以在浏览器中使用 NPM 软件包。</p>

<p>我们 webpack 团队正在努力做一些工作，帮助开发者平稳过渡。为了这个目标，我们计划在 Node.js 的 ESM 支持成熟后，模拟 Node.js 导入 CJS 的方式。</p>
]]></content>
  </entry>
  
</feed>
