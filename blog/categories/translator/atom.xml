<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Translator | Mirreal Note]]></title>
  <link href="http://blog.mirreal.net/blog/categories/translator/atom.xml" rel="self"/>
  <link href="http://blog.mirreal.net/"/>
  <updated>2017-11-03T11:23:21+08:00</updated>
  <id>http://blog.mirreal.net/</id>
  <author>
    <name><![CDATA[Patrick Ran]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[编写扁平化的代码]]></title>
    <link href="http://blog.mirreal.net/blog/2017/11/02/writing-flat-and-declarative-code/"/>
    <updated>2017-11-02T11:20:03+08:00</updated>
    <id>http://blog.mirreal.net/blog/2017/11/02/writing-flat-and-declarative-code</id>
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="https://peeke.nl/writing-flat-code">Writing flat &amp; declarative code</a></p>

<p>作者：<a href="https://twitter.com/peeke__">Peeke Kuepers</a></p></blockquote>

<h1>编写扁平化的代码</h1>

<p>&ndash; <em>给你的代码增加一点点函数式编程的特性</em></p>

<p><strong>最近我对函数式编程非常感兴趣。这个概念让我着迷：应用数学来增强抽象性和强制纯粹性，以避免副作用，并实现代码的良好可复用性。同时，函数式编程非常复杂。</strong></p>

<p>函数式编程有一个非常陡峭的学习曲线，因为它来源于数学中的<a href="https://github.com/MostlyAdequate/mostly-adequate-guide/blob/master/ch5.md#category-theory">范畴论</a>。接触不久之后，就将遇到诸如组合（composition）、恒等（identity），函子（functor）、单子（monad），以及逆变（contravariant）等术语。我根本不太了解这些概念，可能这也是我从来没有在实践中运用函数式编程的原因。</p>

<p>我开始思考：在常规的命令式编程和完全的函数式编程之间是否可能会有一些中间形式？既允许在代码库引入函数式编程的一些很好的特性，同时暂时保留已有的旧代码。</p>

<p>对我而言，函数式编程最大的作用就是强制你编写声明性代码：代码描述你做什么，而不是在描述如何做。这样就可以轻松了解特定代码块的功能，而无需了解其真正的运行原理。事实证明，编写声明式代码是函数式编程中最简单的部分之一。</p>

<h2>循环</h2>

<blockquote><p>&hellip;一个循环就是一个命令式控制结构，难以重用，并且难以插入到其他操作中。此外，它还得不断变化代码来响应新的迭代需求。</p>

<p>&ndash; Luis Atencio</p></blockquote>

<p>所以，让我们先看一下循环，循环是命令式编程的一个很好的例子。循环涉及很多语法，都是描述它们的行为是如何工作，而不是它们在做什么。例如，看看这段代码：</p>

<pre><code class="javascript">function helloworld(arr) {
    for (let i = 1; i &lt; arr.length; i++) {
        arr[i] *= 2
        if (arr[i] % 2 === 0) {
            doSomething(arr[i])
        }
    }
}
</code></pre>

<p>这段代码在做什么呢？它将数组内除第一个数字 （<code>let i = 1</code>）的其他所有数字乘以 2，如果是偶数的话（<code>if (arr % 2 === 0)</code>），就进行某些操作。在此过程中，原始数组的值会被改变。但这通常是不必要的，因为数组可能还会在代码库中的其他地方用到，所以刚才所做的改变可能会导致意外的结果。</p>

<p>但最主要的原因是，这段代码看起来很难一目了然。它是命令式的，for 循环告诉我们如何遍历数组，在里面，使用一个 if 语句有条件地调用一个函数。</p>

<p>我们可以通过使用数组方法以声明式的方式重写这段代码。数组方法直接表达所做的事，比较常见的方法包括：<code>forEach</code>，<code>map</code>，<code>filter</code>，<code>reduce</code> 和 <code>slice</code>。</p>

<p>结果就像下面这样：</p>

<pre><code class="javascript">function helloworld(arr) {
    const evenNumbers = n =&gt; n % 2 === 0

    arr
        .slice(1)
        .map(v =&gt; v * 2)
        .filter(evenNumbers)
        .forEach(v =&gt; doSomething(v))    
}
</code></pre>

<p>在这个例子中，我们使用一种很好的，扁平的链式结构去描述我们在做什么，明确表明意图。此外，我们避免了改变原始数组，从而避免不必要的副作用，因为大多数数组方法会返回一个新数组。当箭头函数开始变得越来越复杂时，可以地将其提取到一个特定的函数中，比如 <code>evenNumbers</code>， 从而尽量保持结构简单易读。</p>

<p>在上面的例子，链式调用并没有返回值，而是以 forEach 结束。然而，我们可以轻松地剥离最后一部分，并返回结果，以便我们可以在其他地方处理它。如果还需要返回除数组以外的任何东西，可以使用 <code>reduce</code> 函数。</p>

<p>对于接下来的一个例子，假设我们有一组 JSON 数据，其中包含在一个虚构歌唱比赛中不同国家获得的积分：</p>

<pre><code class="json">[
    {
        "country": "NL",
        "points": 12
    },
    {
        "country": "BE",
        "points": 3
    },
    {
        "country": "NL",
        "points": 0
    },
    ...
]
</code></pre>

<p>我们想计算荷兰（NL）获得的总积分，根据印象中其强大的音乐能力，我们可以认为这是一个非常高的分数，但我们想要更精确地确认这一点。</p>

<p>使用循环可能会是这样：</p>

<pre><code class="javascript">function countVotes(votes) {
    let score = 0;

    for (let i = 0; i &lt; votes.length; i++) {
        if (votes[i].country === 'NL') {
            score += votes[i].points;
        }
    }

    return score;
}
</code></pre>

<p>使用数组方法重构，我们得到一个更干净的代码片段：</p>

<pre><code class="javascript">function countVotes(votes) {
    const sum = (a, b) =&gt; a + b;

    return votes
        .filter(vote =&gt; vote.country === 'NL')
        .map(vote =&gt; vote.points)
        .reduce(sum);
}
</code></pre>

<p>有时候 <code>reduce</code> 可能有点难以阅读，将 <code>reduce</code> 函数提取出来会在理解上有帮助。在上面的代码片段中，我们定义了一个 <code>sum</code> 函数来描述函数的作用，因此方法链仍然保持很好的可读性。</p>

<h2>if else 语句</h2>

<p>接下来，我们来聊聊大家都很喜欢的 if else 语句，if else 语句也是命令式代码里一个很好的例子。为了使我们的代码更具声明式，我们将使用三元表达式。</p>

<p>一个三元表达式是 if else 语句的替代语法。以下两个代码块具有相同的效果：</p>

<pre><code class="javascript">// Block 1
if (condition) {
    doThis();
} else {
    doThat();
}

// Block 2
const value = condition ? doThis() : doThat();
</code></pre>

<p>当在定义（或返回）一个常量时，三元表达式非常有用。使用 if else 语句会将该变量的使用范围限制在语句内，通过使用三元语句，我们可以避免这个问题：</p>

<pre><code class="javascript">if (condition) {
    const a = 'foo';
} else {
    const a = 'bar';
}

const b = condition ? 'foo' : 'bar';

console.log(a); // Uncaught ReferenceError: a is not defined
console.log(b); // 'bar'
</code></pre>

<p>现在，我们来看看如何应用这一点来重构一些更重要的代码：</p>

<pre><code class="javascript">const box = element.getBoundingClientRect();

if (box.top - document.body.scrollTop &gt; 0 &amp;&amp; box.bottom - document.body.scrollTop &lt; window.innerHeight) {
    reveal();
} else {
    hide();
}
</code></pre>

<p>那么，上面的代码发生了什么呢？if 语句检查元素当前是否在页面的可见部分内，这个信息在代码的任何地方都没有表达出来。基于此布尔值，再调用 <code>reveal()</code> 或者 <code>hide()</code> 函数。</p>

<p>将这个 if 语句转换成三元表达式迫使我们将条件移动到它自己的变量中。这样我们可以将三元表达式组合在一行上，现在通过变量的名称来传达布尔值表示的内容，这样还不错。</p>

<pre><code class="javascript">const box = element.getBoundingClientRect();
const isInViewport =
    box.top - document.body.scrollTop &gt; 0 &amp;&amp;
    box.bottom - document.body.scrollTop &lt; window.innerHeight;

isInViewport ? reveal() : hide();
</code></pre>

<p>通过这个例子，重构带来的好处可能看起来不大。接下来会有一个相比更复杂的例子：</p>

<pre><code class="javascript">elements
    .forEach(element =&gt; {
        const box = element.getBoundingClientRect();

        if (box.top - document.body.scrollTop &gt; 0 &amp;&amp; box.bottom - document.body.scrollTop &lt; window.innerHeight) {
            reveal();
        } else {
            hide();
        }

    });
</code></pre>

<p>这很不好，打破了我们优雅的扁平的调用链，从而使代码更难读。我们再次使用三元操作符，而在使用它的时候，使用 <code>isInViewport</code> 检查，并跟它自己的动态函数分开。</p>

<pre><code class="javascript">const isInViewport = element =&gt; {
    const box = element.getBoundingClientRect();
    const topInViewport = box.top - document.body.scrollTop &gt; 0;
    const bottomInViewport = box.bottom - document.body.scrollTop &lt; window.innerHeight;
    return topInViewport &amp;&amp; bottomInViewport;
};

elements
    .forEach(elem =&gt; isInViewport(elem) ? reveal() : hide());
</code></pre>

<p>此外，现在我们将 <code>isInViewport</code> 移动到一个独立函数，可以很容易地把它放在它自己的 helper 类/对象之内：</p>

<pre><code class="javascript">import { isInViewport } from 'helpers';

elements
    .forEach(elem =&gt; isInViewport(elem) ? reveal() : hide());
</code></pre>

<p>虽然上面的例子依赖于所处理的是数组，但是在不明确是在数组的情况下，也可以采用这种编码风格。</p>

<p>例如，看看下面的函数，它通过三条规则来验证密码的有效性。</p>

<pre><code class="javascript">import { passwordRegex as requiredChars } from 'regexes'
import { getJson } from 'helpers'

const validatePassword = async value =&gt; {
  if (value.length &lt; 6) return false
  if (!requiredChars.test(value)) return false

  const forbidden = await getJson('/forbidden-passwords')
  if (forbidden.includes(value)) return false

  return value
}

validatePassword(someValue).then(persist)
</code></pre>

<p>如果我们使用数组包装初始值，就可以使用在上面的例子中里面所用到的所有数组方法。此外，我们已经将验证函数打包成 <code>validationRules</code> 使其可重用。</p>

<pre><code class="javascript">import { minLength, matchesRegex, notBlacklisted } from 'validationRules'
import { passwordRegex as requiredChars } from 'regexes'
import { getJson } from 'helpers'

const validatePassword = async value =&gt; {
  const result = Array.from(value)
    .filter(minLength(6))
    .filter(matchesRegex(requiredChars))
    .filter(await notBlacklisted('/forbidden-passwords'))
    .shift()

  if (result) return result
  throw new Error('something went wrong...')
}

validatePassword(someValue).then(persist)
</code></pre>

<p>目前在 JavaScript 中有一个 <a href="https://github.com/tc39/proposal-pipeline-operator">管道操作符</a> 的提案。使用这个操作符，就不用再把原始值换成数组了。可以直接在前面的值调用管道操作符之后的函数，有点像 <code>Array</code> 的 <code>map</code> 功能。修改之后的代码大概就像这样：</p>

<pre><code class="javascript">import { minLength, matchesRegex, notBlacklisted } from 'validationRules'
import { passwordRegex as requiredChars } from 'regexes'
import { getJson } from 'helpers'

const validatePassword = async value =&gt;
  value
    |&gt; minLength(6)
    |&gt; matchesRegex(requiredChars)
    |&gt; await notBlacklisted('/forbidden-passwords')

try { someValue |&gt; await validatePassword |&gt; persist }
catch(e) {
  // handle specific error, thrown in validation rule
}
</code></pre>

<p>但需要注意的是，这仍然是一个非常早期的提案，不过可以稍微期待一下。</p>

<h2>事件</h2>

<p>最后，我们来看看事件处理。一直以来，事件处理很难以扁平化的方式编写代码。可以 <code>Promise</code> 化来保持一种链式的，扁平化的编程风格，但 <code>Promise</code> 只能 <code>resolve</code> 一次，而事件绝对会多次触发。</p>

<p>在下面的示例中，我们创建一个类，它对用户的每个输入值进行检索，结果是一个自动补全的数组。首先检查字符串是否长于给定的阈值长度。如果满足条件，将从服务器检索自动补全的结果，并将其渲染成一系列标签。</p>

<p>注意代码的不“纯”，频繁地使用 <code>this</code> 关键字。几乎每个函数都在访问 <code>this</code> 这个关键字：</p>

<blockquote><p>译注：作者在这里使用 &ldquo;this keyword&#8221;，有一种双关的意味</p></blockquote>

<pre><code class="javascript">import { apiCall } from 'helpers'

class AutoComplete {

  constructor (options) {

    this._endpoint = options.endpoint
    this._threshold = options.threshold
    this._inputElement = options.inputElement
    this._containerElement = options.list

    this._inputElement.addEventListener('input', () =&gt;
      this._onInput())

  }

  _onInput () {

    const value = this._inputElement.value

    if (value &gt; this._options.threshold) {
      this._updateList(value)
    }

  }

  _updateList (value) {

    apiCall(this._endpoint, { value })
      .then(items =&gt; this._render(items))
      .then(html =&gt; this._containerElement = html)

  }

  _render (items) {

    let html = ''

    items.forEach(item =&gt; {
      html += `&lt;a href="${ item.href }"&gt;${ item.label }&lt;/a&gt;`
    })

    return html

  }

}
</code></pre>

<p>通过使用 <code>Observable</code>，我们将用一种更好的方式对这段代码进行重写。可以简单将 <code>Observable</code> 理解成一个能够多次 <code>resolve</code> 的 <code>Promise</code>。</p>

<blockquote><p>Observable 类型可用于基于推送模型的数据源，如 DOM 事件，定时器和套接字</p></blockquote>

<p><code>Observable</code> 提案目前处于 Stage-1。在下面 <code>listen</code> 函数的实现是从 GitHub 上的<a href="https://github.com/tc39/proposal-observable">提案</a>中直接复制的，主要是将事件监听器转换成 <code>Observable</code>。可以看到，我们可以将整个 <code>AutoComplete</code> 类重写为单个方法的函数链。</p>

<pre><code class="javascript">import { apiCall, listen } from 'helpers';
import { renderItems } from 'templates';

function AutoComplete ({ endpoint, threshold, input, container }) {

  listen(input, 'input')
    .map(e =&gt; e.target.value)
    .filter(value =&gt; value.length &gt;= threshold)
    .forEach(value =&gt; apiCall(endpoint, { value }))
    .then(items =&gt; renderItems(items))
    .then(html =&gt; container.innerHTML = html)

}
</code></pre>

<p>由于大多数 <code>Observable</code> 库的实现过于庞大，我很期待 ES 原生的实现。<code>map</code>，<code>filter</code> 和 <code>forEach</code>方法还不是规范的一部分，但是在 <a href="https://github.com/zenparsing/zen-observable">zen-observable</a> 已经在扩展 API 实现，而 zen-observable 本身是 ES Observables 的一种实现 。</p>

<p>&ndash;</p>

<p>我希望你会对这些“扁平化”模式感兴趣。就个人而言，我很喜欢以这种方式重写我的程序。你接触到的每一段代码都可以更易读。使用这种技术获得的经验越多，就越来越能认识到这一点。记住这个简单的法则：</p>

<p><strong>The flatter the better!</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ES6 Promise：模式与反模式]]></title>
    <link href="http://blog.mirreal.net/blog/2017/09/29/es6-promises-patterns-and-anti-patterns/"/>
    <updated>2017-09-29T16:50:11+08:00</updated>
    <id>http://blog.mirreal.net/blog/2017/09/29/es6-promises-patterns-and-anti-patterns</id>
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="https://medium.com/datafire-io/es6-promises-patterns-and-anti-patterns-bbb21a5d0918">ES6 Promises: Patterns and Anti-Patterns</a>
作者：Bobby Brennan</p></blockquote>

<p>当几年前，第一次使用 NodeJS 的时候，对现在被称为“ <a href="http://callbackhell.com/">回调地狱</a> ”的写法感到很困扰。幸运的是，现在是 2017 年了，NodeJS 已经采用大量 JavaScript 的最新特性，从 <a href="http://node.green/">v4</a> 开始已经支持 Promise。</p>

<p>尽管 Promise 可以让代码更加简洁易读，但对于只熟悉回调函数的人来说，可能对此还是会有所怀疑。在这里，将列出我在使用Promise 时学到的一些基本模式，以及踩的一些坑。</p>

<p><em>注意：<strong>在本文中</strong>将使用<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">箭头函数</a> ，如果你还不是很熟悉，其实很简单，建议<a href="http://exploringjs.com/es6/ch_arrow-functions.html">先读一下使用它们的好处</a></em></p>

<h2>模式与最佳实践</h2>

<h4>使用 Promise</h4>

<p>如果使用的是已经支持 Promise 的第三方库，那么使用起来非常简单。只需关心两个函数：<code>then()</code> 和 <code>catch()</code>。例如，有一个客户端 API 包含三个方法，<code>getItem()</code>，<code>updateItem()</code>，和<code>deleteItem()</code>，每一个方法都返回一个 Promise：</p>

<pre><code class="javascript">Promise.resolve()
  .then(_ =&gt; {
    return api.getItem(1)
  })
  .then(item =&gt; {
    item.amount++
    return api.updateItem(1, item);
  })
  .then(update =&gt; {
    return api.deleteItem(1);
  })
  .catch(e =&gt; {
    console.log('error while working on item 1');
  })
</code></pre>

<p>每次调用 <code>then()</code> 会在 Promise 链中创建一个新的步骤，如果链中的任何一个地方出现错误，就会触发接下来的 <code>catch()</code> 。<code>then()</code> 和 <code>catch()</code> 都可以返回一个值或者一个新的 Promise，结果将被传递到 Promise 链的下一个<code>then()</code>。</p>

<p>为了比较，这里使用回调函数来实现相同逻辑：</p>

<pre><code class="javascript">api.getItem(1, (err, data) =&gt; {
  if (err) throw err;
  item.amount++;
  api.updateItem(1, item, (err, update) =&gt; {
    if (err) throw err;
    api.deleteItem(1, (err) =&gt; {
      if (err) throw err;
    })
  })
})
</code></pre>

<p>要注意的第一个区别是，使用回调函数，我们必须在过程的<strong>每个</strong>步骤中进行错误处理，而不是用单个的 catch-all 来处理。回调函数的第二个问题更直观，每个步骤都要水平缩进，而使用 Promise 的代码则有显而易见的顺序关系。</p>

<h4>回调函数 Promise 化</h4>

<p>需要学习的第一个技巧是如何将回调函数转换为 Promise。你可能正在使用仍然基于回调的库，或是自己的旧代码，不过不用担心，因为只需要几行代码就可以将其包装成一个 Promise。这是将 Node 中的一个回调方法 <code>fs.readFile</code> 转换为 Promise的示例：</p>

<pre><code class="javascript">function readFilePromise(filename) {
  return new Promise((resolve, reject) =&gt; {
    fs.readFile(filename, 'utf8', (err, data) =&gt; {
      if (err) reject(err);
      else resolve(data);
    })
  })
}

readFilePromise('index.html')
  .then(data =&gt; console.log(data))
  .catch(e =&gt; console.log(e))
</code></pre>

<p>关键部分是 Promise 构造函数，它接收一个函数作为参数，这个函数有两个函数参数：<code>resolve</code> 和 <code>reject</code>。在这个函数里完成所有工作，完成之后，在成功时调用 <code>resolve</code>，如果有错误则调用 <code>reject</code>。</p>

<p>需要注意的是只有<strong>一个</strong><code>resolve</code> 或者 <code>reject</code> 被调用，即应该只被调用一次。在我们的示例中，如果 <code>fs.readFile</code> 返回错误，我们将错误传递给 <code>reject</code>，否则将文件数据传递给<code>resolve</code>。</p>

<h4>Promise 的值</h4>

<p>ES6 有两个很方便的辅助函数，用于通过普通值创建 Promise：<code>Promise.resolve()</code> 和 <code>Promise.reject()</code>。例如，可能需要在同步处理某些情况时一个返回 Promise 的函数：</p>

<pre><code class="javascript">function readFilePromise(filename) {
  if (!filename) {
    return Promise.reject(new Error("Filename not specified"));
  }
  if (filename === 'index.html') {
    return Promise.resolve('&lt;h1&gt;Hello!&lt;/h1&gt;');
  }
  return new Promise((resolve, reject) =&gt; {/*...*/})
}
</code></pre>

<p>注意，虽然可以传递任何东西（或者不传递任何值）给 <code>Promise.reject()</code>，但是好的做法是传递一个<code>Error</code>。</p>

<h4>并行运行</h4>

<p><code>Promise.all</code>是一个并行运行 Promise 数组的方法，也就是说是同时运行。例如，我们有一个要从磁盘读取文件的列表。使用上面创建的 <code>readFilePromise</code> 函数，将如下所示：</p>

<pre><code class="javascript">let filenames = ['index.html', 'blog.html', 'terms.html'];

Promise.all(filenames.map(readFilePromise))
  .then(files =&gt; {
    console.log('index:', files[0]);
    console.log('blog:', files[1]);
    console.log('terms:', files[2]);
  })
</code></pre>

<p>我甚至不会使用传统的回调函数来尝试编写与之等效的代码，那样会很凌乱，而且也容易出错。</p>

<h4>串行运行</h4>

<p>有时同时运行一堆 Promise 可能会出现问题。比如，如果尝试使用 <code>Promise.all</code> 的 API ​​去检索一堆资源，则可能会在达到速率限制时开始响应<a href="https://httpstatuses.com/429">429错误</a>。</p>

<p>一种解决方案是串行运行 Promise，或一个接一个地运行。但是在 ES6 中没有提供类似 <code>Promise.all</code> 这样的方法（为什么？），但我们可以使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce?v=b"><code>Array.reduce</code></a> 来实现：</p>

<pre><code class="javascript">let itemIDs = [1, 2, 3, 4, 5];

itemIDs.reduce((promise, itemID) =&gt; {
  return promise.then(_ =&gt; api.deleteItem(itemID));
}, Promise.resolve());
</code></pre>

<p>在这种情况下，我们需要等待每次调用 <code>api.deleteItem()</code> 完成之后才能进行下一次调用。这种方法，比为每个 itemID 写 <code>.then()</code> 更简洁更通用：</p>

<pre><code class="javascript">Promise.resolve()
  .then(_ =&gt; api.deleteItem(1))
  .then(_ =&gt; api.deleteItem(2))
  .then(_ =&gt; api.deleteItem(3))
  .then(_ =&gt; api.deleteItem(4))
  .then(_ =&gt; api.deleteItem(5));
</code></pre>

<h4>Race</h4>

<p>ES6 提供的另一个很方便的函数是 <code>Promise.race</code>。跟 <code>Promise.all</code> 一样，接收一个 Promise 数组，并同时运行它们，但不同的是，会在一旦<strong>任何</strong> Promise 完成或失败的情况下返回，并放弃所有其他的结果。</p>

<p>例如，我们可以创建一个在几秒钟之后超时的 Promise：</p>

<pre><code class="javascript">function timeout(ms) {
  return new Promise((resolve, reject) =&gt; {
    setTimeout(reject, ms);
  })
}

Promise.race([readFilePromise('index.html'), timeout(1000)])
  .then(data =&gt; console.log(data))
  .catch(e =&gt; console.log("Timed out after 1 second"))
</code></pre>

<p>需要注意的是，其他 Promise 仍将继续运行 ，只是看不到结果而已。</p>

<h4>捕获错误</h4>

<p>捕获错误最常见的方式是添加一个  <code>.catch()</code> 代码块，这将捕获前面所有 <code>.then()</code> 代码块中的错误  ：</p>

<pre><code class="javascript">Promise.resolve()
  .then(_ =&gt; api.getItem(1))
  .then(item =&gt; {
    item.amount++;
    return api.updateItem(1, item);
  })
  .catch(e =&gt; {
    console.log('failed to get or update item');
  })
</code></pre>

<p>在这里，只要有 <code>getItem</code> 或者 <code>updateItem</code> 失败，<code>catch()</code>就会被触发。但是如果我们想分开处理 <code>getItem</code> 的错误怎么办？只需再插入一个<code>catch()</code> 就可以，它也可以返回另一个 Promise。</p>

<pre><code class="javascript">Promise.resolve()
  .then(_ =&gt; api.getItem(1))
  .catch(e =&gt; api.createItem(1, {amount: 0}))
  .then(item =&gt; {
    item.amount++;
    return api.updateItem(1, item);
  })
  .catch(e =&gt; {
    console.log('failed to update item');
  })
</code></pre>

<p>现在，如果<code>getItem()</code>失败，我们通过第一个 <code>catch</code> 介入并创建一条新的记录。</p>

<h4>抛出错误</h4>

<p>应该将 <code>then()</code> 语句中的所有代码视为 <code>try</code> 块内的所有代码。<code>return Promise.reject()</code> 和 <code>throw new Error()</code> 都会导致下一个 <code>catch()</code> 代码块的运行。</p>

<p>这意味着运行时错误也会触发 <code>catch()</code>，所以不要去假设错误的来源。例如，在下面的代码中，我们可能希望该 <code>catch()</code> 只能获得 <code>getItem</code> 抛出的错误，但是如示例所示，它还会在我们的 <code>then()</code> 语句中捕获运行时错误。</p>

<pre><code class="javascript">api.getItem(1)
  .then(item =&gt; {
    delete item.owner;
    console.log(item.owner.name);
  })
  .catch(e =&gt; {
    console.log(e); // Cannot read property 'name' of undefined
  })
</code></pre>

<h4>动态链</h4>

<p>有时，我们想要动态地构建 Promise 链，例如，在满足特定条件时，插入一个额外的步骤。在下面的示例中，在读取给定文件之前，我们可以选择创建一个锁定文件：</p>

<pre><code class="javascript">function readFileAndMaybeLock(filename, createLockFile) {
  let promise = Promise.resolve();

  if (createLockFile) {
    promise = promise.then(_ =&gt; writeFilePromise(filename + '.lock', ''))
  }

  return promise.then(_ =&gt; readFilePromise(filename));
}
</code></pre>

<p>一定要通过重写 <code>promise = promise.then(/*...*/)</code> 来更新 <code>Promise</code> 的值。参看接下来反模式中会提到的 <strong>多次调用 then()</strong>。</p>

<h2>反模式</h2>

<p>Promise 是一个整洁的抽象，但很容易陷入某些陷阱。以下是我遇到的一些最常见的问题。</p>

<h4>重回回调地狱</h4>

<p>当我第一次从回调函数转到 Promise 时，发现很难摆脱一些旧习惯，仍像使用回调函数一样嵌套 Promise：</p>

<pre><code class="javascript">api.getItem(1)
  .then(item =&gt; {
    item.amount++;
    api.updateItem(1, item)
      .then(update =&gt; {
        api.deleteItem(1)
          .then(deletion =&gt; {
            console.log('done!');
          })
      })
  })
</code></pre>

<p>这种嵌套是完全没有必要的。有时一两层嵌套可以帮助组合相关任务，但是最好总是使用 <code>.then()</code> 重写成 Promise 垂直链  。</p>

<h4>没有返回</h4>

<p>我遇到的一个经常会犯的错误是在一个 Promise 链中忘记 <code>return</code> 语句。你能发现下面的 bug 吗？</p>

<pre><code class="javascript">api.getItem(1)
  .then(item =&gt; {
    item.amount++;
    api.updateItem(1, item);
  })
  .then(update =&gt; {
    return api.deleteItem(1);
  })
  .then(deletion =&gt; {
    console.log('done!');
  })
</code></pre>

<p>因为我们没有在第4行的 <code>api.updateItem()</code> 前面写 <code>return</code>，所以 <code>then()</code> 代码块会立即 resolove，导致 <code>api.deleteItem()</code> 可能在<code>api.updateItem()</code> 完成之前就被调用。</p>

<p>在我看来，这是 ES6 Promise 的一个大问题，往往会引发意想不到的行为。问题是，  <code>.then()</code> 可以返回一个值，也可以返回一个新的 Promise，<code>undefined</code> 完全是一个有效的返回值。就个人而言，如果我负责 Promise API，我会在 <code>.then()</code> 返回   <code>undefined</code> 时抛出运行时错误，但现在我们需要特别注意 <code>return</code> 创建的 Promise。</p>

<h4>多次调用 <code>.then()</code></h4>

<p>根据规范，在同一个 Promise 上多次调用 <code>then()</code> 是完全有效的，并且回调将按照其注册顺序被调用。但是，我并未见过需要这样做的场景，并且在使用返回值和错误处理时可能会产生一些意外行为：</p>

<pre><code class="javascript">let p = Promise.resolve('a');
p.then(_ =&gt; 'b');
p.then(result =&gt; {
  console.log(result) // 'a'
})

let q = Promise.resolve('a');
q = q.then(_ =&gt; 'b');
q = q.then(result =&gt; {
  console.log(result) // 'b'
})
</code></pre>

<p>在这个例子中，因为我们在每次调用 <code>then()</code> 不更新 <code>p</code> 的值，所以我们看不到 <code>'b'</code> 返回。但是每次调用 <code>then()</code> 时更新 <code>q</code>，所以其行为更可预测。</p>

<p>这也适用于错误处理：</p>

<pre><code class="javascript">let p = Promise.resolve();
p.then(_ =&gt; {throw new Error("whoops!")})
p.then(_ =&gt; {
  console.log('hello!'); // 'hello!'
})

let q = Promise.resolve();
q = q.then(_ =&gt; {throw new Error("whoops!")})
q = q.then(_ =&gt; {
  console.log('hello'); // We never reach here
})
</code></pre>

<p>在这里，我们期望的是抛出一个错误来打破 Promise 链，但由于没有更新 <code>p</code> 的值，所以第二个 <code>then()</code> 仍会被调用。</p>

<p>有可能在一个 Promise 上多次调用 <code>.then()</code> 有很多理由  ，因为它允许将 Promise 分配到几个新的独立的 Promise 中，但是还没发现真实的使用场景。</p>

<h4>混合使用回调和 Promise</h4>

<p>很容易进入一种陷阱，在使用基于 Promise 库的同时，仍在基于回调的项目中工作。始终避免在 <code>then()</code> 或 <code>catch()</code> 使用回调函数 ，否则 Promise 会吞噬任何后续的错误，将其作为 Promise 链的一部分。例如，以下内容看起来是一个挺合理的方式，使用回调函数来包装一个 Promise：</p>

<pre><code class="javascript">function getThing(callback) {
  api.getItem(1)
    .then(item =&gt; callback(null, item))
    .catch(e =&gt; callback(e));
}

getThing(function(err, thing) {
  if (err) throw err;
  console.log(thing);
})
</code></pre>

<p>这里的问题是，如果有错误，我们会收到关于“Unhandled promise rejection”的警告，即使我们添加了一个 <code>catch()</code> 代码块。这是因为，<code>callback()</code> 在 <code>then()</code> 和 <code>catch()</code> 都会被调用，使之成为 Promise 链的一部分。</p>

<p>如果必须使用回调来包装 Promise，可以使用  <code>setTimeout</code> （或者是 NodeJS 中的 <code>process.nextTick</code>）来打破 Promise：</p>

<pre><code class="javascript">function getThing(callback) {
  api.getItem(1)
    .then(item =&gt; setTimeout(_ =&gt; callback(null, item)))
    .catch(e =&gt; setTimeout(_ =&gt; callback(e)));
}

getThing(function(err, thing) {
  if (err) throw err;
  console.log(thing);
})
</code></pre>

<h4>不捕获错误</h4>

<p>JavaScript 中的错误处理有点奇怪。虽然支持熟悉的 <code>try/catch</code> 范例，但是没有办法强制调用者以 Java 的方式处理错误。然而，使用回调函数，使用所谓的“errbacks”，即第一个参数是一个错误回调变得很常见。这迫使调用者至少承认错误的可能性。例如，<code>fs</code> 库：</p>

<pre><code class="javascript">fs.readFile('index.html', 'utf8', (err, data) =&gt; {
  if (err) throw err;
  console.log(data);
})
</code></pre>

<p>使用 Promise，又将很容易忘记需要进行错误处理，特别是对于敏感操作（如文件系统和数据库访问）。目前，如果没有捕获到 reject 的 Promise，将在 NodeJS 中看到非常丑的警告：</p>

<pre><code class="text">(node:29916) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1): Error: whoops!
(node:29916) DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.
</code></pre>

<p>确保在主要的事件循环中任何 Promise 链的末尾添加 <code>catch()</code> 以避免这种情况。</p>

<h2>总结</h2>

<p>希望这是一篇有用的关于常见 Promise 模式和反模式的概述。如果你想了解更多，这里有一些有用的资源：</p>

<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Mozilla 的 ES6 Promise 文档</a></li>
<li><a href="https://developers.google.com/web/fundamentals/getting-started/primers/promises">来自 Google 的 Promise 介绍</a></li>
<li><a href="http://www.datchley.name/es6-promises/">Dave Atchley 的 ES6 Promise 概述</a></li>
</ul>


<p>更多的 Promise <a href="http://www.datchley.name/promise-patterns-anti-patterns/">模式</a>和<a href="https://hackernoon.com/javascript-promises-best-practices-anti-patterns-b32309f65551">反模式</a></p>

<p><a href="https://medium.com/datafire-io">或者阅读来自 DataFire 团队的内容</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在 Node.js 中使用原生 ES 模块]]></title>
    <link href="http://blog.mirreal.net/blog/2017/09/13/using-es-modules-natively-in-node-dot-js/"/>
    <updated>2017-09-13T16:19:59+08:00</updated>
    <id>http://blog.mirreal.net/blog/2017/09/13/using-es-modules-natively-in-node-dot-js</id>
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="http://2ality.com/2017/09/native-esm-node.html">Using ES modules natively in Node.js</a></p>

<p>作者：<a href="https://twitter.com/rauschma">Axel Rauschmayer</a></p></blockquote>

<p>从版本 8.5.0 开始，Node.js 开始支持原生 ES 模块，可以通过命令行选项打开该功能。新功能很大程度上得归功于 <a href="https://twitter.com/bradleymeck">Bradley Farias</a>。</p>

<h2>1.演示</h2>

<p>这个示例的代码目录结构如下：</p>

<pre><code>esm-demo/
    lib.mjs
    main.mjs
</code></pre>

<p>lib.mjs：</p>

<pre><code class="javascript">export function add(x, y) {
    return x + y;
}
</code></pre>

<p>main.mjs：</p>

<pre><code class="javascript">import {add} from './lib.mjs';

console.log('Result: '+add(2, 3));
</code></pre>

<p>运行演示：</p>

<pre><code class="sh">$ node --experimental-modules main.mjs
Result: 5
</code></pre>

<h2>2.清单：需要注意的事情</h2>

<h3>ES 模块：</h3>

<ul>
<li><p>不能动态导入模块。但是 <a href="http://2ality.com/2017/01/import-operator.html">动态 import()</a> 的相关工作正在进行中，应该很快就能提供支持。</p></li>
<li><p>没有元变量，如 <code>__dirname</code> 和 <code>__filename</code>。但是，有一个的类似功能的提案：“<a href="https://github.com/tc39/proposal-import-meta">import.meta</a>”。看起来可能是这样：</p></li>
</ul>


<pre><code class="javascript">console.log(import.meta.url);
</code></pre>

<ul>
<li>现在所有模块标识符都是 URL（这部分在 Node.js 是新增的）：

<ul>
<li>文件 - 带文件扩展名的相对路径： <code>../util/tools.mjs</code></li>
<li>库 - 没有文件扩展名，也没有路径 <code>lodash</code></li>
<li>如何更好地使 npm 库在浏览器中也可用（不使用 bundler）仍有待观察。一种可能性是引入 RequireJS 风格的配置数据，将路径映射到实际路径。目前，在浏览器中使用 bare path 的模块标识符是非法的。</li>
</ul>
</li>
</ul>


<h3>与 CJS 模块的互操作性</h3>

<ul>
<li>你可以导入 CJS 模块，但它们总是只有默认的导出 - 即 <code>module.exports</code> 的值。让 CJS 模块支持命名导出已经在做了，但可能需要一段时间。如果你能帮忙，<a href="https://twitter.com/bradleymeck/status/906210545145184257">可以来做</a>。</li>
</ul>


<pre><code class="javascript">import fs1 from 'fs';
console.log(Object.keys(fs1).length); // 86

import * as fs2 from 'fs';
console.log(Object.keys(fs2)); // ['default']
</code></pre>

<ul>
<li>不能在 ES 模块中使用 require()。主要原因是：

<ul>
<li>路径解析工作稍有不同：ESM 不支持 <code>NODE_PATH</code> 和 <code>require.extensions</code>。而且，它的标识符始终是 URL 也会导致一些细微差异。</li>
<li>ES 模块始终以异步方式加载，这确保了与 Web 的最大兼容性。这种加载风格并不能通过 require() 混合使用同步加载 CJS 模块。</li>
<li>禁止同步模块加载也可以为 Top-level await 导入 ES 模块保留后路（一个当前正在考虑的功能）。</li>
</ul>
</li>
</ul>


<h2>3.早期版本的 Node.js 上的 ES 模块</h2>

<p>如果要在 8.5.0 之前的 Node.js 版本上使用 ES 模块，请参阅 John-David Dalton 的 <a href="https://github.com/standard-things/esm">@std/esm</a>。</p>

<p>提示：如果不启用任何可解锁的额外功能，将在 Node.js 保持 100％ 兼容原生 ES 模块.</p>

<h2>FAQ</h2>

<h3>什么时候可以不带命令行选项使用ES 模块？</h3>

<p>目前的计划是在 Node.js 10 LTS 中默认可使用 ES 模块。</p>

<h2>进一步阅读  </h2>

<p>有关 Node.js 和浏览器中 ES 模块的更多信息：</p>

<ul>
<li>“<a href="http://2ality.com/2017/01/babel-esm-spec-mode.html">Making transpiled ES modules more spec-compliant</a>” [using ES modules natively vs. transpiling them via Babel]</li>
<li>“<a href="http://2ality.com/2017/05/es-module-specifiers.html">Module specifiers: what’s new with ES modules?</a>” [Why <code>.mjs</code>? How are module specifiers resolved? Etc.]</li>
<li>“<a href="http://exploringjs.com/es6/ch_modules.html">Modules</a>” [in-depth chapter on ES modules in “Exploring ES6”]</li>
</ul>


<p>即将到来的 ECMAScript 提案：</p>

<ul>
<li>博客: “<a href="http://2ality.com/2017/01/import-operator.html">ES proposal: <code>import()</code> – dynamically importing ES modules</a>”</li>
<li>提案: “<a href="https://github.com/tc39/proposal-import-meta"><code>import.meta</code></a>”</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在工作中学习]]></title>
    <link href="http://blog.mirreal.net/blog/2017/09/02/learning-at-work/"/>
    <updated>2017-09-02T21:49:52+08:00</updated>
    <id>http://blog.mirreal.net/blog/2017/09/02/learning-at-work</id>
    <content type="html"><![CDATA[<blockquote><p>原文；<a href="https://jvns.ca/blog/2017/08/06/learning-at-work/">Learning at work</a></p>

<p>作者：Julia Evans</p>

<p>谈点：学习是一件没有尽头的事，虽然在工作中很多时候被淹没在没玩没了的需求里面，加班是常态，或许很多人不知不觉放弃学习的心思。这篇文章中提到的一些方法我很赞同，很多点也是我的做事方式，这里也希望所有人都能找到适合自己的学习方式。</p></blockquote>

<p>在 Twitter 上我提了一个问题，“你是如何花时间用于自身学习”（<a href="https://twitter.com/b0rk/status/887111177062555648">这个推文</a>)，这些回答有一些相同之处：</p>

<ul>
<li>阅读博客文章</li>
<li>去参加业界大会</li>
<li>读书</li>
<li>在洗碗时看一些演讲</li>
<li>在一些不那么重要的项目里运用你想要学习的技术</li>
</ul>


<p>这些方法都挺管用的。为了个人职业发展，在工作之外花时间学习新技能是非常普遍的事，在这方面我也有不少经验。</p>

<p>另一方面，我知道有一些很厉害的程序员在工作之外完全不写代码。于是我开始思考，如果你想变得更牛，但又不想工作之外花太多额外时间要怎么办？</p>

<p>这些是我以及在 Twitter 上的朋友提到的一些观点，并且都是能在工作时候做的事情。</p>

<h2>不要学习工作之外的编程语言/框架</h2>

<p>这一点听起来有些消极，但确实还是很有用的。对于学习编程语言，我的观点是：</p>

<ul>
<li>我很熟悉几种编程语言（python，scala，ruby）</li>
<li>学习新的编程语言需要相当长的时间</li>
<li>我不想把空闲时间花在上面</li>
</ul>


<p>最近我在做一些 Go 方面的工作，还挺有趣的，我也喜欢做这件事。但是又觉得在上面花费太多个人时间，所以显得不是那么有趣了。通过编写代码学习编程，阅读别人的代码掌握一些模式，然后自己审查代码，然而这些都不是必须的，因为完全可以在工作中去做这些事情。</p>

<h2>选择一些可以从中学习的项目</h2>

<p>这些是我在过去三年学到的一些东西：</p>

<ul>
<li>Scala/Ruby/Go</li>
<li>hadoop/mapreduce/scalding</li>
<li>如何使用 Java 并发库，以及如何配置一个 Java 程序</li>
<li>关于各种 AWS 服务的工作原理</li>
<li>很多机器学习的东西</li>
<li>网络/ CDN / TLS 如何工作</li>
<li>docker/容器/rkt/kubernetes</li>
<li>服务发现 / DNS / jenkins</li>
</ul>


<p>一个关于如何选择项目的例子：如果在工作使用一个不能很好并行的程序，这时候问题就来了。我可以选择去问写这个程序的人为什么不使用并行编程，但是如果我也很想学习一下并行编程的话，就可以自己去完成这件事。所以后来我就 <a href="https://jvns.ca/blog/2016/03/29/thread-pools-part-ii-i-love-blocking/">学到了如何在 Java 中使用线程池</a>。</p>

<p>我只为此工作了几天，但却因此学到了新东西。</p>

<p>现在我正在从事 Kubernetes 相关的工作，当时选择它并不是因为可以在这里面学到很多东西。但是我确实学到很多有关分布式系统的东西，还在工作中使用 Go 语言，我觉得这很很棒。</p>

<p>当人们说像“嘿，我们使用 X 技术，需要有相关经验的人才能在这里工作”时，这其实相当愚蠢。现在我在网络/ puppet / kubernetes / docker / AWS 上花了很多时间，在这项工作之前没有任何相关工作经验。</p>

<h2>观察那些高级人员是如何做事的</h2>

<p>我会观察那些我敬佩的人在工作中的做事方式，然后尝试模仿他们或者是向他们寻求建议。例如，当 <a href="http://onemogin.com/">Cory</a> 加入时，我注意到，在引进新技术的时候，他会这样做：</p>

<ul>
<li>找到另一个有类似问题需要解决的团队</li>
<li>与他们合作，确保技术真正解决问题</li>
</ul>


<p>现在我正在开展一个新项目，一直在考虑这些工作可以帮到谁以及如何帮助，这样做就会感觉好很多。</p>

<h2>阅读每个 pull request</h2>

<p>在这个主题下引用两个我很喜欢的观点：</p>

<blockquote><p>我在一个小团队，所以会阅读所有的 pull request，直到完全了解问题和解决方案</p></blockquote>

<p>和</p>

<blockquote><p>我也是一样！我跟踪检查，看看人们如何解决各种问题</p></blockquote>

<p>事实上，我并没有阅读团队中的每一个 pull request。但是那确实很有用，通过跟踪别人在这方面做的工作来学习这个领域的东西。</p>

<p>但我并不是能完全做到。我曾经从事机器学习方面的工作，发现理论也很有趣，就想跟踪人们在这方面的情况，但对我来说有太多要注意的东西。我只能尽量注意那些比较接近我的东西，像是其中网络团队的一些工作。</p>

<h2>阅读源代码</h2>

<blockquote><p>阅读我用到的源代码对我而言是一个大块头。了解它在内部在做什么，主要是为什么可以通过某种方式工作。</p></blockquote>

<p>这是很重要的一点，也非常重要。很多库、框架、工具并没有很好的文档，在没有阅读源代码的情况下根本无法了解其工作原理。</p>

<h2>跟进你无法解决的 bug</h2>

<p>有时我会遇到一些自己没办法解决的 bug。后来，可能别人会找到解决方法，在这时候，就值得花时间去搞清楚具体的解决方法是什么，以及他们如何想出来的。</p>

<p>例如，最近有一个我没有调试出来的网络问题，刚好有人在上周搞清楚这个问题。现在想一想，大概明白造成这个 bug 的原因，但是我并不清楚他们用什么工具来获取调试所需的信息。当我重新开始工作时，必须确保我真的搞清楚这个问题，这样下次就可以做得更好。</p>

<p>Jessica Kerr 评论道</p>

<blockquote><p>每当我在故障排除时，除了解决这个问题，还会更深入或更广泛地延伸开去。</p></blockquote>

<p>我也喜欢这个回复：</p>

<blockquote><p>有时候，想解决一个与工作有关的问题，但并没有真的在实际工作中发生，只是看看我能不能在某方面有所突破。</p></blockquote>

<h2>运用好通勤时间</h2>

<p>对我而言，其实并没有通勤时间。但很多人提到他们会利用通勤时间来听播客/阅读报纸/阅读有趣的文章。这似乎是一个很不错的方式，来做一些你感兴趣的事情。</p>

<h2>花时间在工作中学习</h2>

<p>Twitter上有人说“我希望每天可以花 1 小时来学习”。我的观点是，我的工作就是要在工作日中抽出时间来学习东西。像现在我正在工作中使用 Kubernetes，这是一个很复杂的系统需要很长时间才能理解，我得花时间了解它是如何工作的。例如，在开始的时候，没什么目的地在做集群测试，只是想了解容器的网络如何工作的，同时也在项目上取得进展。</p>

<p>这可能对我来说挺容易的，因为我的工作跟别人隔得很远，没有人真的知道我具体在做什么，他们只是关心在大方面做的是什么。</p>

<p>实际上，如果要是提前多花点时间阅读，可能效果会更好。就像我刚刚在阅读 Kelsey Hightower 的“learn kubernetes the hard way”的文档，读完不需花太长时间，而且其中有一个关于如何设置一个集群的很好的点，这样就可以很节省我很多时间。</p>

<p>关于这个点，有些人还要想得更远。比如，我的朋友 Dan 就提到好几次，说他喜欢在工作中阅读技术书籍。最初觉得这是一件令人惊讶的事情，但它确实很有用。事实上，有很多跟我工作相关的书籍，找不到理由为什么不能在工作中阅读它们。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript 中的匿名递归]]></title>
    <link href="http://blog.mirreal.net/blog/2017/08/09/anonymous-recursion-in-javascript/"/>
    <updated>2017-08-09T14:54:22+08:00</updated>
    <id>http://blog.mirreal.net/blog/2017/08/09/anonymous-recursion-in-javascript</id>
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="https://dev.to/simov/anonymous-recursion-in-javascript">Anonymous Recursion in JavaScript</a></p>

<p>作者：Simeon Velichkov</p></blockquote>

<pre><code class="javascript">(
  (
    (f) =&gt; f(f)
  )
  (
    (f) =&gt;
      (l) =&gt; {
        console.log(l)
        if (l.length) f(f)(l.slice(1))
        console.log(l)
      }
  )
)
(
  [1, 2, 3]
)
</code></pre>

<p>是的，这就是想要分享给大家的一个有趣的示例。这个例子包含以下特性：<a href="https://en.wikipedia.org/wiki/Closure_(computer_programming">闭包</a>)，<a href="https://en.wikipedia.org/wiki/Immediately-invoked_function_expression">自执行函数</a>，<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions">箭头函数</a>，<a href="https://en.wikipedia.org/wiki/Functional_programming">函数式编程</a> 和 <a href="https://en.wikipedia.org/wiki/Anonymous_recursion">匿名递归</a>。</p>

<p>你可以复制粘贴上述代码到浏览器控制台，会看到打印结果如下：</p>

<pre><code>[ 1, 2, 3 ]
[ 2, 3 ]
[ 3 ]
[]
[]
[ 3 ]
[ 2, 3 ]
[ 1, 2, 3 ]
</code></pre>

<p>说到函数式编程，这里有一个使用 <a href="https://en.wikipedia.org/wiki/Scheme_(programming_language">Scheme</a>) (JavaScript 借鉴过的其中一门语言)编写的类似例子：</p>

<pre><code class="scheme">(
  (
    (lambda (f) (f f))
    (lambda (f)
      (lambda (l)
        (print l)
        (if (not (null? l)) ((f f) (cdr l)))
        (print l)
      )
    )
  )
  '(1 2 3)
)
</code></pre>

<h2>Unwind</h2>

<p>像其他很多编程语言一样，函数调用是通过在函数名称后添加括号 <code>()</code> 来完成的：</p>

<pre><code class="javascript">function foo () { return 'hey' }
foo()
</code></pre>

<p>在 JavaScript 中我们可以使用括号包裹任意数量的表达式：</p>

<pre><code class="javascript">('hey', 2+5, 'dev.to')
</code></pre>

<p>上面代码返回结果是 <code>'dev.to'</code>，原因是 JavaScript 返回最后一个表达式作为结果。</p>

<p>使用括号 <code>()</code> 包裹一个匿名函数表示其结果就是 <a href="https://en.wikipedia.org/wiki/Anonymous_function">匿名函数</a> 本身。</p>

<pre><code class="javascript">(function () { return 'hey' })
</code></pre>

<p>这本身并没有用处，因为匿名函数没有命名，无法被引用，除非在初始化的时候立即调用它。</p>

<p>就像是普通函数一样，我们可以在其后面添加括号 <code>()</code> 来进行调用。</p>

<pre><code class="javascript">(function () { return 'hey' })()
</code></pre>

<p>也可以使用箭头函数：</p>

<pre><code class="javascript">(() =&gt; 'hey')()
</code></pre>

<p>同样地，在匿名函数后添加括号 <code>()</code> 来执行函数，这被称为 <a href="https://en.wikipedia.org/wiki/Immediately-invoked_function_expression">自执行函数</a>。</p>

<h2>闭包</h2>

<p><a href="https://en.wikipedia.org/wiki/Closure_(computer_programming">闭包</a>) 指的是函数和该函数声明词法环境的组合。结合 <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions">箭头功能</a>，我们可以定义如下：</p>

<pre><code class="javascript">var foo = (hi) =&gt; (dev) =&gt; hi + ' ' + dev
</code></pre>

<p>在控制台调用上述函数会打印 <code>hey dev.to</code>:</p>

<pre><code class="javascript">foo('hey')('dev.to')
</code></pre>

<p>注意，我们可以在内部函数作用域访问外部函数的参数 <code>hi</code>。</p>

<p>以下代码跟上述代码一样：</p>

<pre><code class="javascript">function foo (hi) {
  return function (dev) { return hi + ' ' + dev }
}
</code></pre>

<p>自执行的版本如下：</p>

<pre><code class="javascript">(
  (hi) =&gt;
    (
      (dev) =&gt; `${hi} ${dev}`
    )
    ('dev.to')
)
('hey')
</code></pre>

<p>首先，将 <code>hey</code> 作为参数 <code>hi</code> 的值传给最外层作用域的函数，然后这个函数返回另一个自执行函数。<code>dev.to</code> 作为参数 <code>dev</code> 的值传给内部函数，最后这个函数返回最终值：<code>'hey dev.to'</code>。</p>

<h2>再深入一点</h2>

<p>这个一个上述自执行函数的修改版本：</p>

<pre><code class="javascript">(
  (
    (dev) =&gt;
      (hi) =&gt; `${hi} ${dev}`
  )
  ('dev.to')
)
('hey')
</code></pre>

<p>需要注意的是，<a href="https://en.wikipedia.org/wiki/Immediately-invoked_function_expression">自执行函数</a> 和 <a href="https://en.wikipedia.org/wiki/Closure_(computer_programming">闭包</a>) 用作初始化和封装状态，接下来我们来看另外一个例子。</p>

<h2>匿名递归</h2>

<p>回到我们最初的例子，这次加点注释：</p>

<pre><code class="javascript">(
  (
    (f) =&gt; f(f) // 3.
  )
  (
    (f) =&gt; // 2.
      (l) =&gt; { // 4.
        console.log(l)
        if (l.length) f(f)(l.slice(1))
        console.log(l)
      }
  )
)
(
  [1, 2, 3] // 1.
)
</code></pre>

<ol>
<li>输入函数 <code>[1, 2, 3]</code> 传给最外层作用域</li>
<li>整个函数作为参数传给上面函数</li>
<li>这个函数接收下面函数作为参数 <code>f</code> 的值，然后自身调用</li>
<li><code>2.</code>将被调用被作为 <code>3.</code>的结果然后返回函数 <code>4.</code> ，该函数是满足最外层作用域的函数，因此接收输入数组作为 <code>l</code> 参数的值</li>
</ol>


<p>至于结果为什么是那样子，原因是在递归内部有一个对函数 <code>f</code> 的引用来接收输入数组 <code>l</code>。所以能那样调用：</p>

<pre><code class="javascript">f(f)(l.slice(1))
</code></pre>

<p>注意，<code>f</code> 是一个闭包，所以我们只需要调用它就可以访问到操作输入数组的最里面的函数。</p>

<p>为了说明目的，第一个 <code>console.log(l)</code> 语句表示递归自上而下，第二个语句表示递归自下而上。</p>

<h2>结论</h2>

<p>希望你喜欢这篇文章，并从中学到了新的东西。闭包、自执行函数、函数式编程模式不是黑魔法。它们遵循一套易于理解和玩乐的简单原则。</p>

<p>话虽如此，你必须培养自己何时使用它们，何时不用的这样一种感觉。如果你的代码变得难以维护，那这可能会成为重构中一些好点子。</p>

<p>然而，理解这些基本技术对于创建清晰优雅的解决方案以及提升自我是至关重要的。</p>

<p>Happy Coding！</p>
]]></content>
  </entry>
  
</feed>
