<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Translator | Mirreal Note]]></title>
  <link href="http://blog.mirreal.net/blog/categories/translator/atom.xml" rel="self"/>
  <link href="http://blog.mirreal.net/"/>
  <updated>2017-12-04T08:56:51+08:00</updated>
  <id>http://blog.mirreal.net/</id>
  <author>
    <name><![CDATA[Patrick Ran]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[React 整洁代码最佳实践]]></title>
    <link href="http://blog.mirreal.net/blog/2017/12/01/clean-code-vs-dirty-code-react-best-practices/"/>
    <updated>2017-12-01T08:53:45+08:00</updated>
    <id>http://blog.mirreal.net/blog/2017/12/01/clean-code-vs-dirty-code-react-best-practices</id>
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="http://americanexpress.io/clean-code-dirty-code/">Clean Code vs. Dirty Code: React Best Practices</a></p>

<p>作者：Donavon West</p></blockquote>

<p>本文主要介绍了适用于现代 React 软件开发的整洁代码实践，顺便谈谈 ES6/ES2015 带来的一些好用的“语法糖”。</p>

<h2>什么是整洁代码，为什么要在乎？</h2>

<p>整洁代码代表的是一种一致的编码风格，目的是让代码更易于编写，阅读和维护。通常情况下，开发者在解决问题的时候，一旦问题解决就发起一个 Pull Request（译注：合并请求，在 Gitlab 上叫 Merge Request）。但我认为，这时候工作并没有真正完成，我们不能仅仅满足于代码可以工作。</p>

<p>这时候其实就是整理代码的最好时机，可以通过删除死代码（僵尸代码），重构以及删除注释掉的代码，来保持代码的可维护性。不妨问问自己，“从现在开始再过六个月，其他人还能理解这些代码吗？”简而言之，对于自己编写的代码，你应该保证能很自豪地拿给别人看。</p>

<p>至于为什么要在乎这点？因为我们常说一个优秀的开发者大都比较”懒“。在遇到需要重复做某些事情的情况下，他们会去找到一个自动化（或更好的）解决方案来完成这些任务。</p>

<h3>整洁代码能够通过“味道测试”</h3>

<p>整洁代码应该可以通过“味道测试”。什么意思呢？我们在看代码的时候，包括我们自己写的或或是别人的，会说：“这里不太对劲。”如果感觉不对，那可能就真的是有问题的。如果你觉得你正在试图把一个方形钉子装进一个圆形的洞里，那么就暂停一下，然后休息一下。多次尝试之后，你会找到一个更好的解决方案。</p>

<h3>整洁代码是符合 DRY 原则的</h3>

<p>DRY 是一个缩略词，意思是“不要重复自己”（Don’t Repeat Yourself）。如果发现多个地方在做同样的事情，那么这时候就应该合并重复代码。如果在代码中看到了模式，那么表明需要实行 DRY。</p>

<pre><code class="js">// Dirty
const MyComponent = () =&gt; (
  &lt;div&gt;
    &lt;OtherComponent type="a" className="colorful" foo={123} bar={456} /&gt;
    &lt;OtherComponent type="b" className="colorful" foo={123} bar={456} /&gt;    
  &lt;/div&gt;
);
</code></pre>

<pre><code class="js">// Clean
const MyOtherComponent = ({ type }) =&gt; (
  &lt;OtherComponent type={type} className="colorful" foo={123} bar={456} /&gt;
);
const MyComponent = () =&gt; (
  &lt;div&gt;
    &lt;MyOtherComponent type="a" /&gt;
    &lt;MyOtherComponent type="b" /&gt;
  &lt;/div&gt;
);
</code></pre>

<p>有时候，比如在上面的例子中，实行 DRY 原则反而可能会增加代码量。但是，DRY 通常也能够提高代码的可维护性。</p>

<p>注意，很容易陷入过分使用 DRY 原则的陷阱，应该学会适可而止。</p>

<h3>整洁代码是可预测和可测试的</h3>

<p>编写单元测试不仅仅只是一个好想法，而且应该是强制性的。不然，怎么能确保新功能不会在其他地方引起 Bug 呢？</p>

<p>许多 React 开发人员选择 <a href="https://facebook.github.io/jest/">Jest</a> 作为一个零配置测试运行器，然后生成代码覆盖率报告。如果对测试前后对比可视化感兴趣，请查看美国运通的 <a href="https://github.com/americanexpress/jest-image-snapshot">Jest Image snanshot</a>。</p>

<h3>整洁代码是自注释的</h3>

<p>以前发生过这种情况吗？你写了一些代码，并且包含详细的注释。后来你发现一个 bug，于是回去修改代码。但是，你有没有改变注释来体现新的逻辑？也许会，也许不会。下一个看你代码的人可能因为注意到这些注释而掉进一个陷阱。</p>

<p>注释只是为了解释复杂的想法，也就是说，不要对显而易见的代码进行注释。同时，更少的注释也减少了视觉上的干扰。</p>

<pre><code class="js">// Dirty
const fetchUser = (id) =&gt; (
  fetch(buildUri`/users/${id}`) // Get User DTO record from REST API
    .then(convertFormat) // Convert to snakeCase
    .then(validateUser) // Make sure the the user is valid
);
</code></pre>

<p>在整洁代码的版本中，我们对一些函数进行重命名，以便更好地描述它们的功能，从而消除注释的必要性，减少视觉干扰。并且避免后续因代码与注释不匹配导致的混淆。</p>

<pre><code class="js">// Clean
const fetchUser = (id) =&gt; (
  fetch(buildUri`/users/${id}`)
    .then(snakeToCamelCase)
    .then(validateUser)
);
</code></pre>

<h3>命名</h3>

<p>在我之前的文章 <a href="http://americanexpress.io/faccs-are-an-antipattern">将函数作为子组件是一种反模式</a>，强调了命名的重要性。每个开发者都应该认真考虑变量名，函数名，甚至是文件名。</p>

<p>这里列举一下命名原则：</p>

<ul>
<li><p>布尔变量或返回布尔值的函数应该以“is”，“has”或“should”开头。</p>

<pre><code class="js">// Dirty
const done = current &gt;= goal;
</code></pre>

<pre><code class="js">// Clean
const isComplete = current &gt;= goal;
</code></pre></li>
<li><p>函数命名应该体现做了什么，而不是是怎样做的。换言之，不要在命名中体现出实现细节。假如有天出现变化，就不需要因此而重构引用该函数的代码。比如，今天可能会从 REST API 加载配置，但是可能明天就会将其直接写入到 JavaScript 中。</p>

<pre><code class="js">// Dirty
const loadConfigFromServer = () =&gt; {
  ...
};
</code></pre>

<pre><code class="js">// Clean
const loadConfig = () =&gt; {
  ...
};
</code></pre></li>
</ul>


<h3>整洁代码遵循成熟的设计模式和最佳实践</h3>

<p>计算机已经存在很长一段时间了。多年以来，程序员通过解决某些特定问题，发现了一些固有套路，被称为设计模式。换言之，有些算法已经被证明是可以工作的，所以应该站在前人的肩膀上，避免犯同样的错误。</p>

<p>那么，什么是最佳实践，与设计模式类似，但是适用范围更广，不仅仅针对编码算法。比如，“应该对代码进行静态检查”或者“当编写一个库时，应该将 React 作为 <code>peerDependency</code>”，这些都可以称为最佳实践。</p>

<p>构建 React 应用程序时，应该遵循以下最佳实践：</p>

<ul>
<li>使用小函数，每个函数具备单一功能，即所谓的单一职责原则（Single responsibility principle）。确保每个函数都能完成一项工作，并做得很好。这样就能将复杂的组件分解成许多较小的组件。同时，将具备更好的可测试性。</li>
<li>小心抽象泄露（leaky abstractions）。换言之，不要强迫消费方去了解内部代码实现细节。</li>
<li>遵循严格的代码检查规则。这将有助于编写整洁，一致的代码。</li>
</ul>


<h3>整洁代码不需要花长时间来编写</h3>

<p>总会听到这样的说法：编写整洁代码会降低生产力。简直是在胡说八道。是的，可能刚开始需要放慢速度，但最终会随着编写更少的代码而节奏加快。</p>

<p>而且，不要小看代码评审导致的重写重构，以及修复问题花费的时间。如果把代码分解成小的模块，每个模块都是单一职责，那么很可能以后再也不用去碰大多数模块了。时间就省下来了，也就是说 “write it and forget it”。</p>

<h2>槽糕代码与整洁代码的实例</h2>

<h3>使用 DRY 原则</h3>

<p>看看下面的代码示例。如上所述，从你的显示器退后一步，发现什么模式了吗？注意 <code>Thingie</code> 组件与 <code>ThingieWithTitle</code> 组件除了 <code>Title</code> 组件几乎完全相同，这是实行 DRY 原则的最佳情形。</p>

<pre><code class="js">// Dirty
import Title from './Title';

export const Thingie = ({ description }) =&gt; (
  &lt;div class="thingie"&gt;
    &lt;div class="description-wrapper"&gt;
      &lt;Description value={description} /&gt;
    &lt;/div&gt;
  &lt;/div&gt;
);

export const ThingieWithTitle = ({ title, description }) =&gt; (
  &lt;div&gt;
    &lt;Title value={title} /&gt;
    &lt;div class="description-wrapper"&gt;
      &lt;Description value={description} /&gt;
    &lt;/div&gt;
  &lt;/div&gt;
);
</code></pre>

<p>在这里，我们将 <code>children</code> 传递给 <code>Thingie</code>。然后创建 <code>ThingieWithTitle</code>，这个组件包含 <code>Thingie</code>，并将 <code>Title</code> 作为其子组件传给 <code>Thingie</code>。</p>

<pre><code class="js">// Clean
import Title from './Title';

export const Thingie = ({ description, children }) =&gt; (
  &lt;div class="thingie"&gt;
    {children}
    &lt;div class="description-wrapper"&gt;
      &lt;Description value={description} /&gt;
    &lt;/div&gt;
  &lt;/div&gt;
);

export const ThingieWithTitle = ({ title, ...others }) =&gt; (
  &lt;Thingie {...others}&gt;
    &lt;Title value={title} /&gt;
  &lt;/Thingie&gt;
);
</code></pre>

<h3>默认值</h3>

<p>看看下面的代码。使用逻辑或将 <code>className</code> 的默认值设置成 “icon-large”，看起来像是上个世纪的人才会写的代码。</p>

<pre><code class="js">// Dirty
const Icon = ({ className, onClick }) =&gt; {
  const additionalClasses = className || 'icon-large';

  return (
    &lt;span
      className={`icon-hover ${additionalClasses}`}
      onClick={onClick}&gt;
    &lt;/span&gt;
  );
};
</code></pre>

<p>这里我们使用 ES6 的默认语法来替换 <code>undefined</code> 时的值，而且还能使用 ES6 的箭头函数表达式写成单一语句形式，从而去除对 <code>return</code> 的依赖。</p>

<pre><code class="js">// Clean
const Icon = ({ className = 'icon-large', onClick }) =&gt; (
  &lt;span className={`icon-hover ${className}`} onClick={onClick} /&gt;
);
</code></pre>

<p>在下面这个更整洁的版本中，使用 React 中的 API 来设置默认值。</p>

<pre><code class="js">// Cleaner
const Icon = ({ className, onClick }) =&gt; (
  &lt;span className={`icon-hover ${className}`} onClick={onClick} /&gt;
);

Icon.defaultProps = {
  className: 'icon-large',
};
</code></pre>

<p>为什么这样显得更加整洁？而且它真的会更好吗？三个版本不是都在做同样的事情吗？某种意义上来说，是对的。让 React 设置 prop 默认值的好处是，可以产生更高效的代码，而且在基于 <code>Class</code> 的生命周期组件中允许通过 <code>propTypes</code> 检查默认值。还有一个优点是：将默认逻辑从组件本身抽离出来。</p>

<p>例如，你可以执行以下操作，将所有默认属性放到一个地方。当然，并不是建议你这样做，只是说具有这样的灵活性。</p>

<pre><code class="js">import defaultProps from './defaultProps';
// ...
Icon.defaultProps = defaultProps.Icon;
</code></pre>

<h3>从渲染分离有状态的部分</h3>

<p>将有状态的数据加载逻辑与渲染逻辑混合可能增加组件复杂性。更好的方式是，写一个负责完成数据加载的有状态的容器组件，然后编写另一个负责显示数据的组件。这被称为 <a href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0">容器模式</a>。</p>

<p>在下面的示例中，用户数据加载和显示功能放在一个组件中。</p>

<pre><code class="js">// Dirty
class User extends Component {
  state = { loading: true };

  render() {
    const { loading, user } = this.state;
    return loading
      ? &lt;div&gt;Loading...&lt;/div&gt;
      : &lt;div&gt;
          &lt;div&gt;
            First name: {user.firstName}
          &lt;/div&gt;
          &lt;div&gt;
            First name: {user.lastName}
          &lt;/div&gt;
          ...
        &lt;/div&gt;;
  }

  componentDidMount() {
    fetchUser(this.props.id)
      .then((user) =&gt; { this.setState({ loading: false, user })})
  }
}
</code></pre>

<p>在整洁版本中，加载数据和显示数据已经分离。这不仅使代码更容易理解，而且能减少测试的工作量，因为可以独立测试每个部分。而且由于 <code>RenderUser</code> 是一个无状态组件，所以结果是可预测的。</p>

<pre><code class="js">// Clean
import RenderUser from './RenderUser';

class User extends Component {
  state = { loading: true };

  render() {
    const { loading, user } = this.state;
    return loading ? &lt;Loading /&gt; : &lt;RenderUser user={user} /&gt;;
  }

  componentDidMount() {
    fetchUser(this.props.id)
      .then(user =&gt; { this.setState({ loading: false, user })})
  }
}
</code></pre>

<h3>使用无状态组件</h3>

<p>React v0.14.0 中引入了无状态函数组件（SFC），被简化成纯渲染组件，但有些开发者还在使用过去的方式。例如，以下组件就应该转换为 SFC。</p>

<pre><code class="js">// Dirty
class TableRowWrapper extends Component {
  render() {
    return (
      &lt;tr&gt;
        {this.props.children}
      &lt;/tr&gt;
    );
  }
}
</code></pre>

<p>整洁版本清除了很多可能导致干扰的信息。通过 React 核心的优化，使用无状态组件将占用更少的内存，因为没有创建 Component 实例。</p>

<pre><code class="js">// Clean
const TableRowWrapper = ({ children }) =&gt; (
  &lt;tr&gt;
    {children}
  &lt;/tr&gt;
);
</code></pre>

<h3>剩余/扩展属性（rest/spread）</h3>

<p>大约在一年前，我还推荐大家多用 <code>Object.assign</code>。但时代变化很快，在 ES2016/ES7 中引入新特性 <a href="https://github.com/tc39/proposal-object-rest-spread">rest/spread</a>。</p>

<p>比如这样一种场景，当传递给一些 props 给一个组件，只希望在组件本身使用 <code>className</code>，但是需要将其他所有 props 传递到子组件。这时，你可能会这样做：</p>

<pre><code class="js">// Dirty
const MyComponent = (props) =&gt; {
  const others = Object.assign({}, props);
  delete others.className;

  return (
    &lt;div className={props.className}&gt;
      {React.createElement(MyOtherComponent, others)}
    &lt;/div&gt;
  );
};
</code></pre>

<p>这不是一个非常优雅的解决方案。但是使用 rest/spread，就能轻而易举地实现，</p>

<pre><code class="js">// Clean
const MyComponent = ({ className, ...others }) =&gt; (
  &lt;div className={className}&gt;
    &lt;MyOtherComponent {...others} /&gt;
  &lt;/div&gt;
);
</code></pre>

<p>我们将剩余属性展开并作为新的 props 传递给 <code>MyOtherComponent</code> 组件。</p>

<h3>合理使用解构</h3>

<p>ES6 引入 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">解构</a>（destructuring） 的概念，这是一个非常棒的特性，用类似对象或数组字面量的语法获取一个对象的属性或一个数组的元素。</p>

<h4>对象解构</h4>

<p>在这个例子中，<code>componentWillReceiveProps</code> 组件接收 <code>newProps</code> 参数，然后将其 <code>active</code> 属性设置为新的 <code>state.active</code>。</p>

<pre><code class="js">// Dirty
componentWillReceiveProps(newProps) {
  this.setState({
    active: newProps.active
  });
}
</code></pre>

<p>在整洁版本中，我们解构 <code>newProps</code>成 <code>active</code>。这样我们不仅不需要引用 <code>newProps.active</code>，而且也可以使用 ES6 的简短属性特性来调用 <code>setState</code>。</p>

<pre><code>// Clean
componentWillReceiveProps({ active }) {
  this.setState({ active });
}
</code></pre>

<h4>数组解构</h4>

<p>一个经常被忽视的 ES6 特性是数组解构。以下面的代码为例，它获取 <code>locale</code> 的值，比如“en-US”，并将其分成 <code>language</code>（en）和 <code>country</code>（US）。</p>

<pre><code class="js">// Dirty
const splitLocale = locale.split('-');
const language = splitLocale[0];
const country = splitLocale[1];
</code></pre>

<p>在整洁版本，使用 ES6 的数组解构特性可以自动完成上述过程：</p>

<pre><code class="js">// Clean
const [language, country] = locale.split('-');
</code></pre>

<h2>所以结论是</h2>

<p>希望这篇文章能有助于你看到编写整洁代码的好处，甚至可以直接使用这里介绍的一些代码示例。一旦你习惯编写整洁代码，将很快就会体会到 “write it and forget it” 的生活方式。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[编写扁平化的代码]]></title>
    <link href="http://blog.mirreal.net/blog/2017/11/02/writing-flat-and-declarative-code/"/>
    <updated>2017-11-02T11:20:03+08:00</updated>
    <id>http://blog.mirreal.net/blog/2017/11/02/writing-flat-and-declarative-code</id>
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="https://peeke.nl/writing-flat-code">Writing flat &amp; declarative code</a></p>

<p>作者：<a href="https://twitter.com/peeke__">Peeke Kuepers</a></p></blockquote>

<p>&ndash; <em>给你的代码增加一点点函数式编程的特性</em></p>

<p><strong>最近我对函数式编程非常感兴趣。这个概念让我着迷：应用数学来增强抽象性和强制纯粹性，以避免副作用，并实现代码的良好可复用性。同时，函数式编程非常复杂。</strong></p>

<p>函数式编程有一个非常陡峭的学习曲线，因为它来源于数学中的<a href="https://github.com/MostlyAdequate/mostly-adequate-guide/blob/master/ch5.md#category-theory">范畴论</a>。接触不久之后，就将遇到诸如组合（composition）、恒等（identity），函子（functor）、单子（monad），以及逆变（contravariant）等术语。我根本不太了解这些概念，可能这也是我从来没有在实践中运用函数式编程的原因。</p>

<p>我开始思考：在常规的命令式编程和完全的函数式编程之间是否可能会有一些中间形式？既允许在代码库引入函数式编程的一些很好的特性，同时暂时保留已有的旧代码。</p>

<p>对我而言，函数式编程最大的作用就是强制你编写声明性代码：代码描述你做什么，而不是在描述如何做。这样就可以轻松了解特定代码块的功能，而无需了解其真正的运行原理。事实证明，编写声明式代码是函数式编程中最简单的部分之一。</p>

<h2>循环</h2>

<blockquote><p>&hellip;一个循环就是一个命令式控制结构，难以重用，并且难以插入到其他操作中。此外，它还得不断变化代码来响应新的迭代需求。</p>

<p>&ndash; Luis Atencio</p></blockquote>

<p>所以，让我们先看一下循环，循环是命令式编程的一个很好的例子。循环涉及很多语法，都是描述它们的行为是如何工作，而不是它们在做什么。例如，看看这段代码：</p>

<pre><code class="javascript">function helloworld(arr) {
    for (let i = 1; i &lt; arr.length; i++) {
        arr[i] *= 2
        if (arr[i] % 2 === 0) {
            doSomething(arr[i])
        }
    }
}
</code></pre>

<p>这段代码在做什么呢？它将数组内除第一个数字 （<code>let i = 1</code>）的其他所有数字乘以 2，如果是偶数的话（<code>if (arr % 2 === 0)</code>），就进行某些操作。在此过程中，原始数组的值会被改变。但这通常是不必要的，因为数组可能还会在代码库中的其他地方用到，所以刚才所做的改变可能会导致意外的结果。</p>

<p>但最主要的原因是，这段代码看起来很难一目了然。它是命令式的，for 循环告诉我们如何遍历数组，在里面，使用一个 if 语句有条件地调用一个函数。</p>

<p>我们可以通过使用数组方法以声明式的方式重写这段代码。数组方法直接表达所做的事，比较常见的方法包括：<code>forEach</code>，<code>map</code>，<code>filter</code>，<code>reduce</code> 和 <code>slice</code>。</p>

<p>结果就像下面这样：</p>

<pre><code class="javascript">function helloworld(arr) {
    const evenNumbers = n =&gt; n % 2 === 0

    arr
        .slice(1)
        .map(v =&gt; v * 2)
        .filter(evenNumbers)
        .forEach(v =&gt; doSomething(v))    
}
</code></pre>

<p>在这个例子中，我们使用一种很好的，扁平的链式结构去描述我们在做什么，明确表明意图。此外，我们避免了改变原始数组，从而避免不必要的副作用，因为大多数数组方法会返回一个新数组。当箭头函数开始变得越来越复杂时，可以地将其提取到一个特定的函数中，比如 <code>evenNumbers</code>， 从而尽量保持结构简单易读。</p>

<p>在上面的例子，链式调用并没有返回值，而是以 forEach 结束。然而，我们可以轻松地剥离最后一部分，并返回结果，以便我们可以在其他地方处理它。如果还需要返回除数组以外的任何东西，可以使用 <code>reduce</code> 函数。</p>

<p>对于接下来的一个例子，假设我们有一组 JSON 数据，其中包含在一个虚构歌唱比赛中不同国家获得的积分：</p>

<pre><code class="json">[
    {
        "country": "NL",
        "points": 12
    },
    {
        "country": "BE",
        "points": 3
    },
    {
        "country": "NL",
        "points": 0
    },
    ...
]
</code></pre>

<p>我们想计算荷兰（NL）获得的总积分，根据印象中其强大的音乐能力，我们可以认为这是一个非常高的分数，但我们想要更精确地确认这一点。</p>

<p>使用循环可能会是这样：</p>

<pre><code class="javascript">function countVotes(votes) {
    let score = 0;

    for (let i = 0; i &lt; votes.length; i++) {
        if (votes[i].country === 'NL') {
            score += votes[i].points;
        }
    }

    return score;
}
</code></pre>

<p>使用数组方法重构，我们得到一个更干净的代码片段：</p>

<pre><code class="javascript">function countVotes(votes) {
    const sum = (a, b) =&gt; a + b;

    return votes
        .filter(vote =&gt; vote.country === 'NL')
        .map(vote =&gt; vote.points)
        .reduce(sum);
}
</code></pre>

<p>有时候 <code>reduce</code> 可能有点难以阅读，将 <code>reduce</code> 函数提取出来会在理解上有帮助。在上面的代码片段中，我们定义了一个 <code>sum</code> 函数来描述函数的作用，因此方法链仍然保持很好的可读性。</p>

<h2>if else 语句</h2>

<p>接下来，我们来聊聊大家都很喜欢的 if else 语句，if else 语句也是命令式代码里一个很好的例子。为了使我们的代码更具声明式，我们将使用三元表达式。</p>

<p>一个三元表达式是 if else 语句的替代语法。以下两个代码块具有相同的效果：</p>

<pre><code class="javascript">// Block 1
if (condition) {
    doThis();
} else {
    doThat();
}

// Block 2
const value = condition ? doThis() : doThat();
</code></pre>

<p>当在定义（或返回）一个常量时，三元表达式非常有用。使用 if else 语句会将该变量的使用范围限制在语句内，通过使用三元语句，我们可以避免这个问题：</p>

<pre><code class="javascript">if (condition) {
    const a = 'foo';
} else {
    const a = 'bar';
}

const b = condition ? 'foo' : 'bar';

console.log(a); // Uncaught ReferenceError: a is not defined
console.log(b); // 'bar'
</code></pre>

<p>现在，我们来看看如何应用这一点来重构一些更重要的代码：</p>

<pre><code class="javascript">const box = element.getBoundingClientRect();

if (box.top - document.body.scrollTop &gt; 0 &amp;&amp; box.bottom - document.body.scrollTop &lt; window.innerHeight) {
    reveal();
} else {
    hide();
}
</code></pre>

<p>那么，上面的代码发生了什么呢？if 语句检查元素当前是否在页面的可见部分内，这个信息在代码的任何地方都没有表达出来。基于此布尔值，再调用 <code>reveal()</code> 或者 <code>hide()</code> 函数。</p>

<p>将这个 if 语句转换成三元表达式迫使我们将条件移动到它自己的变量中。这样我们可以将三元表达式组合在一行上，现在通过变量的名称来传达布尔值表示的内容，这样还不错。</p>

<pre><code class="javascript">const box = element.getBoundingClientRect();
const isInViewport =
    box.top - document.body.scrollTop &gt; 0 &amp;&amp;
    box.bottom - document.body.scrollTop &lt; window.innerHeight;

isInViewport ? reveal() : hide();
</code></pre>

<p>通过这个例子，重构带来的好处可能看起来不大。接下来会有一个相比更复杂的例子：</p>

<pre><code class="javascript">elements
    .forEach(element =&gt; {
        const box = element.getBoundingClientRect();

        if (box.top - document.body.scrollTop &gt; 0 &amp;&amp; box.bottom - document.body.scrollTop &lt; window.innerHeight) {
            reveal();
        } else {
            hide();
        }

    });
</code></pre>

<p>这很不好，打破了我们优雅的扁平的调用链，从而使代码更难读。我们再次使用三元操作符，而在使用它的时候，使用 <code>isInViewport</code> 检查，并跟它自己的动态函数分开。</p>

<pre><code class="javascript">const isInViewport = element =&gt; {
    const box = element.getBoundingClientRect();
    const topInViewport = box.top - document.body.scrollTop &gt; 0;
    const bottomInViewport = box.bottom - document.body.scrollTop &lt; window.innerHeight;
    return topInViewport &amp;&amp; bottomInViewport;
};

elements
    .forEach(elem =&gt; isInViewport(elem) ? reveal() : hide());
</code></pre>

<p>此外，现在我们将 <code>isInViewport</code> 移动到一个独立函数，可以很容易地把它放在它自己的 helper 类/对象之内：</p>

<pre><code class="javascript">import { isInViewport } from 'helpers';

elements
    .forEach(elem =&gt; isInViewport(elem) ? reveal() : hide());
</code></pre>

<p>虽然上面的例子依赖于所处理的是数组，但是在不明确是在数组的情况下，也可以采用这种编码风格。</p>

<p>例如，看看下面的函数，它通过三条规则来验证密码的有效性。</p>

<pre><code class="javascript">import { passwordRegex as requiredChars } from 'regexes'
import { getJson } from 'helpers'

const validatePassword = async value =&gt; {
  if (value.length &lt; 6) return false
  if (!requiredChars.test(value)) return false

  const forbidden = await getJson('/forbidden-passwords')
  if (forbidden.includes(value)) return false

  return value
}

validatePassword(someValue).then(persist)
</code></pre>

<p>如果我们使用数组包装初始值，就可以使用在上面的例子中里面所用到的所有数组方法。此外，我们已经将验证函数打包成 <code>validationRules</code> 使其可重用。</p>

<pre><code class="javascript">import { minLength, matchesRegex, notBlacklisted } from 'validationRules'
import { passwordRegex as requiredChars } from 'regexes'
import { getJson } from 'helpers'

const validatePassword = async value =&gt; {
  const result = Array.from(value)
    .filter(minLength(6))
    .filter(matchesRegex(requiredChars))
    .filter(await notBlacklisted('/forbidden-passwords'))
    .shift()

  if (result) return result
  throw new Error('something went wrong...')
}

validatePassword(someValue).then(persist)
</code></pre>

<p>目前在 JavaScript 中有一个 <a href="https://github.com/tc39/proposal-pipeline-operator">管道操作符</a> 的提案。使用这个操作符，就不用再把原始值换成数组了。可以直接在前面的值调用管道操作符之后的函数，有点像 <code>Array</code> 的 <code>map</code> 功能。修改之后的代码大概就像这样：</p>

<pre><code class="javascript">import { minLength, matchesRegex, notBlacklisted } from 'validationRules'
import { passwordRegex as requiredChars } from 'regexes'
import { getJson } from 'helpers'

const validatePassword = async value =&gt;
  value
    |&gt; minLength(6)
    |&gt; matchesRegex(requiredChars)
    |&gt; await notBlacklisted('/forbidden-passwords')

try { someValue |&gt; await validatePassword |&gt; persist }
catch(e) {
  // handle specific error, thrown in validation rule
}
</code></pre>

<p>但需要注意的是，这仍然是一个非常早期的提案，不过可以稍微期待一下。</p>

<h2>事件</h2>

<p>最后，我们来看看事件处理。一直以来，事件处理很难以扁平化的方式编写代码。可以 <code>Promise</code> 化来保持一种链式的，扁平化的编程风格，但 <code>Promise</code> 只能 <code>resolve</code> 一次，而事件绝对会多次触发。</p>

<p>在下面的示例中，我们创建一个类，它对用户的每个输入值进行检索，结果是一个自动补全的数组。首先检查字符串是否长于给定的阈值长度。如果满足条件，将从服务器检索自动补全的结果，并将其渲染成一系列标签。</p>

<p>注意代码的不“纯”，频繁地使用 <code>this</code> 关键字。几乎每个函数都在访问 <code>this</code> 这个关键字：</p>

<blockquote><p>译注：作者在这里使用 &ldquo;this keyword&#8221;，有一种双关的意味</p></blockquote>

<pre><code class="javascript">import { apiCall } from 'helpers'

class AutoComplete {

  constructor (options) {

    this._endpoint = options.endpoint
    this._threshold = options.threshold
    this._inputElement = options.inputElement
    this._containerElement = options.list

    this._inputElement.addEventListener('input', () =&gt;
      this._onInput())

  }

  _onInput () {

    const value = this._inputElement.value

    if (value &gt; this._options.threshold) {
      this._updateList(value)
    }

  }

  _updateList (value) {

    apiCall(this._endpoint, { value })
      .then(items =&gt; this._render(items))
      .then(html =&gt; this._containerElement = html)

  }

  _render (items) {

    let html = ''

    items.forEach(item =&gt; {
      html += `&lt;a href="${ item.href }"&gt;${ item.label }&lt;/a&gt;`
    })

    return html

  }

}
</code></pre>

<p>通过使用 <code>Observable</code>，我们将用一种更好的方式对这段代码进行重写。可以简单将 <code>Observable</code> 理解成一个能够多次 <code>resolve</code> 的 <code>Promise</code>。</p>

<blockquote><p>Observable 类型可用于基于推送模型的数据源，如 DOM 事件，定时器和套接字</p></blockquote>

<p><code>Observable</code> 提案目前处于 Stage-1。在下面 <code>listen</code> 函数的实现是从 GitHub 上的<a href="https://github.com/tc39/proposal-observable">提案</a>中直接复制的，主要是将事件监听器转换成 <code>Observable</code>。可以看到，我们可以将整个 <code>AutoComplete</code> 类重写为单个方法的函数链。</p>

<pre><code class="javascript">import { apiCall, listen } from 'helpers';
import { renderItems } from 'templates';

function AutoComplete ({ endpoint, threshold, input, container }) {

  listen(input, 'input')
    .map(e =&gt; e.target.value)
    .filter(value =&gt; value.length &gt;= threshold)
    .forEach(value =&gt; apiCall(endpoint, { value }))
    .then(items =&gt; renderItems(items))
    .then(html =&gt; container.innerHTML = html)

}
</code></pre>

<p>由于大多数 <code>Observable</code> 库的实现过于庞大，我很期待 ES 原生的实现。<code>map</code>，<code>filter</code> 和 <code>forEach</code>方法还不是规范的一部分，但是在 <a href="https://github.com/zenparsing/zen-observable">zen-observable</a> 已经在扩展 API 实现，而 zen-observable 本身是 ES Observables 的一种实现 。</p>

<p>&ndash;</p>

<p>我希望你会对这些“扁平化”模式感兴趣。就个人而言，我很喜欢以这种方式重写我的程序。你接触到的每一段代码都可以更易读。使用这种技术获得的经验越多，就越来越能认识到这一点。记住这个简单的法则：</p>

<p><strong>The flatter the better!</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ES6 Promise：模式与反模式]]></title>
    <link href="http://blog.mirreal.net/blog/2017/09/29/es6-promises-patterns-and-anti-patterns/"/>
    <updated>2017-09-29T16:50:11+08:00</updated>
    <id>http://blog.mirreal.net/blog/2017/09/29/es6-promises-patterns-and-anti-patterns</id>
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="https://medium.com/datafire-io/es6-promises-patterns-and-anti-patterns-bbb21a5d0918">ES6 Promises: Patterns and Anti-Patterns</a>
作者：Bobby Brennan</p></blockquote>

<p>当几年前，第一次使用 NodeJS 的时候，对现在被称为“ <a href="http://callbackhell.com/">回调地狱</a> ”的写法感到很困扰。幸运的是，现在是 2017 年了，NodeJS 已经采用大量 JavaScript 的最新特性，从 <a href="http://node.green/">v4</a> 开始已经支持 Promise。</p>

<p>尽管 Promise 可以让代码更加简洁易读，但对于只熟悉回调函数的人来说，可能对此还是会有所怀疑。在这里，将列出我在使用Promise 时学到的一些基本模式，以及踩的一些坑。</p>

<p><em>注意：<strong>在本文中</strong>将使用<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">箭头函数</a> ，如果你还不是很熟悉，其实很简单，建议<a href="http://exploringjs.com/es6/ch_arrow-functions.html">先读一下使用它们的好处</a></em></p>

<h2>模式与最佳实践</h2>

<h4>使用 Promise</h4>

<p>如果使用的是已经支持 Promise 的第三方库，那么使用起来非常简单。只需关心两个函数：<code>then()</code> 和 <code>catch()</code>。例如，有一个客户端 API 包含三个方法，<code>getItem()</code>，<code>updateItem()</code>，和<code>deleteItem()</code>，每一个方法都返回一个 Promise：</p>

<pre><code class="javascript">Promise.resolve()
  .then(_ =&gt; {
    return api.getItem(1)
  })
  .then(item =&gt; {
    item.amount++
    return api.updateItem(1, item);
  })
  .then(update =&gt; {
    return api.deleteItem(1);
  })
  .catch(e =&gt; {
    console.log('error while working on item 1');
  })
</code></pre>

<p>每次调用 <code>then()</code> 会在 Promise 链中创建一个新的步骤，如果链中的任何一个地方出现错误，就会触发接下来的 <code>catch()</code> 。<code>then()</code> 和 <code>catch()</code> 都可以返回一个值或者一个新的 Promise，结果将被传递到 Promise 链的下一个<code>then()</code>。</p>

<p>为了比较，这里使用回调函数来实现相同逻辑：</p>

<pre><code class="javascript">api.getItem(1, (err, data) =&gt; {
  if (err) throw err;
  item.amount++;
  api.updateItem(1, item, (err, update) =&gt; {
    if (err) throw err;
    api.deleteItem(1, (err) =&gt; {
      if (err) throw err;
    })
  })
})
</code></pre>

<p>要注意的第一个区别是，使用回调函数，我们必须在过程的<strong>每个</strong>步骤中进行错误处理，而不是用单个的 catch-all 来处理。回调函数的第二个问题更直观，每个步骤都要水平缩进，而使用 Promise 的代码则有显而易见的顺序关系。</p>

<h4>回调函数 Promise 化</h4>

<p>需要学习的第一个技巧是如何将回调函数转换为 Promise。你可能正在使用仍然基于回调的库，或是自己的旧代码，不过不用担心，因为只需要几行代码就可以将其包装成一个 Promise。这是将 Node 中的一个回调方法 <code>fs.readFile</code> 转换为 Promise的示例：</p>

<pre><code class="javascript">function readFilePromise(filename) {
  return new Promise((resolve, reject) =&gt; {
    fs.readFile(filename, 'utf8', (err, data) =&gt; {
      if (err) reject(err);
      else resolve(data);
    })
  })
}

readFilePromise('index.html')
  .then(data =&gt; console.log(data))
  .catch(e =&gt; console.log(e))
</code></pre>

<p>关键部分是 Promise 构造函数，它接收一个函数作为参数，这个函数有两个函数参数：<code>resolve</code> 和 <code>reject</code>。在这个函数里完成所有工作，完成之后，在成功时调用 <code>resolve</code>，如果有错误则调用 <code>reject</code>。</p>

<p>需要注意的是只有<strong>一个</strong><code>resolve</code> 或者 <code>reject</code> 被调用，即应该只被调用一次。在我们的示例中，如果 <code>fs.readFile</code> 返回错误，我们将错误传递给 <code>reject</code>，否则将文件数据传递给<code>resolve</code>。</p>

<h4>Promise 的值</h4>

<p>ES6 有两个很方便的辅助函数，用于通过普通值创建 Promise：<code>Promise.resolve()</code> 和 <code>Promise.reject()</code>。例如，可能需要在同步处理某些情况时一个返回 Promise 的函数：</p>

<pre><code class="javascript">function readFilePromise(filename) {
  if (!filename) {
    return Promise.reject(new Error("Filename not specified"));
  }
  if (filename === 'index.html') {
    return Promise.resolve('&lt;h1&gt;Hello!&lt;/h1&gt;');
  }
  return new Promise((resolve, reject) =&gt; {/*...*/})
}
</code></pre>

<p>注意，虽然可以传递任何东西（或者不传递任何值）给 <code>Promise.reject()</code>，但是好的做法是传递一个<code>Error</code>。</p>

<h4>并行运行</h4>

<p><code>Promise.all</code>是一个并行运行 Promise 数组的方法，也就是说是同时运行。例如，我们有一个要从磁盘读取文件的列表。使用上面创建的 <code>readFilePromise</code> 函数，将如下所示：</p>

<pre><code class="javascript">let filenames = ['index.html', 'blog.html', 'terms.html'];

Promise.all(filenames.map(readFilePromise))
  .then(files =&gt; {
    console.log('index:', files[0]);
    console.log('blog:', files[1]);
    console.log('terms:', files[2]);
  })
</code></pre>

<p>我甚至不会使用传统的回调函数来尝试编写与之等效的代码，那样会很凌乱，而且也容易出错。</p>

<h4>串行运行</h4>

<p>有时同时运行一堆 Promise 可能会出现问题。比如，如果尝试使用 <code>Promise.all</code> 的 API ​​去检索一堆资源，则可能会在达到速率限制时开始响应<a href="https://httpstatuses.com/429">429错误</a>。</p>

<p>一种解决方案是串行运行 Promise，或一个接一个地运行。但是在 ES6 中没有提供类似 <code>Promise.all</code> 这样的方法（为什么？），但我们可以使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce?v=b"><code>Array.reduce</code></a> 来实现：</p>

<pre><code class="javascript">let itemIDs = [1, 2, 3, 4, 5];

itemIDs.reduce((promise, itemID) =&gt; {
  return promise.then(_ =&gt; api.deleteItem(itemID));
}, Promise.resolve());
</code></pre>

<p>在这种情况下，我们需要等待每次调用 <code>api.deleteItem()</code> 完成之后才能进行下一次调用。这种方法，比为每个 itemID 写 <code>.then()</code> 更简洁更通用：</p>

<pre><code class="javascript">Promise.resolve()
  .then(_ =&gt; api.deleteItem(1))
  .then(_ =&gt; api.deleteItem(2))
  .then(_ =&gt; api.deleteItem(3))
  .then(_ =&gt; api.deleteItem(4))
  .then(_ =&gt; api.deleteItem(5));
</code></pre>

<h4>Race</h4>

<p>ES6 提供的另一个很方便的函数是 <code>Promise.race</code>。跟 <code>Promise.all</code> 一样，接收一个 Promise 数组，并同时运行它们，但不同的是，会在一旦<strong>任何</strong> Promise 完成或失败的情况下返回，并放弃所有其他的结果。</p>

<p>例如，我们可以创建一个在几秒钟之后超时的 Promise：</p>

<pre><code class="javascript">function timeout(ms) {
  return new Promise((resolve, reject) =&gt; {
    setTimeout(reject, ms);
  })
}

Promise.race([readFilePromise('index.html'), timeout(1000)])
  .then(data =&gt; console.log(data))
  .catch(e =&gt; console.log("Timed out after 1 second"))
</code></pre>

<p>需要注意的是，其他 Promise 仍将继续运行 ，只是看不到结果而已。</p>

<h4>捕获错误</h4>

<p>捕获错误最常见的方式是添加一个  <code>.catch()</code> 代码块，这将捕获前面所有 <code>.then()</code> 代码块中的错误  ：</p>

<pre><code class="javascript">Promise.resolve()
  .then(_ =&gt; api.getItem(1))
  .then(item =&gt; {
    item.amount++;
    return api.updateItem(1, item);
  })
  .catch(e =&gt; {
    console.log('failed to get or update item');
  })
</code></pre>

<p>在这里，只要有 <code>getItem</code> 或者 <code>updateItem</code> 失败，<code>catch()</code>就会被触发。但是如果我们想分开处理 <code>getItem</code> 的错误怎么办？只需再插入一个<code>catch()</code> 就可以，它也可以返回另一个 Promise。</p>

<pre><code class="javascript">Promise.resolve()
  .then(_ =&gt; api.getItem(1))
  .catch(e =&gt; api.createItem(1, {amount: 0}))
  .then(item =&gt; {
    item.amount++;
    return api.updateItem(1, item);
  })
  .catch(e =&gt; {
    console.log('failed to update item');
  })
</code></pre>

<p>现在，如果<code>getItem()</code>失败，我们通过第一个 <code>catch</code> 介入并创建一条新的记录。</p>

<h4>抛出错误</h4>

<p>应该将 <code>then()</code> 语句中的所有代码视为 <code>try</code> 块内的所有代码。<code>return Promise.reject()</code> 和 <code>throw new Error()</code> 都会导致下一个 <code>catch()</code> 代码块的运行。</p>

<p>这意味着运行时错误也会触发 <code>catch()</code>，所以不要去假设错误的来源。例如，在下面的代码中，我们可能希望该 <code>catch()</code> 只能获得 <code>getItem</code> 抛出的错误，但是如示例所示，它还会在我们的 <code>then()</code> 语句中捕获运行时错误。</p>

<pre><code class="javascript">api.getItem(1)
  .then(item =&gt; {
    delete item.owner;
    console.log(item.owner.name);
  })
  .catch(e =&gt; {
    console.log(e); // Cannot read property 'name' of undefined
  })
</code></pre>

<h4>动态链</h4>

<p>有时，我们想要动态地构建 Promise 链，例如，在满足特定条件时，插入一个额外的步骤。在下面的示例中，在读取给定文件之前，我们可以选择创建一个锁定文件：</p>

<pre><code class="javascript">function readFileAndMaybeLock(filename, createLockFile) {
  let promise = Promise.resolve();

  if (createLockFile) {
    promise = promise.then(_ =&gt; writeFilePromise(filename + '.lock', ''))
  }

  return promise.then(_ =&gt; readFilePromise(filename));
}
</code></pre>

<p>一定要通过重写 <code>promise = promise.then(/*...*/)</code> 来更新 <code>Promise</code> 的值。参看接下来反模式中会提到的 <strong>多次调用 then()</strong>。</p>

<h2>反模式</h2>

<p>Promise 是一个整洁的抽象，但很容易陷入某些陷阱。以下是我遇到的一些最常见的问题。</p>

<h4>重回回调地狱</h4>

<p>当我第一次从回调函数转到 Promise 时，发现很难摆脱一些旧习惯，仍像使用回调函数一样嵌套 Promise：</p>

<pre><code class="javascript">api.getItem(1)
  .then(item =&gt; {
    item.amount++;
    api.updateItem(1, item)
      .then(update =&gt; {
        api.deleteItem(1)
          .then(deletion =&gt; {
            console.log('done!');
          })
      })
  })
</code></pre>

<p>这种嵌套是完全没有必要的。有时一两层嵌套可以帮助组合相关任务，但是最好总是使用 <code>.then()</code> 重写成 Promise 垂直链  。</p>

<h4>没有返回</h4>

<p>我遇到的一个经常会犯的错误是在一个 Promise 链中忘记 <code>return</code> 语句。你能发现下面的 bug 吗？</p>

<pre><code class="javascript">api.getItem(1)
  .then(item =&gt; {
    item.amount++;
    api.updateItem(1, item);
  })
  .then(update =&gt; {
    return api.deleteItem(1);
  })
  .then(deletion =&gt; {
    console.log('done!');
  })
</code></pre>

<p>因为我们没有在第4行的 <code>api.updateItem()</code> 前面写 <code>return</code>，所以 <code>then()</code> 代码块会立即 resolove，导致 <code>api.deleteItem()</code> 可能在<code>api.updateItem()</code> 完成之前就被调用。</p>

<p>在我看来，这是 ES6 Promise 的一个大问题，往往会引发意想不到的行为。问题是，  <code>.then()</code> 可以返回一个值，也可以返回一个新的 Promise，<code>undefined</code> 完全是一个有效的返回值。就个人而言，如果我负责 Promise API，我会在 <code>.then()</code> 返回   <code>undefined</code> 时抛出运行时错误，但现在我们需要特别注意 <code>return</code> 创建的 Promise。</p>

<h4>多次调用 <code>.then()</code></h4>

<p>根据规范，在同一个 Promise 上多次调用 <code>then()</code> 是完全有效的，并且回调将按照其注册顺序被调用。但是，我并未见过需要这样做的场景，并且在使用返回值和错误处理时可能会产生一些意外行为：</p>

<pre><code class="javascript">let p = Promise.resolve('a');
p.then(_ =&gt; 'b');
p.then(result =&gt; {
  console.log(result) // 'a'
})

let q = Promise.resolve('a');
q = q.then(_ =&gt; 'b');
q = q.then(result =&gt; {
  console.log(result) // 'b'
})
</code></pre>

<p>在这个例子中，因为我们在每次调用 <code>then()</code> 不更新 <code>p</code> 的值，所以我们看不到 <code>'b'</code> 返回。但是每次调用 <code>then()</code> 时更新 <code>q</code>，所以其行为更可预测。</p>

<p>这也适用于错误处理：</p>

<pre><code class="javascript">let p = Promise.resolve();
p.then(_ =&gt; {throw new Error("whoops!")})
p.then(_ =&gt; {
  console.log('hello!'); // 'hello!'
})

let q = Promise.resolve();
q = q.then(_ =&gt; {throw new Error("whoops!")})
q = q.then(_ =&gt; {
  console.log('hello'); // We never reach here
})
</code></pre>

<p>在这里，我们期望的是抛出一个错误来打破 Promise 链，但由于没有更新 <code>p</code> 的值，所以第二个 <code>then()</code> 仍会被调用。</p>

<p>有可能在一个 Promise 上多次调用 <code>.then()</code> 有很多理由  ，因为它允许将 Promise 分配到几个新的独立的 Promise 中，但是还没发现真实的使用场景。</p>

<h4>混合使用回调和 Promise</h4>

<p>很容易进入一种陷阱，在使用基于 Promise 库的同时，仍在基于回调的项目中工作。始终避免在 <code>then()</code> 或 <code>catch()</code> 使用回调函数 ，否则 Promise 会吞噬任何后续的错误，将其作为 Promise 链的一部分。例如，以下内容看起来是一个挺合理的方式，使用回调函数来包装一个 Promise：</p>

<pre><code class="javascript">function getThing(callback) {
  api.getItem(1)
    .then(item =&gt; callback(null, item))
    .catch(e =&gt; callback(e));
}

getThing(function(err, thing) {
  if (err) throw err;
  console.log(thing);
})
</code></pre>

<p>这里的问题是，如果有错误，我们会收到关于“Unhandled promise rejection”的警告，即使我们添加了一个 <code>catch()</code> 代码块。这是因为，<code>callback()</code> 在 <code>then()</code> 和 <code>catch()</code> 都会被调用，使之成为 Promise 链的一部分。</p>

<p>如果必须使用回调来包装 Promise，可以使用  <code>setTimeout</code> （或者是 NodeJS 中的 <code>process.nextTick</code>）来打破 Promise：</p>

<pre><code class="javascript">function getThing(callback) {
  api.getItem(1)
    .then(item =&gt; setTimeout(_ =&gt; callback(null, item)))
    .catch(e =&gt; setTimeout(_ =&gt; callback(e)));
}

getThing(function(err, thing) {
  if (err) throw err;
  console.log(thing);
})
</code></pre>

<h4>不捕获错误</h4>

<p>JavaScript 中的错误处理有点奇怪。虽然支持熟悉的 <code>try/catch</code> 范例，但是没有办法强制调用者以 Java 的方式处理错误。然而，使用回调函数，使用所谓的“errbacks”，即第一个参数是一个错误回调变得很常见。这迫使调用者至少承认错误的可能性。例如，<code>fs</code> 库：</p>

<pre><code class="javascript">fs.readFile('index.html', 'utf8', (err, data) =&gt; {
  if (err) throw err;
  console.log(data);
})
</code></pre>

<p>使用 Promise，又将很容易忘记需要进行错误处理，特别是对于敏感操作（如文件系统和数据库访问）。目前，如果没有捕获到 reject 的 Promise，将在 NodeJS 中看到非常丑的警告：</p>

<pre><code class="text">(node:29916) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1): Error: whoops!
(node:29916) DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.
</code></pre>

<p>确保在主要的事件循环中任何 Promise 链的末尾添加 <code>catch()</code> 以避免这种情况。</p>

<h2>总结</h2>

<p>希望这是一篇有用的关于常见 Promise 模式和反模式的概述。如果你想了解更多，这里有一些有用的资源：</p>

<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Mozilla 的 ES6 Promise 文档</a></li>
<li><a href="https://developers.google.com/web/fundamentals/getting-started/primers/promises">来自 Google 的 Promise 介绍</a></li>
<li><a href="http://www.datchley.name/es6-promises/">Dave Atchley 的 ES6 Promise 概述</a></li>
</ul>


<p>更多的 Promise <a href="http://www.datchley.name/promise-patterns-anti-patterns/">模式</a>和<a href="https://hackernoon.com/javascript-promises-best-practices-anti-patterns-b32309f65551">反模式</a></p>

<p><a href="https://medium.com/datafire-io">或者阅读来自 DataFire 团队的内容</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在 Node.js 中使用原生 ES 模块]]></title>
    <link href="http://blog.mirreal.net/blog/2017/09/13/using-es-modules-natively-in-node-dot-js/"/>
    <updated>2017-09-13T16:19:59+08:00</updated>
    <id>http://blog.mirreal.net/blog/2017/09/13/using-es-modules-natively-in-node-dot-js</id>
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="http://2ality.com/2017/09/native-esm-node.html">Using ES modules natively in Node.js</a></p>

<p>作者：<a href="https://twitter.com/rauschma">Axel Rauschmayer</a></p></blockquote>

<p>从版本 8.5.0 开始，Node.js 开始支持原生 ES 模块，可以通过命令行选项打开该功能。新功能很大程度上得归功于 <a href="https://twitter.com/bradleymeck">Bradley Farias</a>。</p>

<h2>1.演示</h2>

<p>这个示例的代码目录结构如下：</p>

<pre><code>esm-demo/
    lib.mjs
    main.mjs
</code></pre>

<p>lib.mjs：</p>

<pre><code class="javascript">export function add(x, y) {
    return x + y;
}
</code></pre>

<p>main.mjs：</p>

<pre><code class="javascript">import {add} from './lib.mjs';

console.log('Result: '+add(2, 3));
</code></pre>

<p>运行演示：</p>

<pre><code class="sh">$ node --experimental-modules main.mjs
Result: 5
</code></pre>

<h2>2.清单：需要注意的事情</h2>

<h3>ES 模块：</h3>

<ul>
<li><p>不能动态导入模块。但是 <a href="http://2ality.com/2017/01/import-operator.html">动态 import()</a> 的相关工作正在进行中，应该很快就能提供支持。</p></li>
<li><p>没有元变量，如 <code>__dirname</code> 和 <code>__filename</code>。但是，有一个的类似功能的提案：“<a href="https://github.com/tc39/proposal-import-meta">import.meta</a>”。看起来可能是这样：</p></li>
</ul>


<pre><code class="javascript">console.log(import.meta.url);
</code></pre>

<ul>
<li>现在所有模块标识符都是 URL（这部分在 Node.js 是新增的）：

<ul>
<li>文件 - 带文件扩展名的相对路径： <code>../util/tools.mjs</code></li>
<li>库 - 没有文件扩展名，也没有路径 <code>lodash</code></li>
<li>如何更好地使 npm 库在浏览器中也可用（不使用 bundler）仍有待观察。一种可能性是引入 RequireJS 风格的配置数据，将路径映射到实际路径。目前，在浏览器中使用 bare path 的模块标识符是非法的。</li>
</ul>
</li>
</ul>


<h3>与 CJS 模块的互操作性</h3>

<ul>
<li>你可以导入 CJS 模块，但它们总是只有默认的导出 - 即 <code>module.exports</code> 的值。让 CJS 模块支持命名导出已经在做了，但可能需要一段时间。如果你能帮忙，<a href="https://twitter.com/bradleymeck/status/906210545145184257">可以来做</a>。</li>
</ul>


<pre><code class="javascript">import fs1 from 'fs';
console.log(Object.keys(fs1).length); // 86

import * as fs2 from 'fs';
console.log(Object.keys(fs2)); // ['default']
</code></pre>

<ul>
<li>不能在 ES 模块中使用 require()。主要原因是：

<ul>
<li>路径解析工作稍有不同：ESM 不支持 <code>NODE_PATH</code> 和 <code>require.extensions</code>。而且，它的标识符始终是 URL 也会导致一些细微差异。</li>
<li>ES 模块始终以异步方式加载，这确保了与 Web 的最大兼容性。这种加载风格并不能通过 require() 混合使用同步加载 CJS 模块。</li>
<li>禁止同步模块加载也可以为 Top-level await 导入 ES 模块保留后路（一个当前正在考虑的功能）。</li>
</ul>
</li>
</ul>


<h2>3.早期版本的 Node.js 上的 ES 模块</h2>

<p>如果要在 8.5.0 之前的 Node.js 版本上使用 ES 模块，请参阅 John-David Dalton 的 <a href="https://github.com/standard-things/esm">@std/esm</a>。</p>

<p>提示：如果不启用任何可解锁的额外功能，将在 Node.js 保持 100％ 兼容原生 ES 模块.</p>

<h2>FAQ</h2>

<h3>什么时候可以不带命令行选项使用ES 模块？</h3>

<p>目前的计划是在 Node.js 10 LTS 中默认可使用 ES 模块。</p>

<h2>进一步阅读  </h2>

<p>有关 Node.js 和浏览器中 ES 模块的更多信息：</p>

<ul>
<li>“<a href="http://2ality.com/2017/01/babel-esm-spec-mode.html">Making transpiled ES modules more spec-compliant</a>” [using ES modules natively vs. transpiling them via Babel]</li>
<li>“<a href="http://2ality.com/2017/05/es-module-specifiers.html">Module specifiers: what’s new with ES modules?</a>” [Why <code>.mjs</code>? How are module specifiers resolved? Etc.]</li>
<li>“<a href="http://exploringjs.com/es6/ch_modules.html">Modules</a>” [in-depth chapter on ES modules in “Exploring ES6”]</li>
</ul>


<p>即将到来的 ECMAScript 提案：</p>

<ul>
<li>博客: “<a href="http://2ality.com/2017/01/import-operator.html">ES proposal: <code>import()</code> – dynamically importing ES modules</a>”</li>
<li>提案: “<a href="https://github.com/tc39/proposal-import-meta"><code>import.meta</code></a>”</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在工作中学习]]></title>
    <link href="http://blog.mirreal.net/blog/2017/09/02/learning-at-work/"/>
    <updated>2017-09-02T21:49:52+08:00</updated>
    <id>http://blog.mirreal.net/blog/2017/09/02/learning-at-work</id>
    <content type="html"><![CDATA[<blockquote><p>原文；<a href="https://jvns.ca/blog/2017/08/06/learning-at-work/">Learning at work</a></p>

<p>作者：Julia Evans</p>

<p>谈点：学习是一件没有尽头的事，虽然在工作中很多时候被淹没在没玩没了的需求里面，加班是常态，或许很多人不知不觉放弃学习的心思。这篇文章中提到的一些方法我很赞同，很多点也是我的做事方式，这里也希望所有人都能找到适合自己的学习方式。</p></blockquote>

<p>在 Twitter 上我提了一个问题，“你是如何花时间用于自身学习”（<a href="https://twitter.com/b0rk/status/887111177062555648">这个推文</a>)，这些回答有一些相同之处：</p>

<ul>
<li>阅读博客文章</li>
<li>去参加业界大会</li>
<li>读书</li>
<li>在洗碗时看一些演讲</li>
<li>在一些不那么重要的项目里运用你想要学习的技术</li>
</ul>


<p>这些方法都挺管用的。为了个人职业发展，在工作之外花时间学习新技能是非常普遍的事，在这方面我也有不少经验。</p>

<p>另一方面，我知道有一些很厉害的程序员在工作之外完全不写代码。于是我开始思考，如果你想变得更牛，但又不想工作之外花太多额外时间要怎么办？</p>

<p>这些是我以及在 Twitter 上的朋友提到的一些观点，并且都是能在工作时候做的事情。</p>

<h2>不要学习工作之外的编程语言/框架</h2>

<p>这一点听起来有些消极，但确实还是很有用的。对于学习编程语言，我的观点是：</p>

<ul>
<li>我很熟悉几种编程语言（python，scala，ruby）</li>
<li>学习新的编程语言需要相当长的时间</li>
<li>我不想把空闲时间花在上面</li>
</ul>


<p>最近我在做一些 Go 方面的工作，还挺有趣的，我也喜欢做这件事。但是又觉得在上面花费太多个人时间，所以显得不是那么有趣了。通过编写代码学习编程，阅读别人的代码掌握一些模式，然后自己审查代码，然而这些都不是必须的，因为完全可以在工作中去做这些事情。</p>

<h2>选择一些可以从中学习的项目</h2>

<p>这些是我在过去三年学到的一些东西：</p>

<ul>
<li>Scala/Ruby/Go</li>
<li>hadoop/mapreduce/scalding</li>
<li>如何使用 Java 并发库，以及如何配置一个 Java 程序</li>
<li>关于各种 AWS 服务的工作原理</li>
<li>很多机器学习的东西</li>
<li>网络/ CDN / TLS 如何工作</li>
<li>docker/容器/rkt/kubernetes</li>
<li>服务发现 / DNS / jenkins</li>
</ul>


<p>一个关于如何选择项目的例子：如果在工作使用一个不能很好并行的程序，这时候问题就来了。我可以选择去问写这个程序的人为什么不使用并行编程，但是如果我也很想学习一下并行编程的话，就可以自己去完成这件事。所以后来我就 <a href="https://jvns.ca/blog/2016/03/29/thread-pools-part-ii-i-love-blocking/">学到了如何在 Java 中使用线程池</a>。</p>

<p>我只为此工作了几天，但却因此学到了新东西。</p>

<p>现在我正在从事 Kubernetes 相关的工作，当时选择它并不是因为可以在这里面学到很多东西。但是我确实学到很多有关分布式系统的东西，还在工作中使用 Go 语言，我觉得这很很棒。</p>

<p>当人们说像“嘿，我们使用 X 技术，需要有相关经验的人才能在这里工作”时，这其实相当愚蠢。现在我在网络/ puppet / kubernetes / docker / AWS 上花了很多时间，在这项工作之前没有任何相关工作经验。</p>

<h2>观察那些高级人员是如何做事的</h2>

<p>我会观察那些我敬佩的人在工作中的做事方式，然后尝试模仿他们或者是向他们寻求建议。例如，当 <a href="http://onemogin.com/">Cory</a> 加入时，我注意到，在引进新技术的时候，他会这样做：</p>

<ul>
<li>找到另一个有类似问题需要解决的团队</li>
<li>与他们合作，确保技术真正解决问题</li>
</ul>


<p>现在我正在开展一个新项目，一直在考虑这些工作可以帮到谁以及如何帮助，这样做就会感觉好很多。</p>

<h2>阅读每个 pull request</h2>

<p>在这个主题下引用两个我很喜欢的观点：</p>

<blockquote><p>我在一个小团队，所以会阅读所有的 pull request，直到完全了解问题和解决方案</p></blockquote>

<p>和</p>

<blockquote><p>我也是一样！我跟踪检查，看看人们如何解决各种问题</p></blockquote>

<p>事实上，我并没有阅读团队中的每一个 pull request。但是那确实很有用，通过跟踪别人在这方面做的工作来学习这个领域的东西。</p>

<p>但我并不是能完全做到。我曾经从事机器学习方面的工作，发现理论也很有趣，就想跟踪人们在这方面的情况，但对我来说有太多要注意的东西。我只能尽量注意那些比较接近我的东西，像是其中网络团队的一些工作。</p>

<h2>阅读源代码</h2>

<blockquote><p>阅读我用到的源代码对我而言是一个大块头。了解它在内部在做什么，主要是为什么可以通过某种方式工作。</p></blockquote>

<p>这是很重要的一点，也非常重要。很多库、框架、工具并没有很好的文档，在没有阅读源代码的情况下根本无法了解其工作原理。</p>

<h2>跟进你无法解决的 bug</h2>

<p>有时我会遇到一些自己没办法解决的 bug。后来，可能别人会找到解决方法，在这时候，就值得花时间去搞清楚具体的解决方法是什么，以及他们如何想出来的。</p>

<p>例如，最近有一个我没有调试出来的网络问题，刚好有人在上周搞清楚这个问题。现在想一想，大概明白造成这个 bug 的原因，但是我并不清楚他们用什么工具来获取调试所需的信息。当我重新开始工作时，必须确保我真的搞清楚这个问题，这样下次就可以做得更好。</p>

<p>Jessica Kerr 评论道</p>

<blockquote><p>每当我在故障排除时，除了解决这个问题，还会更深入或更广泛地延伸开去。</p></blockquote>

<p>我也喜欢这个回复：</p>

<blockquote><p>有时候，想解决一个与工作有关的问题，但并没有真的在实际工作中发生，只是看看我能不能在某方面有所突破。</p></blockquote>

<h2>运用好通勤时间</h2>

<p>对我而言，其实并没有通勤时间。但很多人提到他们会利用通勤时间来听播客/阅读报纸/阅读有趣的文章。这似乎是一个很不错的方式，来做一些你感兴趣的事情。</p>

<h2>花时间在工作中学习</h2>

<p>Twitter上有人说“我希望每天可以花 1 小时来学习”。我的观点是，我的工作就是要在工作日中抽出时间来学习东西。像现在我正在工作中使用 Kubernetes，这是一个很复杂的系统需要很长时间才能理解，我得花时间了解它是如何工作的。例如，在开始的时候，没什么目的地在做集群测试，只是想了解容器的网络如何工作的，同时也在项目上取得进展。</p>

<p>这可能对我来说挺容易的，因为我的工作跟别人隔得很远，没有人真的知道我具体在做什么，他们只是关心在大方面做的是什么。</p>

<p>实际上，如果要是提前多花点时间阅读，可能效果会更好。就像我刚刚在阅读 Kelsey Hightower 的“learn kubernetes the hard way”的文档，读完不需花太长时间，而且其中有一个关于如何设置一个集群的很好的点，这样就可以很节省我很多时间。</p>

<p>关于这个点，有些人还要想得更远。比如，我的朋友 Dan 就提到好几次，说他喜欢在工作中阅读技术书籍。最初觉得这是一件令人惊讶的事情，但它确实很有用。事实上，有很多跟我工作相关的书籍，找不到理由为什么不能在工作中阅读它们。</p>
]]></content>
  </entry>
  
</feed>
