<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Translator | Mirreal Note]]></title>
  <link href="http://blog.mirreal.net/blog/categories/translator/atom.xml" rel="self"/>
  <link href="http://blog.mirreal.net/"/>
  <updated>2017-09-18T22:03:04+08:00</updated>
  <id>http://blog.mirreal.net/</id>
  <author>
    <name><![CDATA[Mirreal Ellison]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[在 Node.js 中使用原生 ES 模块]]></title>
    <link href="http://blog.mirreal.net/blog/2017/09/13/using-es-modules-natively-in-node-dot-js/"/>
    <updated>2017-09-13T16:19:59+08:00</updated>
    <id>http://blog.mirreal.net/blog/2017/09/13/using-es-modules-natively-in-node-dot-js</id>
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="http://2ality.com/2017/09/native-esm-node.html">Using ES modules natively in Node.js</a></p>

<p>作者：<a href="https://twitter.com/rauschma">Axel Rauschmayer</a></p></blockquote>

<p>从版本 8.5.0 开始，Node.js 开始支持原生 ES 模块，可以通过命令行选项打开该功能。新功能很大程度上得归功于 <a href="https://twitter.com/bradleymeck">Bradley Farias</a>。</p>

<h2>1.演示</h2>

<p>这个示例的代码目录结构如下：</p>

<pre><code>esm-demo/
    lib.mjs
    main.mjs
</code></pre>

<p>lib.mjs：</p>

<pre><code class="javascript">export function add(x, y) {
    return x + y;
}
</code></pre>

<p>main.mjs：</p>

<pre><code class="javascript">import {add} from './lib.mjs';

console.log('Result: '+add(2, 3));
</code></pre>

<p>运行演示：</p>

<pre><code class="sh">$ node --experimental-modules main.mjs
Result: 5
</code></pre>

<h2>2.清单：需要注意的事情</h2>

<h3>ES 模块：</h3>

<ul>
<li><p>不能动态导入模块。但是 <a href="http://2ality.com/2017/01/import-operator.html">动态 import()</a> 的相关工作正在进行中，应该很快就能提供支持。</p></li>
<li><p>没有元变量，如 <code>__dirname</code> 和 <code>__filename</code>。但是，有一个的类似功能的提案：“<a href="https://github.com/tc39/proposal-import-meta">import.meta</a>”。看起来可能是这样：</p></li>
</ul>


<pre><code class="javascript">console.log(import.meta.url);
</code></pre>

<ul>
<li>现在所有模块标识符都是 URL（这部分在 Node.js 是新增的）：

<ul>
<li>文件 - 带文件扩展名的相对路径： <code>../util/tools.mjs</code></li>
<li>库 - 没有文件扩展名，也没有路径 <code>lodash</code></li>
<li>如何更好地使 npm 库在浏览器中也可用（不使用 bundler）仍有待观察。一种可能性是引入 RequireJS 风格的配置数据，将路径映射到实际路径。目前，在浏览器中使用 bare path 的模块标识符是非法的。</li>
</ul>
</li>
</ul>


<h3>与 CJS 模块的互操作性</h3>

<ul>
<li>你可以导入 CJS 模块，但它们总是只有默认的导出 - 即 <code>module.exports</code> 的值。让 CJS 模块支持命名导出已经在做了，但可能需要一段时间。如果你能帮忙，<a href="https://twitter.com/bradleymeck/status/906210545145184257">可以来做</a>。</li>
</ul>


<pre><code class="javascript">import fs1 from 'fs';
console.log(Object.keys(fs1).length); // 86

import * as fs2 from 'fs';
console.log(Object.keys(fs2)); // ['default']
</code></pre>

<ul>
<li>不能在 ES 模块中使用 require()。主要原因是：

<ul>
<li>路径解析工作稍有不同：ESM 不支持 <code>NODE_PATH</code> 和 <code>require.extensions</code>。而且，它的标识符始终是 URL 也会导致一些细微差异。</li>
<li>ES 模块始终以异步方式加载，这确保了与 Web 的最大兼容性。这种加载风格并不能通过 require() 混合使用同步加载 CJS 模块。</li>
<li>禁止同步模块加载也可以为 Top-level await 导入 ES 模块保留后路（一个当前正在考虑的功能）。</li>
</ul>
</li>
</ul>


<h2>3.早期版本的 Node.js 上的 ES 模块</h2>

<p>如果要在 8.5.0 之前的 Node.js 版本上使用 ES 模块，请参阅 John-David Dalton 的 <a href="https://github.com/standard-things/esm">@std/esm</a>。</p>

<p>提示：如果不启用任何可解锁的额外功能，将在 Node.js 保持 100％ 兼容原生 ES 模块.</p>

<h2>FAQ</h2>

<h3>什么时候可以不带命令行选项使用ES 模块？</h3>

<p>目前的计划是在 Node.js 10 LTS 中默认可使用 ES 模块。</p>

<h2>进一步阅读  </h2>

<p>有关 Node.js 和浏览器中 ES 模块的更多信息：</p>

<ul>
<li>“<a href="http://2ality.com/2017/01/babel-esm-spec-mode.html">Making transpiled ES modules more spec-compliant</a>” [using ES modules natively vs. transpiling them via Babel]</li>
<li>“<a href="http://2ality.com/2017/05/es-module-specifiers.html">Module specifiers: what’s new with ES modules?</a>” [Why <code>.mjs</code>? How are module specifiers resolved? Etc.]</li>
<li>“<a href="http://exploringjs.com/es6/ch_modules.html">Modules</a>” [in-depth chapter on ES modules in “Exploring ES6”]</li>
</ul>


<p>即将到来的 ECMAScript 提案：</p>

<ul>
<li>博客: “<a href="http://2ality.com/2017/01/import-operator.html">ES proposal: <code>import()</code> – dynamically importing ES modules</a>”</li>
<li>提案: “<a href="https://github.com/tc39/proposal-import-meta"><code>import.meta</code></a>”</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在工作中学习]]></title>
    <link href="http://blog.mirreal.net/blog/2017/09/02/learning-at-work/"/>
    <updated>2017-09-02T21:49:52+08:00</updated>
    <id>http://blog.mirreal.net/blog/2017/09/02/learning-at-work</id>
    <content type="html"><![CDATA[<blockquote><p>原文；<a href="https://jvns.ca/blog/2017/08/06/learning-at-work/">Learning at work</a></p>

<p>作者：Julia Evans</p>

<p>谈点：学习是一件没有尽头的事，虽然在工作中很多时候被淹没在没玩没了的需求里面，加班是常态，或许很多人不知不觉放弃学习的心思。这篇文章中提到的一些方法我很赞同，很多点也是我的做事方式，这里也希望所有人都能找到适合自己的学习方式。</p></blockquote>

<p>在 Twitter 上我提了一个问题，“你是如何花时间用于自身学习”（<a href="https://twitter.com/b0rk/status/887111177062555648">这个推文</a>)，这些回答有一些相同之处：</p>

<ul>
<li>阅读博客文章</li>
<li>去参加业界大会</li>
<li>读书</li>
<li>在洗碗时看一些演讲</li>
<li>在一些不那么重要的项目里运用你想要学习的技术</li>
</ul>


<p>这些方法都挺管用的。为了个人职业发展，在工作之外花时间学习新技能是非常普遍的事，在这方面我也有不少经验。</p>

<p>另一方面，我知道有一些很厉害的程序员在工作之外完全不写代码。于是我开始思考，如果你想变得更牛，但又不想工作之外花太多额外时间要怎么办？</p>

<p>这些是我以及在 Twitter 上的朋友提到的一些观点，并且都是能在工作时候做的事情。</p>

<h2>不要学习工作之外的编程语言/框架</h2>

<p>这一点听起来有些消极，但确实还是很有用的。对于学习编程语言，我的观点是：</p>

<ul>
<li>我很熟悉几种编程语言（python，scala，ruby）</li>
<li>学习新的编程语言需要相当长的时间</li>
<li>我不想把空闲时间花在上面</li>
</ul>


<p>最近我在做一些 Go 方面的工作，还挺有趣的，我也喜欢做这件事。但是又觉得在上面花费太多个人时间，所以显得不是那么有趣了。通过编写代码学习编程，阅读别人的代码掌握一些模式，然后自己审查代码，然而这些都不是必须的，因为完全可以在工作中去做这些事情。</p>

<h2>选择一些可以从中学习的项目</h2>

<p>这些是我在过去三年学到的一些东西：</p>

<ul>
<li>Scala/Ruby/Go</li>
<li>hadoop/mapreduce/scalding</li>
<li>如何使用 Java 并发库，以及如何配置一个 Java 程序</li>
<li>关于各种 AWS 服务的工作原理</li>
<li>很多机器学习的东西</li>
<li>网络/ CDN / TLS 如何工作</li>
<li>docker/容器/rkt/kubernetes</li>
<li>服务发现 / DNS / jenkins</li>
</ul>


<p>一个关于如何选择项目的例子：如果在工作使用一个不能很好并行的程序，这时候问题就来了。我可以选择去问写这个程序的人为什么不使用并行编程，但是如果我也很想学习一下并行编程的话，就可以自己去完成这件事。所以后来我就 <a href="https://jvns.ca/blog/2016/03/29/thread-pools-part-ii-i-love-blocking/">学到了如何在 Java 中使用线程池</a>。</p>

<p>我只为此工作了几天，但却因此学到了新东西。</p>

<p>现在我正在从事 Kubernetes 相关的工作，当时选择它并不是因为可以在这里面学到很多东西。但是我确实学到很多有关分布式系统的东西，还在工作中使用 Go 语言，我觉得这很很棒。</p>

<p>当人们说像“嘿，我们使用 X 技术，需要有相关经验的人才能在这里工作”时，这其实相当愚蠢。现在我在网络/ puppet / kubernetes / docker / AWS 上花了很多时间，在这项工作之前没有任何相关工作经验。</p>

<h2>观察那些高级人员是如何做事的</h2>

<p>我会观察那些我敬佩的人在工作中的做事方式，然后尝试模仿他们或者是向他们寻求建议。例如，当 <a href="http://onemogin.com/">Cory</a> 加入时，我注意到，在引进新技术的时候，他会这样做：</p>

<ul>
<li>找到另一个有类似问题需要解决的团队</li>
<li>与他们合作，确保技术真正解决问题</li>
</ul>


<p>现在我正在开展一个新项目，一直在考虑这些工作可以帮到谁以及如何帮助，这样做就会感觉好很多。</p>

<h2>阅读每个 pull request</h2>

<p>在这个主题下引用两个我很喜欢的观点：</p>

<blockquote><p>我在一个小团队，所以会阅读所有的 pull request，直到完全了解问题和解决方案</p></blockquote>

<p>和</p>

<blockquote><p>我也是一样！我跟踪检查，看看人们如何解决各种问题</p></blockquote>

<p>事实上，我并没有阅读团队中的每一个 pull request。但是那确实很有用，通过跟踪别人在这方面做的工作来学习这个领域的东西。</p>

<p>但我并不是能完全做到。我曾经从事机器学习方面的工作，发现理论也很有趣，就想跟踪人们在这方面的情况，但对我来说有太多要注意的东西。我只能尽量注意那些比较接近我的东西，像是其中网络团队的一些工作。</p>

<h2>阅读源代码</h2>

<blockquote><p>阅读我用到的源代码对我而言是一个大块头。了解它在内部在做什么，主要是为什么可以通过某种方式工作。</p></blockquote>

<p>这是很重要的一点，也非常重要。很多库、框架、工具并没有很好的文档，在没有阅读源代码的情况下根本无法了解其工作原理。</p>

<h2>跟进你无法解决的 bug</h2>

<p>有时我会遇到一些自己没办法解决的 bug。后来，可能别人会找到解决方法，在这时候，就值得花时间去搞清楚具体的解决方法是什么，以及他们如何想出来的。</p>

<p>例如，最近有一个我没有调试出来的网络问题，刚好有人在上周搞清楚这个问题。现在想一想，大概明白造成这个 bug 的原因，但是我并不清楚他们用什么工具来获取调试所需的信息。当我重新开始工作时，必须确保我真的搞清楚这个问题，这样下次就可以做得更好。</p>

<p>Jessica Kerr 评论道</p>

<blockquote><p>每当我在故障排除时，除了解决这个问题，还会更深入或更广泛地延伸开去。</p></blockquote>

<p>我也喜欢这个回复：</p>

<blockquote><p>有时候，想解决一个与工作有关的问题，但并没有真的在实际工作中发生，只是看看我能不能在某方面有所突破。</p></blockquote>

<h2>运用好通勤时间</h2>

<p>对我而言，其实并没有通勤时间。但很多人提到他们会利用通勤时间来听播客/阅读报纸/阅读有趣的文章。这似乎是一个很不错的方式，来做一些你感兴趣的事情。</p>

<h2>花时间在工作中学习</h2>

<p>Twitter上有人说“我希望每天可以花 1 小时来学习”。我的观点是，我的工作就是要在工作日中抽出时间来学习东西。像现在我正在工作中使用 Kubernetes，这是一个很复杂的系统需要很长时间才能理解，我得花时间了解它是如何工作的。例如，在开始的时候，没什么目的地在做集群测试，只是想了解容器的网络如何工作的，同时也在项目上取得进展。</p>

<p>这可能对我来说挺容易的，因为我的工作跟别人隔得很远，没有人真的知道我具体在做什么，他们只是关心在大方面做的是什么。</p>

<p>实际上，如果要是提前多花点时间阅读，可能效果会更好。就像我刚刚在阅读 Kelsey Hightower 的“learn kubernetes the hard way”的文档，读完不需花太长时间，而且其中有一个关于如何设置一个集群的很好的点，这样就可以很节省我很多时间。</p>

<p>关于这个点，有些人还要想得更远。比如，我的朋友 Dan 就提到好几次，说他喜欢在工作中阅读技术书籍。最初觉得这是一件令人惊讶的事情，但它确实很有用。事实上，有很多跟我工作相关的书籍，找不到理由为什么不能在工作中阅读它们。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript 中的匿名递归]]></title>
    <link href="http://blog.mirreal.net/blog/2017/08/09/anonymous-recursion-in-javascript/"/>
    <updated>2017-08-09T14:54:22+08:00</updated>
    <id>http://blog.mirreal.net/blog/2017/08/09/anonymous-recursion-in-javascript</id>
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="https://dev.to/simov/anonymous-recursion-in-javascript">Anonymous Recursion in JavaScript</a></p>

<p>作者：Simeon Velichkov</p></blockquote>

<pre><code class="javascript">(
  (
    (f) =&gt; f(f)
  )
  (
    (f) =&gt;
      (l) =&gt; {
        console.log(l)
        if (l.length) f(f)(l.slice(1))
        console.log(l)
      }
  )
)
(
  [1, 2, 3]
)
</code></pre>

<p>是的，这就是想要分享给大家的一个有趣的示例。这个例子包含以下特性：<a href="https://en.wikipedia.org/wiki/Closure_(computer_programming">闭包</a>)，<a href="https://en.wikipedia.org/wiki/Immediately-invoked_function_expression">自执行函数</a>，<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions">箭头函数</a>，<a href="https://en.wikipedia.org/wiki/Functional_programming">函数式编程</a> 和 <a href="https://en.wikipedia.org/wiki/Anonymous_recursion">匿名递归</a>。</p>

<p>你可以复制粘贴上述代码到浏览器控制台，会看到打印结果如下：</p>

<pre><code>[ 1, 2, 3 ]
[ 2, 3 ]
[ 3 ]
[]
[]
[ 3 ]
[ 2, 3 ]
[ 1, 2, 3 ]
</code></pre>

<p>说到函数式编程，这里有一个使用 <a href="https://en.wikipedia.org/wiki/Scheme_(programming_language">Scheme</a>) (JavaScript 借鉴过的其中一门语言)编写的类似例子：</p>

<pre><code class="scheme">(
  (
    (lambda (f) (f f))
    (lambda (f)
      (lambda (l)
        (print l)
        (if (not (null? l)) ((f f) (cdr l)))
        (print l)
      )
    )
  )
  '(1 2 3)
)
</code></pre>

<h2>Unwind</h2>

<p>像其他很多编程语言一样，函数调用是通过在函数名称后添加括号 <code>()</code> 来完成的：</p>

<pre><code class="javascript">function foo () { return 'hey' }
foo()
</code></pre>

<p>在 JavaScript 中我们可以使用括号包裹任意数量的表达式：</p>

<pre><code class="javascript">('hey', 2+5, 'dev.to')
</code></pre>

<p>上面代码返回结果是 <code>'dev.to'</code>，原因是 JavaScript 返回最后一个表达式作为结果。</p>

<p>使用括号 <code>()</code> 包裹一个匿名函数表示其结果就是 <a href="https://en.wikipedia.org/wiki/Anonymous_function">匿名函数</a> 本身。</p>

<pre><code class="javascript">(function () { return 'hey' })
</code></pre>

<p>这本身并没有用处，因为匿名函数没有命名，无法被引用，除非在初始化的时候立即调用它。</p>

<p>就像是普通函数一样，我们可以在其后面添加括号 <code>()</code> 来进行调用。</p>

<pre><code class="javascript">(function () { return 'hey' })()
</code></pre>

<p>也可以使用箭头函数：</p>

<pre><code class="javascript">(() =&gt; 'hey')()
</code></pre>

<p>同样地，在匿名函数后添加括号 <code>()</code> 来执行函数，这被称为 <a href="https://en.wikipedia.org/wiki/Immediately-invoked_function_expression">自执行函数</a>。</p>

<h2>闭包</h2>

<p><a href="https://en.wikipedia.org/wiki/Closure_(computer_programming">闭包</a>) 指的是函数和该函数声明词法环境的组合。结合 <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions">箭头功能</a>，我们可以定义如下：</p>

<pre><code class="javascript">var foo = (hi) =&gt; (dev) =&gt; hi + ' ' + dev
</code></pre>

<p>在控制台调用上述函数会打印 <code>hey dev.to</code>:</p>

<pre><code class="javascript">foo('hey')('dev.to')
</code></pre>

<p>注意，我们可以在内部函数作用域访问外部函数的参数 <code>hi</code>。</p>

<p>以下代码跟上述代码一样：</p>

<pre><code class="javascript">function foo (hi) {
  return function (dev) { return hi + ' ' + dev }
}
</code></pre>

<p>自执行的版本如下：</p>

<pre><code class="javascript">(
  (hi) =&gt;
    (
      (dev) =&gt; `${hi} ${dev}`
    )
    ('dev.to')
)
('hey')
</code></pre>

<p>首先，将 <code>hey</code> 作为参数 <code>hi</code> 的值传给最外层作用域的函数，然后这个函数返回另一个自执行函数。<code>dev.to</code> 作为参数 <code>dev</code> 的值传给内部函数，最后这个函数返回最终值：<code>'hey dev.to'</code>。</p>

<h2>再深入一点</h2>

<p>这个一个上述自执行函数的修改版本：</p>

<pre><code class="javascript">(
  (
    (dev) =&gt;
      (hi) =&gt; `${hi} ${dev}`
  )
  ('dev.to')
)
('hey')
</code></pre>

<p>需要注意的是，<a href="https://en.wikipedia.org/wiki/Immediately-invoked_function_expression">自执行函数</a> 和 <a href="https://en.wikipedia.org/wiki/Closure_(computer_programming">闭包</a>) 用作初始化和封装状态，接下来我们来看另外一个例子。</p>

<h2>匿名递归</h2>

<p>回到我们最初的例子，这次加点注释：</p>

<pre><code class="javascript">(
  (
    (f) =&gt; f(f) // 3.
  )
  (
    (f) =&gt; // 2.
      (l) =&gt; { // 4.
        console.log(l)
        if (l.length) f(f)(l.slice(1))
        console.log(l)
      }
  )
)
(
  [1, 2, 3] // 1.
)
</code></pre>

<ol>
<li>输入函数 <code>[1, 2, 3]</code> 传给最外层作用域</li>
<li>整个函数作为参数传给上面函数</li>
<li>这个函数接收下面函数作为参数 <code>f</code> 的值，然后自身调用</li>
<li><code>2.</code>将被调用被作为 <code>3.</code>的结果然后返回函数 <code>4.</code> ，该函数是满足最外层作用域的函数，因此接收输入数组作为 <code>l</code> 参数的值</li>
</ol>


<p>至于结果为什么是那样子，原因是在递归内部有一个对函数 <code>f</code> 的引用来接收输入数组 <code>l</code>。所以能那样调用：</p>

<pre><code class="javascript">f(f)(l.slice(1))
</code></pre>

<p>注意，<code>f</code> 是一个闭包，所以我们只需要调用它就可以访问到操作输入数组的最里面的函数。</p>

<p>为了说明目的，第一个 <code>console.log(l)</code> 语句表示递归自上而下，第二个语句表示递归自下而上。</p>

<h2>结论</h2>

<p>希望你喜欢这篇文章，并从中学到了新的东西。闭包、自执行函数、函数式编程模式不是黑魔法。它们遵循一套易于理解和玩乐的简单原则。</p>

<p>话虽如此，你必须培养自己何时使用它们，何时不用的这样一种感觉。如果你的代码变得难以维护，那这可能会成为重构中一些好点子。</p>

<p>然而，理解这些基本技术对于创建清晰优雅的解决方案以及提升自我是至关重要的。</p>

<p>Happy Coding！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[面向初学者的高阶组件介绍]]></title>
    <link href="http://blog.mirreal.net/blog/2017/07/19/higher-order-components-for-beginners/"/>
    <updated>2017-07-19T18:59:37+08:00</updated>
    <id>http://blog.mirreal.net/blog/2017/07/19/higher-order-components-for-beginners</id>
    <content type="html"><![CDATA[<blockquote><p>作者：Brandon Newton</p>

<p>原文：<a href="https://btnwtn.com/articles/higher-order-components-for-beginners">Higher-Order Components (HOCs) for Beginners</a></p>

<p>谈点：一篇面向初学者的 HOC 介绍。高阶组件听起来挺唬人的，只看名字恐怕不是那么容易明白究竟是何物，而且通常来讲高阶组件并不是组件，而是接受组件作为参数，并且返回组件的函数。早期利用 ES5 的 mixin 语法来做的事，基本都可以使用高阶组件代替，而且能做的还有更多。</p></blockquote>

<h2>前言</h2>

<p>写这篇文章的起因是其他关于高阶组件（Higher-Order Components）的文章，包含官方文档，都令初学者感到相当困惑。我知道有高阶组件这样一个东西，但不知道它到底有什么用。所以，想通过一篇文章来对高阶组件有一个更好的理解。</p>

<p>在此之前，我们需要先来讲一下 JavaScript 中的函数。</p>

<h2>ES6 箭头函数简介</h2>

<p>接下来将提供一些箭头函数的简单示例，如果之前没有使用过，可以认为它们与普通函数基本一致。下面的代码会展示箭头函数与普通函数的区别。</p>

<pre><code class="javascript">function () {
  return 42
}

// same as:
() =&gt; 42

// same as:
() =&gt; {
  return 42
}

function person(name) {
  return { name: name }
}

// same as:
(name) =&gt; {
  return { name: name }
}
</code></pre>

<p>阅读 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">MDN 的箭头函数文档</a> 了解更多信息。</p>

<h2>作为值的函数与部分调用</h2>

<p>就像是数字、字符串、布尔值 一样，函数也是值，意味着可以像传递其他数据一样传递函数，可以将函数作为参数传递给另外一个函数。</p>

<pre><code class="javascript">const execute = (someFunction) =&gt; someFunction()

execute(() =&gt; alert('Executed'))
</code></pre>

<p>也可以在在函数中返回一个函数：</p>

<pre><code class="javascript">const getOne = () =&gt; () =&gt; 1

getOne()()
</code></pre>

<p>之所以在 <code>getOne</code> 后面有两个 <code>()</code> ，是因为第一个返回的返回值是一个函数。如下：</p>

<pre><code class="javascript">const getOne = () =&gt; () =&gt; 1

getOne
//=&gt; () =&gt; () =&gt; 1

getOne()
//=&gt; () =&gt; 1

getOne()()
//=&gt; 1
</code></pre>

<p>从函数返回函数可以帮助我们追踪初始输入函数。例如，下面的函数接受一个数字作为参数，并返回一个将该参数乘以新参数的函数：</p>

<pre><code class="javascript">const multiply = (x) =&gt; (y) =&gt; x * y

multiply(5)(20)
</code></pre>

<p>这个示例跟上述 <code>getOne</code> 一样，在下面这个例子，让 x = 5，y = 20。</p>

<pre><code class="javascript">const multiply = (x) =&gt; (y) =&gt; x * y

multiply
//=&gt; (x) =&gt; (y) =&gt; x * y

multiply(5)
//=&gt; (y) =&gt; 5 * y

multiply(5)(20)
//=&gt; 5 * 20
</code></pre>

<p>在只传入一个参数调用 <code>multiply</code> 函数时，即部分调用该函数。比如，<code>multiply(5)</code> 讲得到一个将其输入值乘以 5 的函数，<code>multiply(7)</code> 将得到一个将其输入值乘以 7 的函数。依此类推。通过部分调用可以创建一个预定义功能的新函数：</p>

<pre><code class="javascript">const multiply = (x) =&gt; (y) =&gt; x * y

const multiplyByFive = multiply(5)
const multiplyBy100 = multiply(100)

multiplyByFive(20)
//=&gt; 100
multiply(5)(20)
//=&gt; 100

multiplyBy100(5)
//=&gt; 500
multiply(100)(5)
//=&gt; 500
</code></pre>

<p>一开始看起来似乎没什么用，但是，通过部分调用这种方式可以编写可读性更高，更易于理解的代码。举个例子，可以用一种更清晰的方式来代替 <a href="https://www.styled-components.com/docs/basics#adapting-based-on-props">style-components</a> 的函数插入语法。</p>

<pre><code class="javascript">// before
const Button = styled.button`
  background-color: ${({ theme }) =&gt; theme.bgColor}
  color: ${({ theme }) =&gt; theme.textColor}
`

&lt;Button theme={themes.primary}&gt;Submit&lt;/Button&gt;
// after
const fromTheme = (prop) =&gt; ({ theme }) =&gt; theme[prop]

const Button = styled.button`
  background-color: ${fromTheme("bgColor")}
  color: ${fromTheme("textColor")}
`

&lt;Button theme={themes.primary}&gt;Submit&lt;/Button&gt;
</code></pre>

<p>我们创建一个接受一个字符串作为参数的函数 <code>fromTheme("textColor")</code>：它返回一个接受具有 <code>theme</code> 属性的对象的函数：<code>({ theme }) =&gt; theme[prop]</code>，然后再通过初始传入的字符串 <code>"textColor"</code> 进行查找。我们可以做得更多，写类似的 <code>backgroundColor</code> 和 <code>textColor</code> 这种部分调用 <code>fromTheme</code> 的函数：</p>

<pre><code class="javascript">const fromTheme = (prop) =&gt; ({ theme }) =&gt; theme[prop]
const backgroundColor = fromTheme("bgColor")
const textColor = fromTheme("textColor")

const Button = styled.button`
  background-color: ${backgroundColor}
  color: ${textColor}
`

&lt;Button theme={themes.primary}&gt;Submit&lt;/Button&gt;
</code></pre>

<h2>高阶函数</h2>

<p>高阶函数的定义是，接受函数作为参数的函数。如果曾经使用过类似 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map">map</a> 这样的函数，可能已经很熟悉高阶函数。如果不熟悉 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map">map</a>，它是一个数组遍历的方法，接受一个函数作为参数应用到数组中的每个元素。例如，可以像这样对一个数组作平方：</p>

<pre><code class="javascript">const square = (x) =&gt; x * x

[1, 2, 3].map(square)
//=&gt; [ 1, 4, 9 ]
</code></pre>

<p>可以实现一个我们自己的 <code>map</code> 版本来说明这个概念：</p>

<pre><code class="javascript">const map = (fn, array) =&gt; {
  const mappedArray = []

  for (let i = 0; i &lt; array.length; i++) {
    mappedArray.push(
      // apply fn with the current element of the array
      fn(array[i])
    )
  }

  return mappedArray
}
</code></pre>

<p>然后再使用我们的 map 版本来对一个数组作平方：</p>

<pre><code class="javascript">const square = (x) =&gt; x * x

console.log(map(square, [1, 2, 3, 4, 5]))
//=&gt; [ 1, 4, 9, 16, 25 ]
</code></pre>

<blockquote><p>译者注：我们也可以将 map 方法从对象中解耦出来：</p>

<pre><code class="javascript">const map = (fn, array) =&gt; Array.prototype.map.call(array, fn)
</code></pre>

<p>这样也可以像上述例子一样调用。
或者更函数式的做法，再来点柯里化：</p>

<pre><code class="javascript">const map = array =&gt; fn =&gt; Array.prototype.map.call(array, fn)
</code></pre></blockquote>

<p>或者是返回一个 <code>&lt;li&gt;</code>的 React 元素数组：</p>

<pre><code class="javascript">const HeroList = ({ heroes }) =&gt; (
  &lt;ul&gt;
    {map((hero) =&gt; (
      &lt;li key={hero}&gt;{hero}&lt;/li&gt;
    ), heroes)}
  &lt;/ul&gt;
)

&lt;HeroList heroes=[
  "Wonder Woman",
  "Black Widow",
  "Spider Man",
  "Storm",
  "Deadpool"
]/&gt;
/*=&gt; (
  &lt;ul&gt;
    &lt;li&gt;Wonder Woman&lt;/li&gt;
    &lt;li&gt;Black Widow&lt;/li&gt;
    &lt;li&gt;Spider Man&lt;/li&gt;
    &lt;li&gt;Storm&lt;/li&gt;
    &lt;li&gt;Deadpool&lt;/li&gt;
  &lt;/ul&gt;
)*/
</code></pre>

<h2>高阶组件</h2>

<p>我们知道，高阶函数是接受函数作为参数的函数。在 React 中，任何返回 <a href="https://facebook.github.io/react/docs/jsx-in-depth.html">JSX</a> 的函数都被称为无状态函数组件，简称为函数组件。基本的函数组件如下所示：</p>

<pre><code class="javascript">const Title = (props) =&gt; &lt;h1&gt;{props.children}&lt;/h1&gt;

&lt;Title&gt;Higher-Order Components(HOCs) for React Newbies&lt;/Title&gt;
//=&gt; &lt;h1&gt;Higher-Order Components(HOCs) for React Newbies&lt;/h1&gt;
</code></pre>

<p>高阶组件则是<em>接受组件作为参数并返回组件的函数</em>。如何使用传入组件完全取决于你，甚至可以完全忽视它：</p>

<pre><code class="javascript">// Technically an HOC
const ignore = (anything) =&gt; (props) =&gt; &lt;h1&gt;:)&lt;/h1&gt;

const IgnoreHeroList = ignore(HeroList)
&lt;IgnoreHeroList /&gt;
//=&gt; &lt;h1&gt;:)&lt;/h1&gt;
</code></pre>

<p>可以编写一个将输入转换成大写的 HOC：</p>

<pre><code class="javascript">const yell = (PassedComponent) =&gt;
  ({ children, ...props }) =&gt;
    &lt;PassedComponent {...props}&gt;
      {children.toUpperCase()}!
    &lt;/PassedComponent&gt;

const Title = (props) =&gt; &lt;h1&gt;{props.children}&lt;/h1&gt;
const AngryTitle = yell(Title)

&lt;AngryTitle&gt;Whatever&lt;/AngryTitle&gt;
//=&gt; &lt;h1&gt;WHATEVER!&lt;/h1&gt;
</code></pre>

<p>你也可以返回一个有状态组件，因为 JavaScript 中的类不过是函数的语法糖。这样就可以使用到 React 生命周期的方法，比如 <code>componentDidMount</code>。这是 HOCs 真正有用的地方。我们现在可以做一些稍微有趣点的事，比如将 HTTP 请求的结果传递给函数组件。</p>

<pre><code class="javascript">const withGists = (PassedComponent) =&gt;
  class WithGists extends React.Component {
    state = {
      gists: []
    }

    componentDidMount() {
      fetch("https://api.github.com/gists/public")
      .then((r) =&gt; r.json())
      .then((gists) =&gt; this.setState({
        gists: gists
      }))
    }

    render() {
      return (
        &lt;PassedComponent
          {...this.props}
          gists={this.state.gists}
        /&gt;
      )
    }
  }


const Gists = ({ gists }) =&gt; (
  &lt;pre&gt;{JSON.stringify(gists, null, 2)}&lt;/pre&gt;
)

const GistsList = withGists(Gists)

&lt;GistsList /&gt;
//=&gt; Before api request finishes:
// &lt;Gists gists={[]} /&gt;
//
//=&gt; After api request finishes:
// &lt;Gists gists={[
//  { /* … */ },
//  { /* … */ },
//  { /* … */ }
// ]} /&gt;
</code></pre>

<p><code>withGists</code> 会传递 gist api 调用的结果，并且你可以在任何组件上使用。<a href="https://codesandbox.io/embed/o2YpJnpDj">点击这里</a> 可以看到一个更加完整的例子。</p>

<h2>结论：高阶组件是 🔥🔥🔥</h2>

<p>react-redux 也是使用 HOC， <a href="https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options">connect</a> 将应用 store 的值传递到“已连接” 的组件。它还会执行一些错误检查和组件生命周期优化，如果手动完成将导致编写大量重复代码。</p>

<p>如果你发现自己在不同地方编写了大量的代码，那么也可以将代码重构成可重用的 HOC。</p>

<p>HOCs 非常具有表现力，可以使用它们创造很多很酷的东西。</p>

<p>尽可能地保持你的 HOC 简单，<em>不要编写需要阅读长篇大论才能理解的代码</em>。</p>

<h3>附加练习</h3>

<p>下面有一些练习，来巩固对 HOC 的理解：</p>

<ul>
<li>写一个反转其输入的 HOC</li>
<li>编写一个HOC，将 API 中的数据提供给组件</li>
<li>写一个HOC来实现 <a href="https://facebook.github.io/react/docs/react-component.html#shouldcomponentupdate"><code>shouldComponentUpdate</code></a>，<a href="https://facebook.github.io/react/docs/optimizing-performance.html#avoid-reconciliation">以避免更新</a>。</li>
<li>编写一个 HOC，使用 <a href="https://facebook.github.io/react/docs/react-api.html#react.children.toarray"><code>React.Children.toArray</code></a> 对传入组件子元素进行排序。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CSS Animations vs Web Animations API]]></title>
    <link href="http://blog.mirreal.net/blog/2017/06/26/css-animations-vs-web-animations-api-slash/"/>
    <updated>2017-06-26T20:47:08+08:00</updated>
    <id>http://blog.mirreal.net/blog/2017/06/26/css-animations-vs-web-animations-api-slash</id>
    <content type="html"><![CDATA[<blockquote><p>作者：Ollie Williams</p>

<p>原文：<a href="https://css-tricks.com/css-animations-vs-web-animations-api/">CSS Animations vs Web Animations API</a></p></blockquote>

<p>在  JavaScript 有一个原生动画 API 叫 Web Animations API，在这篇文章中简称为 WAAPI。MDN 上已经有 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API">很好的文档</a>，而且，Dan Wilson 为此写了 <a href="http://danielcwilson.com/blog/2015/07/animations-part-1/">一个很棒的文章系列</a>。</p>

<p>在本文中，我们一起来对比一下 WAAPI 和 CSS 动画。</p>

<h2>关于浏览器支持</h2>

<p>尽管浏览器原生支持仍然有限，但 WAAPI 有一个全面和强大的 <a href="https://github.com/web-animations/web-animations-js">polyfill</a>，使得现在就能在生产环境使用。</p>

<p>同样地，可以在 <a href="https://github.com/web-animations/web-animations-js">Can I Use</a> 查看浏览器兼容性数据。然而，这并没有提供很好的信息来支持 WAAPI 的所有子功能。这里有一个检查工具：</p>

<p>See the Pen <a href="https://codepen.io/danwilson/pen/xGBKVq/">WAAPI Browser Support Test</a> by Dan Wilson (<a href="https://codepen.io/danwilson">@danwilson</a>) on <a href="https://codepen.io/">CodePen</a>.</p>

<p>要想再没有 polyfill 的情况下体验所有功能，请使用 Firefox Nightly。</p>

<h2>WAAPI 的基础知识</h2>

<p>如果你曾经使用 jQuery  的 <code>.animate()</code>，那么应该会觉得 WAAPI 的基本语法看起来很熟悉。</p>

<pre><code class="javascript">var element = document.querySelector('.animate-me');
element.animate(keyframes, 1000);
</code></pre>

<p><code>animate</code> 方法接受两个参数：关键帧和持续时间。与 jQuery 相比的优势是，不仅是浏览器内置，而且性能也更好。</p>

<p>第一个参数，关键帧，是一个对象数组，每个对象都是动画中的一个关键帧。看这个简单的例子：</p>

<pre><code class="javascript">var keyframes = [
  { opacity: 0 },
  { opacity: 1 }
];
</code></pre>

<p>第二个参数，持续时间，指的是想要动画持续多久，在上面的例子中是 1000 毫秒。接下来看一个更令人兴奋的例子。</p>

<h2>用 WAAPI 重新创建一个 animista 的 CSS 动画</h2>

<p>这里有一些从 <a href="http://animista.net/">animista</a> 拉取的 CSS 代码，被称为 slide-in-blurred-top 的入场动画。看起来很漂亮</p>

<p>在 <a href="http://animista.net/play/entrances/slide-in-blurred/slide-in-blurred-top">实际PERF</a> 比这个 GIF 效果好很多。</p>

<p>以下是 CSS 中的关键帧：</p>

<pre><code class="css">0% {
  transform: translateY(-1000px) scaleY(2.5) scaleX(.2);
  transform-origin: 50% 0;
  filter: blur(40px);
  opacity: 0;
}
100% {
  transform: translateY(0) scaleY(1) scaleX(1);
  transform-origin: 50% 50%;
  filter: blur(0);
  opacity: 1;
}
</code></pre>

<p>在 WAAPI 中代码基本相同：</p>

<pre><code class="javascript">var keyframes = [
  {
    transform: 'translateY(-1000px) scaleY(2.5) scaleX(.2)',
    transformOrigin: '50% 0',
    filter: 'blur(40px)',
    opacity: 0
  },
  {
    transform: 'translateY(0) scaleY(1) scaleX(1)',
    transformOrigin: '50% 50%',
    filter: 'blur(0)',
    opacity: 1
  }
];
</code></pre>

<p>可以看出，将关键帧应用到需要动画的元素上是多么容易：</p>

<pre><code class="javascript">element.animate(keyframes, 700);
</code></pre>

<p>为了简单起见，只指定了持续时间。但是，我们可以使用这个第二个参数来传递更多的选项，至少也应该指定一个缓动效果。以下是所有可用选项的完整列表，其中包含一些示例值：</p>

<pre><code class="javascript">var options = {
  iterations: Infinity,
  iterationStart: 0,
  delay: 0,
  endDelay: 0,
  direction: 'alternate',
  duration: 700,
  fill: 'forwards',
  easing: 'ease-out',
}
element.animate(keyframes, options);
</code></pre>

<p>加上这些选项，我们的动画将从头开始，没有任何延迟，在动画完成后往返循环播放。</p>

<p>不爽的是，对于熟悉 CSS 动画的人来说，一些术语跟我们习惯的有所不同。好处是打字会更快一些！</p>

<ul>
<li>使用 <code>easing</code> 而不是 <code>animation-timing-function</code></li>
<li>不是 <code>animation-iteration-count</code>，而是 <code>iterations</code>。如果我们希望动画永远重复，使用 <code>Infinity</code> 而不是 <code>infinite</code>。有点混乱， <code>Infinity</code> 不带引号。<code>Infinity</code> 是一个 JavaScript 关键字，而其他值都是字符串。</li>
<li>我们使用毫秒而不是秒，对于之前写过许多 JavaScript 的人来说，这应该是一样的。（你也可以在 CSS 动画中使用毫秒数，但很少有人使用。）</li>
</ul>


<p>我们来仔细看看一个选项：<code>iterationStart</code>。</p>

<p>当我第一次碰到 <code>iterationStart</code> 有点困惑。为什么要从指定的迭代开始，而不是只要减少迭代次数？当使用十进制数时，此选项非常有用。例如，可以将其设置为  <code>.5</code>，动画将开始一半。要做一个完整的动画需要两个一半，所以如果迭代次数设置为 1，并且将 <code>iterationStart</code> 设置为  <code>.5</code>，动画将从一半到动画结束播放，然后从动画开头开始，结束于中间！</p>

<p>值得注意的是，也可以将迭代次数设置为小于 1。例如：</p>

<pre><code class="javascript">var option = {
  iterations: .5,
  iterationStart: .5
}
</code></pre>

<p>这样，动画会从中间开始，一直播放到最后。</p>

<p>endDelay：如果要将多个动画串在一起，但是希望在一个动画的结尾和后续动画的开始之间存在差距，这时 endDelay 就很有用。这是一个有用的视频，由 Patrick Brosset 来解释。</p>

<p><a href="https://www.youtube.com/embed/hWe-qukNrN8">一个 YouTube 的视频</a></p>

<h2>缓动（easing）</h2>

<p>在任何动画中，缓动都是最重要的元素之一。WAAPI 为我们提供了两种不同的方式设置缓动 - 在我们的关键帧数组或我们的选项对象内。</p>

<p>在 CSS 中，如果使用 <code>animation-timing-function: ease-in-out</code> 你可能会认为动画会缓慢开始，然后缓慢结束。实际上，这些缓动应用在关键帧之间，而不是整个动画。这可以对动画的感觉进行细粒度的控制。WAAPI 也提供这种功能。</p>

<pre><code class="javascript">var keyframes = [
  { opacity: 0, easing: 'ease-in' },
  { opacity: 0.5, easing: 'ease-out' },
  { opacity: 1 }
]
</code></pre>

<p>值得注意的是，在 CSS 和 WAAPI 中，不应该传入最后一帧的缓动值，因为这将不起作用。可是很多人会犯这种错误。</p>

<p>有时候，在整个动画中添加缓动效果更为直观。这在 CSS 是不可能的，但现在可以在 WAAPI 中实现。</p>

<pre><code class="javascript">var options = {
  duration: 1000,
  easing: 'ease-in-out',
}
</code></pre>

<p>可以看到这两种缓动在 CodePen 上的区别：</p>

<p><a href="https://codepen.io/cssgrid/pen/OmrVeQ">点我查看</a></p>

<h2>缓动 vs 线性</h2>

<p>值得注意的是 CSS 动画和 WAAPI 之间的另一个区别：<strong>在 CSS 中 默认值是 ease，而在 WAAPI 默认是 linear。</strong> ease 实际上是 <code>ease-in-out</code> 的一个版本，当你想偷懒时这是一个非常好的选择。同时，线性代表致命的沉闷和无生命 - 一致的速度看起来机械和不自然。它被选为默认值，可能因为它是最中立的选项。然而，在使用 WAAPI 时，更好是使用缓动，以免动画看起来很乏味和机械。</p>

<h2>性能</h2>

<p>WAAPI 提供与 CSS 动画相同的性能改进，尽管这并不意味着一定就是平滑的动画。</p>

<p>希望这个 API 的性能优化做到，使我们可以避免使用 <code>will-change</code>和 <code>translateZ</code> 成为可能。但是，至少在目前的浏览器实现中，这些属性在处理性能问题方面仍然是有帮助，有必要的。</p>

<p>但是，如果你的动画有延迟，则无需担心使用 <code>will-change</code>。web animations 规范的主要作者对 <a href="https://damp-lake-50659.herokuapp.com/">Animation for Work Slack community</a> 提出了一些有趣的建议，希望他不介意我在这里重复：</p>

<blockquote><p>如果有一个正向的延迟，不需要使用 <code>will-change</code>，因为浏览器将在延迟开始时进行分层，当动画启动时，它将准备就绪。</p></blockquote>

<h2>WAAPI 对战 CSS 动画？</h2>

<p>WAAPI 为我们提供了一套已经在 CSS 中实现的 JavaScript 语法。然而，它们不应该被视为对手。如果我们坚持使用 CSS 完成动画和转换，那么我们可以在 WAAPI 进行动画交互。</p>

<h2>动画对象</h2>

<p><code>.animate()</code> 方法不仅处理元素的动画，它也返回一些东西。</p>

<pre><code class="javascript">var myAnimation = element.animate(keyframes, options);
</code></pre>

<p>在控制台中查看的动画对象</p>

<p>如果我们在控制台中查看返回值，会发现这是一个动画对象。这为我们提供了各种各样的功能，其中一些是不言自明，比如 <code>myAnimation.pause()</code>。通过更改 <code>animation-play-state</code> 属性，我们可以通过 CSS 动画实现类似的结果，但 WAAPI 语法比 <code>element.style.animationPlayState = "paused"</code> 更简洁。我们也可以通过 <code>myAnimation.reverse()</code> 轻松反转动画，同样地，跟我们使用脚本更改 CSS 的 <code>animation-direction</code> 属性相比，稍微有点进步。</p>

<p>然而，到目前为止，使用 JavaScript 操作 <code>@keyframe</code> 并不是件容易的的事。即使是重新启动动画这样简单的事，也是需要一些技巧的，就像 Chris Coyier <a href="https://css-tricks.com/restart-css-animation/">先前写过的那样</a>。使用 WAAPI，我们可以简单地使用 <code>myAnimation.play()</code> ，如果动画已经完成，将从一开始就重播动画，或者如果我们暂停播放，则从中间迭代播放动画。</p>

<p>我们甚至可以轻松地改变动画的速度。</p>

<pre><code class="javascript">myAnimation.playbackRate = 2; // speed it up
myAnimation.playbackRate = .4; // use a number less than one to slow it down
</code></pre>

<h2>getAnimations()</h2>

<p>这个方法将返回所有动画对象的数组，包含使用 WAAPI 定义的动画和 CSS 转换或动画。</p>

<pre><code class="javascript">element.getAnimations() // returns any animations or transitions applied to our element using  CSS or WAAPI
</code></pre>

<p>如果你喜欢使用 CSS 来定义和使用动画，<code>getAnimations()</code>  允许 API​​ 与 <code>@keyframes</code> 结合使用。你可以继续使用 CSS 进行大部分动画工作，然后在需要 API 时获得使用 API 的优势。</p>

<p>即使一个 DOM 元素只使用到一个动画，<code>getAnimations()</code> 也将始终返回一个数组。我们使用那个单一的动画对象来处理。</p>

<pre><code class="javascript">var h2 = document.querySelector("h2");
var myCSSAnimation = h2.getAnimations()[0];
</code></pre>

<p>我们也可以在 CSS 动画中使用 web animation API :)</p>

<pre><code class="javascript">myCSSAnimation.playbackRate = 4;
myCSSAnimation.reverse();
</code></pre>

<h2>Promise 和 Event</h2>

<p>很多通过 CSS 触发的事件，现在我们已经可以使用 JavaScript 代码来完成：   <code>animationstart</code>，<code>animationend</code>，<code>animationiteration</code> 和 <code>transitionend</code>。之前经常需要监听动画或转换的结束，以便从 DOM 中删除应用的元素。</p>

<p>在动画对象可以使用 WAAPI 来完成 <code>animationend</code> 或 <code>transitionend</code> 做的事情：</p>

<pre><code class="javascript">myAnimation.onfinish = function() {
  element.remove();
}
</code></pre>

<p>WAAPI 为我们提供了两个选择：event 和 promise。动画对象的 <code>.finished</code> 方法会返回一个在动画结束时的 promise。下面这段代码是上面例子的 promise 版本：</p>

<pre><code class="javascript">myAnimation.finished.then(() =&gt;
  element.remove())
</code></pre>

<p>我们来看看来自 Mozilla 开发者网络中的一个稍微复杂点的例子。<code>Promise.all</code> 接受一个 promise 的数组，一旦所有 promise 完成才会运行回调函数。可以看出，<code>element.getAnimations()</code> 返回的是一个动画对象数组。我们可以将数组中的所有动画对象 map 到每个动画对象的 <code>.finished</code>上，这样就获得需要的 promise 数组。</p>

<p>在这个例子中，只有在页面上的所有动画完成后，我们的函数才能运行。</p>

<pre><code class="javascript">Promise.all(document.getAnimations().map(animation =&gt;
  animation.finished)).then(function() {           
    // do something cool
  })
</code></pre>

<h2>未来</h2>

<p>本文中提到的功能只是一个开始。从目前的规范和实施来看，未来会有一个很强大动画 API。</p>
]]></content>
  </entry>
  
</feed>
