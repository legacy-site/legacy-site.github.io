<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Translator | Mirreal Note]]></title>
  <link href="http://blog.mirreal.net/blog/categories/translator/atom.xml" rel="self"/>
  <link href="http://blog.mirreal.net/"/>
  <updated>2019-03-30T09:45:32+08:00</updated>
  <id>http://blog.mirreal.net/</id>
  <author>
    <name><![CDATA[Patrick Ran]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[从零开始写一个 Promise 库]]></title>
    <link href="http://blog.mirreal.net/blog/2018/04/15/write-your-own-node-js-promise-library-from-scratch/"/>
    <updated>2018-04-15T12:15:14+08:00</updated>
    <id>http://blog.mirreal.net/blog/2018/04/15/write-your-own-node-js-promise-library-from-scratch</id>
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="http://thecodebarbarian.com/write-your-own-node-js-promise-library-from-scratch.html">Write Your Own Node.js Promise Library from Scratch</a></p>

<p>作者：<a href="https://twitter.com/code_barbarian">code_barbarian</a></p></blockquote>

<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a> 已经是 JavaScript 中异步处理的基石，<a href="http://thecodebarbarian.com/2015/03/20/callback-hell-is-a-myth">回调</a>的场景将会越来越少，而且现在<a href="http://thecodebarbarian.com/common-async-await-design-patterns-in-node.js.html">可以直接在 Node.js 使用 async/await</a>。async/await 基于 Promise，因此需要了解 Promise 来掌握 async/await。这篇文章，将介绍如何编写一个 Promise 库，并演示如何使用 async/await。</p>

<h2>Promise 是什么？</h2>

<p>在 ES6 规范中，<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-promise-executor">Promise 是一个类</a>，它的构造函数接受一个 <code>executor</code> 函数。Promise 类的实例有一个 <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-promise.prototype.then"><code>then()</code> 方法</a>。根据规范，Promise 还有其他的一些属性，但在这里可以暂时忽略，因为我们要实现的是一个精简版的库。下面是一个 <code>MyPromise</code> 类的脚手架：</p>

<pre><code>class MyPromise {
    // `executor` 函数接受两个参数，`resolve()` 和 `reject()`
    // 负责在异步操作成功(resolved)或者失败(rejected)的时候调用 `resolve()` 或者 `reject()`
    constructor(executor) {}

    // 当 promise 的状态是 fulfilled（完成）时调用 `onFulfilled` 方法，
    // 当 promise 的状态是 rejected（失败）时调用 `onRejected` 方法
    // 到目前为止，可以认为 'fulfilled' 和 'resolved' 是一样的
    then(onFulfilled, onRejected) {}
}
</code></pre>

<p><code>executor</code> 函数需要两个参数，<code>resolve()</code> 和 <code>reject()</code>。promise 是一个状态机，包含三个状态：</p>

<ul>
<li>pending：初始状态，既不是成功，也不是失败状态</li>
<li>fulfilled：意味着操作成功完成，返回结果值</li>
<li>rejected：意味着操作失败，返回错误信息</li>
</ul>


<p>这样很容易就能实现 <code>MyPromise</code> 构造函数的初始版本：</p>

<pre><code>constructor(executor) {
    if (typeof executor !== 'function') {
        throw new Error('Executor must be a function')
    }

    // 初始状态，$state 表示 promise 的当前状态
    // $chained 是当 promise 处在 settled 状态时需要调用的函数数组
    this.$state = 'PENDING'
    this.$chained = []

    // 为处理器函数实现 `resolve()` 和 `reject()`
    const resolve = res =&gt; {
        // 只要当 `resolve()` 或 `reject()` 被调用
        // 这个 promise 对象就不再处于 pending 状态，被称为 settled 状态
        // 调用 `resolve()` 或 `reject()` 两次，以及在 `resolve()` 之后调用 `reject()` 是无效的
        if (this.$state !== 'PENDING') {
            return
        }
        // 后面将会谈到 fulfilled 和 resolved 之间存在细微差别
        this.$state = 'FULFILLED'
        this.$internalValue = res
        // If somebody called `.then()` while this promise was pending, need
        // to call their `onFulfilled()` function
        for (const { onFulfilled } of this.$chained) {
            onFulfilled(res)
        }
    }
    const reject = err =&gt; {
        if (this.$state !== 'PENDING') {
            return
        }
        this.$state = 'REJECTED'
        this.$internalValue = err
        for (const { onRejected } of this.$chained) {
            onRejected(err)
        }
    }

    // 如规范所言，调用处理器函数中的 `resolve()` 和 `reject()`
    try {
        // 如果处理器函数抛出一个同步错误，我们认为这是一个失败状态
        // 需要注意的是，`resolve()` 和 `reject()` 只能被调用一次
        executor(resolve, reject)
    } catch (err) {
        reject(err)
    }
}
</code></pre>

<p><code>then()</code> 函数的实现更简单，它接受两个参数，<code>onFulfilled()</code> 和 <code>onRejected()</code>。<code>then()</code> 函数必须确保 promise 在 fulfilled 时调用 <code>onFulfilled()</code>，在 rejected 时调用 <code>onRejected()</code>。如果 promise 已经 resolved 或 rejected，<code>then()</code> 函数会立即调用 <code>onFulfilled()</code> 或 <code>onRejected()</code>。如果 promise 仍处于 pending 状态，就将函数推入 <code>$chained</code> 数组，因此后续 <code>resolve()</code> 和 <code>reject()</code> 函数仍然可以调用它们。</p>

<pre><code>then(onFulfilled, onRejected) {
    if (this.$state === 'FULFILLED') {
        onFulfilled(this.$internalValue)
    } else if (this.$state === 'REJECTED') {
        onRejected(this.$internalValue)
    } else {
        this.$chained.push({ onFulfilled, onRejected })
    }
}
</code></pre>

<p><em>*除此之外：ES6 规范表示，如果在已经 resolved 或 rejected 的 promise 调用 <code>.then()</code>, 那么 <code>onFulfilled()</code> 或 <code>onRejected()</code> 将在下一个时序被调用。由于本文代码只是一个教学示例而不是规范的精确实现，因此实现会忽略这些细节。</em></p>

<h2>Promise 调用链</h2>

<p>上面的例子特意忽略了 promise 中最复杂也是最有用的部分：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises#Chaining">链式调用</a>。如果 <code>onFulfilled()</code> 或者 <code>onRejected()</code> 函数返回一个 promise，则 <code>then()</code> 应该返回一个 <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-promise-objects">“locked in”</a> 的新 promise 以匹配这个 promise 的状态。例如：</p>

<pre><code>p = new MyPromise(resolve =&gt; {
    setTimeout(() =&gt; resolve('World'), 100)
})

p
    .then(res =&gt; new MyPromise(resolve =&gt; resolve(`Hello, ${res}`)))
    // 在 100 ms 后打印 'Hello, World'
    .then(res =&gt; console.log(res))
</code></pre>

<p>下面是可以返回 promise 的 <code>.then()</code> 函数实现，这样就可以进行链式调用。</p>

<pre><code>then(onFulfilled, onRejected) {
    return new MyPromise((resolve, reject) =&gt; {
        // 确保在 `onFulfilled()` 和 `onRejected()` 的错误将导致返回的 promise 失败（reject)
        const _onFulfilled = res =&gt; {
            try {
                // 如果 `onFulfilled()` 返回一个 promise, 确保 `resolve()` 能正确处理
                resolve(onFulfilled(res))
            } catch (err) {
                reject(err)
            }
        }
        const _onRejected = err =&gt; {
            try {
                reject(onRejected(err))
            } catch (_err) {
                reject(_err)
            }
        }
        if (this.$state === 'FULFILLED') {
            _onFulfilled(this.$internalValue)
        } else if (this.$state === 'REJECTED') {
            _onRejected(this.$internalValue)
        } else {
            this.$chained.push({ onFulfilled: _onFulfilled, onRejected: _onRejected })
        }
    })
}
</code></pre>

<p>现在 <code>then()</code> 返回一个 promise，但是还需要完成一些工作：如果 <code>onFulfilled()</code> 返回一个 promise，<code>resolve()</code> 要能够正确处理。所以 <code>resolve()</code> 函数需要在 <code>then()</code> 递归调用，下面是更新后的 <code>resolve()</code> 函数：</p>

<pre><code>const resolve = res =&gt; {
    // 只要当 `resolve()` 或 `reject()` 被调用
    // 这个 promise 对象就不再处于 pending 状态，被称为 settled 状态
    // 调用 `resolve()` 或 `reject()` 两次，以及在 `resolve()` 之后调用 `reject()` 是无效的
    if (this.$state !== 'PENDING') {
        return
    }

    // 如果 `res` 是 thenable（带有then方法的对象）
    // 将锁定 promise 来保持跟 thenable 的状态一致
    if (res !== null &amp;&amp; typeof res.then === 'function') {
        // 在这种情况下，这个 promise 是 resolved，但是仍处于 'PENDING' 状态
        // 这就是 ES6 规范中说的"一个 resolved 的 promise"，可能处在 pending, fulfilled 或者 rejected 状态
        // http://www.ecma-international.org/ecma-262/6.0/#sec-promise-objects
        return res.then(resolve, reject)
    }

    this.$state = 'FULFILLED'
    this.$internalValue = res
    // If somebody called `.then()` while this promise was pending, need
    // to call their `onFulfilled()` function
    for (const { onFulfilled } of this.$chained) {
        onFulfilled(res)
    }

    return res
}
</code></pre>

<p><em>为了简单起见，上面的例子省略了一旦 promise 被锁定用以匹配另一个 promise 时，调用 resolve() 或者 reject() 是无效的关键细节。在上面的例子中，你可以 resolve() 一个 pending 的 promise ，然后抛出一个错误，然后 res.then(resolve, reject) 将会无效。这仅仅是一个例子，而不是 ES6 promise 规范的完全实现。</em></p>

<p>上面的代码说明了 resolved 的 promise 和 fulfilled 的 promise 之间的区别。这种区别是微妙的，并且与 promise 链式调用有关。resolved 不是一种真正的 promise 状态，但它是<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-promise-objects">ES6规范中定义</a>的<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-promise-objects">术语</a>。当对一个已经 resolved 的 promise 调用 <code>resolve()</code>，可能会发生以下两件事之一：</p>

<ul>
<li>在调用 <code>resolve(v)</code>时，如果 <code>v</code> 不是一个 promise ，那么 promise 立即成为 fulfilled。在这种简单的情况下，resolved 和 fulfilled 就是一样的。</li>
<li>在调用 <code>resolve(v)</code>时，如果 <code>v</code> 是另一个 promise，那么这个 promise 一直处于 pending 直到 <code>v</code> 调用 resolve 或者 reject。在这种情况下， promise 是 resolved 但处于 pending 状态。</li>
</ul>


<h2>与 Async/Await 一起使用</h2>

<p>关键字 <code>await</code> 会暂停执行一个 <code>async</code> 函数，直到等待的 promise 变成 settled 状态。现在我们已经有了一个简单的自制 promise 库，看看结合使用 async/await 中时会发生什么。向 <code>then()</code> 函数添加一个 <code>console.log()</code> 语句：</p>

<pre><code>then(onFulfilled, onRejected) {
    console.log('Then', onFulfilled, onRejected, new Error().stack)
    return new MyPromise((resolve, reject) =&gt; {
        /* ... */
    })
}
</code></pre>

<p>现在，我们来 <code>await</code> 一个 <code>MyPromise</code> 的实例，看看会发生什么。</p>

<pre><code>run().catch(error =&gt; console.error(error.stack))

async function run() {
    const start = Date.now()
    await new MyPromise(resolve =&gt; setTimeout(() =&gt; resolve(), 100))
    console.log('Elapsed time', Date.now() - start)
}
</code></pre>

<p>注意上面的 <code>.catch()</code> 调用。<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch"><code>catch()</code> 函数</a>是 ES6 promise 规范的核心部分。本文不会详细讲述它，因为 <code>.catch(f)</code> 相当于 <code>.then(null, f)</code>，没有什么特别的内容。</p>

<p>以下是输出内容，注意 await 隐式调用 <code>.then()</code> 中的 <code>onFulfilled()</code> 和 <code>onRejected()</code> 函数，这是 V8 底层的 C++ 代码（native code）。此外，<code>await</code> 会一直等待调用 <code>.then()</code> 直到下一个时序。</p>

<pre><code>Then function () { [native code] } function () { [native code] } Error
    at MyPromise.then (/home/val/test/promise.js:63:50)
    at process._tickCallback (internal/process/next_tick.js:188:7)
    at Function.Module.runMain (module.js:686:11)
    at startup (bootstrap_node.js:187:16)
    at bootstrap_node.js:608:3
Elapsed time 102
</code></pre>

<h2>更多</h2>

<p><a href="http://thecodebarbarian.com/common-async-await-design-patterns-in-node.js.html">async/await</a> 是非常强大的特性，但掌握起来稍微有点困难，因为需要使用者了解 promise 的基本原则。 promise 有很多细节，例如捕获处理器函数中的同步错误，以及 promise 一旦解决就无法改变状态，这使得 async/await 成为可能。一旦对 promise 有了充分的理解，async/await 就会变得容易得多。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[魔幻语言 JavaScript 系列之类型转换、宽松相等以及原始值]]></title>
    <link href="http://blog.mirreal.net/blog/2018/04/12/looking-into-assembly-code-of-coercion/"/>
    <updated>2018-04-12T10:18:01+08:00</updated>
    <id>http://blog.mirreal.net/blog/2018/04/12/looking-into-assembly-code-of-coercion</id>
    <content type="html"><![CDATA[<blockquote><p>编译自：<a href="https://wanago.io/2018/04/02/1-2-3-9-looking-into-assembly-code-of-coercion/"><code>[1] + [2] – [3] === 9</code>!? Looking into assembly code of coercion.</a></p>

<p>全文从两个题目来介绍类型转换、宽松相等以及原始值的概念:</p>

<p>[1] + [2] – [3] === 9</p>

<p>如果让 a == true &amp;&amp; a == false 的值为 true</p>

<p>第二道题目是译者加的，因为这其实是个很好的例子，体现出 JavaScript 的魔幻之处</p></blockquote>

<p>变量值都具有类型，但仍然可以将一种类型的值赋值给另一种类型，如果是由开发者进行这些操作，就是<strong>类型转换</strong>（显式转换）。如果是发生在后台，比如在尝试对不一致的类型执行操作时，就是<strong>隐式转换</strong>（强制转换）。</p>

<h2>类型转换（Type casting）</h2>

<h3>基本包装类型（Primitive types wrappers）</h3>

<p>在 JavaScript 中除了 <code>null</code> 和 <code>undefined</code> 之外的所有基本类型都有一个对应的基本包装类型。通过使用其构造函数，可以将一个值的类型转换为另一种类型。</p>

<pre><code class="js">String(123); // '123'
Boolean(123); // true
Number('123'); // 123
Number(true); // 1
</code></pre>

<blockquote><p>基本类型的包装器不会保存很长时间，一旦完成相应工作，就会消失</p></blockquote>

<p>需要注意的是，如果在构造函数前使用 <code>new</code> 关键字，结果就完全不同，比如下面的例子：</p>

<pre><code class="js">const bool = new Boolean(false);
bool.propertyName = 'propertyValue';
bool.valueOf(); // false

if (bool) {
  console.log(bool.propertyName); // 'propertyValue'
}
</code></pre>

<p>由于 <code>bool</code> 在这里是一个新的对象，已经不再是基本类型值，它的计算结果为 <code>true</code>。</p>

<p>上述例子，因为在 if 语句中，括号间的表达式将会装换成布尔值，比如</p>

<pre><code class="js">if (1) {
    console.log(true);
}
</code></pre>

<p>其实，上面这段代码跟下面一样：</p>

<pre><code class="js">if ( Boolean(1) ) {
    console.log(true);
}
</code></pre>

<h3>parseFloat</h3>

<p><code>parseFloat</code> 函数的功能跟 <code>Number</code> 构造函数类似，但对于传参并没有那么严格。当它遇到不能转换成数字的字符，将返回一个到该点的值并忽略其余字符。</p>

<pre><code class="js">Number('123a45'); // NaN
parseFloat('123a45'); // 123
</code></pre>

<h3>parseInt</h3>

<p><code>parseInt</code> 函数在解析时将会对数字进行向下取整，并且可以使用不同的进制。</p>

<pre><code class="js">parseInt('1111', 2); // 15
parseInt('0xF'); // 15

parseFloat('0xF'); // 0
</code></pre>

<p><code>parseInt</code> 函数可以猜测进制，或着你可以显式地通过第二个参数传入进制，参考 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt">MDN web docs</a>。</p>

<p>而且不能正常处理大数，所以不应该成为 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/floor"><strong>Math.floor</strong></a> 的替代品，是的，<code>Math.floor</code> 也会进行类型转换：</p>

<pre><code class="js">parseInt('1.261e7'); // 1
Number('1.261e7'); // 12610000
Math.floor('1.261e7') // 12610000

Math.floor(true) // 1
</code></pre>

<h3>toString</h3>

<p>可以使用 <strong>toString</strong> 函数将值转换为字符串，但是在不同原型之间的实现有所不同。</p>

<p><strong>String.prototype.toString</strong></p>

<p>返回字符串的值</p>

<pre><code class="js">const dogName = 'Fluffy';

dogName.toString() // 'Fluffy'
String.prototype.toString.call('Fluffy') // 'Fluffy'

String.prototype.toString.call({}) // Uncaught TypeError: String.prototype.toString requires that 'this' be a String
</code></pre>

<p><strong>Number.prototype.toString</strong></p>

<p>返回将数字的字符串表示形式，可以指定进制作为第一个参数传入</p>

<pre><code class="js">(15).toString(); // "15"
(15).toString(2); // "1111"
(-15).toString(2); // "-1111"
</code></pre>

<p><strong>Symbol .prototype.toString</strong></p>

<p>返回  <code>Symbol（${description}）</code></p>

<p><strong>Boolean.prototype.toString</strong></p>

<p>返回 <code>“true”</code> 或 <code>“false”</code></p>

<p><strong>Object.prototype.toString</strong></p>

<p>返回一个字符串 <code>[ object $ { tag } ]</code> ，其中 tag 可以是内置类型比如 “Array”，“String”，“Object”，“Date”，也可以是自定义 tag。</p>

<pre><code class="js">const dogName = 'Fluffy';

dogName.toString(); // 'Fluffy' (String.prototype.toString called here)
Object.prototype.toString.call(dogName); // '[object String]'
</code></pre>

<p>随着 ES6 的推出，还可以使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol"><strong>Symbol</strong></a> 进行自定义 tag。</p>

<pre><code class="js">const dog = { name: 'Fluffy' }
console.log( dog.toString() ) // '[object Object]'

dog[Symbol.toStringTag] = 'Dog';
console.log( dog.toString() ) // '[object Dog]'
</code></pre>

<p>或者</p>

<pre><code class="js">const Dog = function(name) {
  this.name = name;
}
Dog.prototype[Symbol.toStringTag] = 'Dog';

const dog = new Dog('Fluffy');
dog.toString(); // '[object Dog]'
</code></pre>

<p>还可以结合使用 ES6 class 和 getter：</p>

<pre><code class="js">class Dog {
  constructor(name) {
    this.name = name;
  }
  get [Symbol.toStringTag]() {
    return 'Dog';
  }
}

const dog = new Dog('Fluffy');
dog.toString(); // '[object Dog]'
</code></pre>

<p><strong>Array.prototype.toString</strong></p>

<p>在每个元素上调用 <code>toString</code>，并返回一个字符串，并且以逗号分隔。</p>

<pre><code class="js">const arr = [
  {},
  2,
  3
]

arr.toString() // "[object Object],2,3"
</code></pre>

<h2>强制转换</h2>

<p>如果了解类型转换的工作原理，那么理解强制转换就会容易很多。</p>

<h3>数学运算符</h3>

<p><strong>加号运算符</strong></p>

<p>在作为二元运算符的 <code>+</code> 如果两边的表达式存在字符串，最后将会返回一个字符串。</p>

<pre><code class="js">'2' + 2 // '22'
15 + '' // '15'
</code></pre>

<p>可以使用一元运算符将其转换为数字：</p>

<pre><code class="js">+'12' // 12
</code></pre>

<p><strong>其他数学运算符</strong></p>

<p>其他数学运算符（如 <code>-</code>或 <code>/</code>）将始终转换为数字。</p>

<pre><code class="js">new Date('04-02-2018') - '1' // 1522619999999
'12' / '6' // 2
-'1' // -1
</code></pre>

<p>上述例子中，Date 类型将转换为数字，即 <a href="https://en.wikipedia.org/wiki/Unix_time">Unix 时间戳</a>。</p>

<h3>逻辑非</h3>

<p>如果原始值是 <em>假</em>，则使用逻辑非将输出 <em>真</em>，如果 <em>真</em>，则输出为 <em>假</em>。 如果使用两次，可用于将该值转换为相应的布尔值。</p>

<pre><code class="js">!1 // false
!!({}) // true
</code></pre>

<h3>位或</h3>

<p>值得一提的是，即使 ToInt32 实际上是一个抽象操作（仅限内部，不可调用），将一个值转换为一个<a href="https://en.wikipedia.org/wiki/32-bit">有符号的 32 位整数</a>。</p>

<pre><code class="js">0 | true          // 1
0 | '123'         // 123
0 | '2147483647'  // 2147483647
0 | '2147483648'  // -2147483648 (too big)
0 | '-2147483648' // -2147483648
0 | '-2147483649' // 2147483647 (too small)
0 | Infinity      // 0
</code></pre>

<p>当其中一个操作数为 0 时执行按位或操作将不改变另一个操作数的值。</p>

<h3>其他情况下的强制转换</h3>

<p>在编码时，可能会遇到更多强制转换的情况，比如这个例子：</p>

<pre><code class="js">const foo = {};
const bar = {};
const x = {};

x[foo] = 'foo';
x[bar] = 'bar';

console.log(x[foo]); // "bar"
</code></pre>

<p>发生这种情况是因为 <code>foo</code> 和 <code>bar</code> 在转换为字符串的结果均为 <code>“[object Object]”</code>。就像这样：</p>

<pre><code class="js">x[bar.toString()] = 'bar';
x["[object Object]"]; // "bar"
</code></pre>

<p>使用<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals">模板字符串</a>的时候也会发生强制转换，在下面例子中重写 <code>toString</code> 函数：</p>

<pre><code class="js">const Dog = function(name) {
  this.name = name;
}
Dog.prototype.toString = function() {
  return this.name;
}

const dog = new Dog('Fluffy');
console.log(`${dog} is a good dog!`); // "Fluffy is a good dog!"
</code></pre>

<p>正因为如此，<strong>宽松相等</strong>（==）被认为是一种不好的做法，如果两边类型不一致，就会试图进行强制隐式转换。</p>

<p>看下面这个有趣的例子：</p>

<pre><code class="js">const foo = new String('foo');
const foo2 = new String('foo');

foo === foo2 // false
foo &gt;= foo2 // true
</code></pre>

<p>在这里我们使用了 <code>new</code> 关键字，所以 <code>foo</code> 和 <code>foo2</code> 都是字符串包装类型，原始值都是 <code>foo</code> 。但是，它们现在引用了两个不同的对象，所以 <code>foo === foo2</code> 将返回 <code>false</code>。这里的关系运算符 <code>&gt;=</code> 会在两个操作数上调用 <code>valueOf</code> 函数，因此比较的是它们的原始值，<code>'foo' &gt; = 'foo'</code> 的结果为 <code>true</code>。</p>

<h2>[1] + [2] - [3] === 9</h2>

<p>希望这些知识都能帮助揭开这个题目的神秘面纱</p>

<ol>
<li><code>[1] + [2]</code> 将调用 <code>Array.prototype.toString</code> 转换为字符串，然后进行字符串拼接。结果将是 <code>“12”</code>

<ul>
<li><code>[1,2] + [3,4]</code> 的值讲师 <code>“1,23,4”</code></li>
</ul>
</li>
<li><code>12 - [3]</code>，减号运算符会将值转换为 Number 类型，所以等于 <code>12-3</code>，结果为 <code>9</code>

<ul>
<li>12 - [3,4] 的值是 <code>NaN</code>，因为<code>"3,4"</code> 不能被转换为 Number</li>
</ul>
</li>
</ol>


<h2>总结</h2>

<p>尽管很多人会建议尽量避免强制隐式转换，但了解它的工作原理非常重要，在调试代码和避免错误方面大有帮助。</p>

<p>【译文完】</p>

<h2>再谈点，关于宽松相等和原始值</h2>

<p>这里看另一道题目，在 JavaScript 环境下，能否让表达式 <code>a == true &amp;&amp; a == false</code> 为 <code>true</code>。</p>

<p>就像下面这样，在控制台打印出 <code>’yeah'</code>:</p>

<pre><code class="js">// code here
if (a == true &amp;&amp; a == false) {
    console.log('yeah');
}
</code></pre>

<p>关于宽松相等（==），先看看 ECMA 5.1 的规范，包含 <code>toPrimitive</code>:</p>

<ul>
<li><a href="http://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3">11.9.3</a> The Abstract Equality Comparison Algorithm</li>
<li><a href="http://www.ecma-international.org/ecma-262/5.1/#sec-9.1">9.1</a> ToPrimitive</li>
</ul>


<h3>稍作总结</h3>

<p>规范很长很详细，简单总结就是，对于下述表达式：</p>

<pre><code class="js">x == y
</code></pre>

<ul>
<li>类型相同，判断的就是 x === y</li>
<li>类型不同

<ul>
<li>如果 x，y 其中一个是布尔值，将这个布尔值进行 ToNumber 操作</li>
<li>如果 x，y 其中一个是字符串，将这个字符串进行 ToNumber 操作</li>
<li>若果 x，y 一方为对象，将这个对象进行 ToPrimitive 操作</li>
</ul>
</li>
</ul>


<p>至于 <code>ToPrimitive</code>，即求原始值，可以简单理解为进行 <code>valueOf()</code> 和 <code>toString()</code> 操作。</p>

<p>稍后我们再详细剖析，接下来先看一个问题。</p>

<h3>Question：是否存在这样一个变量，满足 x == !x</h3>

<p>就像这样：</p>

<pre><code class="js">// code here
if (x == !x) {
    console.log('yeah');
}
</code></pre>

<p>可能很多人会想到下面这个，毕竟我们也曾热衷于各种奇技淫巧：</p>

<pre><code class="js">[] == ![] // true
</code></pre>

<p>但答案绝不仅仅局限于此，比如：</p>

<pre><code class="js">var x = new Boolean(false);

if (x == !x) {
    console.log('yeah');
}
// x.valueOf() -&gt; false
// x is a object, so: !x -&gt; false


var y = new Number(0);
y == !y // true
// y.valueOf() -&gt; 0
// !y -&gt; false
// 0 === Number(false) // true
// 0 == false // true
</code></pre>

<p>理解这个问题，那下面的这些例子都不是问题了：</p>

<pre><code class="js">[] == ![]
[] == {}
[] == !{}
{} == ![]
{} == !{}
</code></pre>

<p>在来看看什么是 <code>ToPrimitive</code></p>

<h3>ToPrimitive</h3>

<p>看规范：<a href="http://www.ecma-international.org/ecma-262/5.1/#sec-8.12.8">8.12.8</a> <code>[[DefaultValue]] (hint)</code></p>

<p>如果是 <code>Date</code> 求原始值，则 hint 是 <code>String</code>，其他均为 <code>Number</code>，即先调用 <code>valueOf()</code> 再调用 <code>toString()</code>。</p>

<p>如果 hint 为 <code>Number</code>，具体过程如下：</p>

<ol>
<li>调用对象的 <code>valueOf()</code> 方法，如果值是原值则返回</li>
<li>否则，调用对象的 <code>toString()</code> 方法，如果值是原值则返回</li>
<li>否则，抛出 TypeError 错误</li>
</ol>


<pre><code class="js">// valueOf 和 toString 的调用顺序
var a = {
    valueOf() {
        console.log('valueof')
        return []
    },
    toString() {
        console.log('toString')
        return {}
    }
}

a == 0
// valueof
// toString
// Uncaught TypeError: Cannot convert object to primitive value


// Date 类型先 toString，后 valueOf
var t = new Date('2018/04/01');
t.valueOf = function() {
    console.log('valueof')
    return []
}
t.toString = function() {
    console.log('toString')
    return {}
}
t == 0
// toString
// valueof
// Uncaught TypeError: Cannot convert object to primitive value
</code></pre>

<p>到目前为止，上面的都是 ES5 的规范，那么在 ES6 中，有什么变化呢</p>

<h3>ES6 中 ToPrimitive</h3>

<p><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-toprimitive">7.1.1</a>ToPrimitive ( input [, PreferredType] )</p>

<p>在 ES6 中吗，是可以自定义 <code>@@toPrimitive</code> 方法的，这是 Well-Known Symbols(<a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-well-known-symbols">§6.1.5.1</a>)中的一个。JavaScript 内建了一些在 ECMAScript 5 之前没有暴露给开发者的 symbol，它们代表了内部语言行为。</p>

<p>来自 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive">MDN</a> 的例子：</p>

<pre><code class="js">// 没有 Symbol.toPrimitive 属性的对象
var obj1 = {};
console.log(+obj1); // NaN
console.log(`${obj1}`); // '[object Object]'
console.log(obj1 + ''); // '[object Object]'

// 拥有 Symbol.toPrimitive 属性的对象
var obj2 = {
    [Symbol.toPrimitive](hint) {
        if (hint == 'number') {
            return 10;
        }
        if (hint == 'string') {
            return 'hello';
        }
        return true;
    }
};
console.log(+obj2); // 10 -- hint is 'number'
console.log(`${obj2}`); // 'hello' -- hint is 'string'
console.log(obj2 + ''); // 'true' -- hint is 'default'
</code></pre>

<p>有了上述铺垫，答案就呼之欲出了</p>

<h3><code>a == true &amp;&amp; a == false</code> 为 <code>true</code> 的答案</h3>

<pre><code class="js">var a = {
    flag: false,
    toString() {
        return this.flag = !this.flag;
    }
}
</code></pre>

<p>或者使用 <code>valueOf()</code>：</p>

<pre><code class="js">var a = {
    flag: false,
    valueOf() {
        return this.flag = !this.flag;
    }
}
</code></pre>

<p>或者是直接改变 ToPrimitive 行为：</p>

<pre><code class="js">// 其实只需设置 default 即可
var a = {
    flag: false,
    [Symbol.toPrimitive](hint) {
        if (hint === 'number') {
            return 10
        }
        if (hint === 'string') {
            return 'hello'
        }
        return this.flag = !this.flag
    }
}
</code></pre>

<h3>如果是严格相等呢</h3>

<p>这个问题在严格相等的情况下，也是能够成立的，这又是另外的知识点了，使用 <code>defineProperty</code> 就能实现：</p>

<pre><code class="js">let flag = false
Object.defineProperty(window, 'a', {
    get() {
        return (flag = !flag)
    }
})

if (a === true &amp;&amp; a === false) {
    console.log('yeah');
}
</code></pre>

<h3>阅读更多</h3>

<ul>
<li><a href="https://stackoverflow.com/questions/48270127/can-a-1-a-2-a-3-ever-evaluate-to-true">Can (a== 1 &amp;&amp; a ==2 &amp;&amp; a==3) ever evaluate to true?</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React 整洁代码最佳实践]]></title>
    <link href="http://blog.mirreal.net/blog/2017/12/01/clean-code-vs-dirty-code-react-best-practices/"/>
    <updated>2017-12-01T08:53:45+08:00</updated>
    <id>http://blog.mirreal.net/blog/2017/12/01/clean-code-vs-dirty-code-react-best-practices</id>
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="http://americanexpress.io/clean-code-dirty-code/">Clean Code vs. Dirty Code: React Best Practices</a></p>

<p>作者：Donavon West</p></blockquote>

<p>本文主要介绍了适用于现代 React 软件开发的整洁代码实践，顺便谈谈 ES6/ES2015 带来的一些好用的“语法糖”。</p>

<h2>什么是整洁代码，为什么要在乎？</h2>

<p>整洁代码代表的是一种一致的编码风格，目的是让代码更易于编写，阅读和维护。通常情况下，开发者在解决问题的时候，一旦问题解决就发起一个 Pull Request（译注：合并请求，在 Gitlab 上叫 Merge Request）。但我认为，这时候工作并没有真正完成，我们不能仅仅满足于代码可以工作。</p>

<p>这时候其实就是整理代码的最好时机，可以通过删除死代码（僵尸代码），重构以及删除注释掉的代码，来保持代码的可维护性。不妨问问自己，“从现在开始再过六个月，其他人还能理解这些代码吗？”简而言之，对于自己编写的代码，你应该保证能很自豪地拿给别人看。</p>

<p>至于为什么要在乎这点？因为我们常说一个优秀的开发者大都比较”懒“。在遇到需要重复做某些事情的情况下，他们会去找到一个自动化（或更好的）解决方案来完成这些任务。</p>

<h3>整洁代码能够通过“味道测试”</h3>

<p>整洁代码应该可以通过“味道测试”。什么意思呢？我们在看代码的时候，包括我们自己写的或或是别人的，会说：“这里不太对劲。”如果感觉不对，那可能就真的是有问题的。如果你觉得你正在试图把一个方形钉子装进一个圆形的洞里，那么就暂停一下，然后休息一下。多次尝试之后，你会找到一个更好的解决方案。</p>

<h3>整洁代码是符合 DRY 原则的</h3>

<p>DRY 是一个缩略词，意思是“不要重复自己”（Don’t Repeat Yourself）。如果发现多个地方在做同样的事情，那么这时候就应该合并重复代码。如果在代码中看到了模式，那么表明需要实行 DRY。</p>

<pre><code class="js">// Dirty
const MyComponent = () =&gt; (
  &lt;div&gt;
    &lt;OtherComponent type="a" className="colorful" foo={123} bar={456} /&gt;
    &lt;OtherComponent type="b" className="colorful" foo={123} bar={456} /&gt;    
  &lt;/div&gt;
);
</code></pre>

<pre><code class="js">// Clean
const MyOtherComponent = ({ type }) =&gt; (
  &lt;OtherComponent type={type} className="colorful" foo={123} bar={456} /&gt;
);
const MyComponent = () =&gt; (
  &lt;div&gt;
    &lt;MyOtherComponent type="a" /&gt;
    &lt;MyOtherComponent type="b" /&gt;
  &lt;/div&gt;
);
</code></pre>

<p>有时候，比如在上面的例子中，实行 DRY 原则反而可能会增加代码量。但是，DRY 通常也能够提高代码的可维护性。</p>

<p>注意，很容易陷入过分使用 DRY 原则的陷阱，应该学会适可而止。</p>

<h3>整洁代码是可预测和可测试的</h3>

<p>编写单元测试不仅仅只是一个好想法，而且应该是强制性的。不然，怎么能确保新功能不会在其他地方引起 Bug 呢？</p>

<p>许多 React 开发人员选择 <a href="https://facebook.github.io/jest/">Jest</a> 作为一个零配置测试运行器，然后生成代码覆盖率报告。如果对测试前后对比可视化感兴趣，请查看美国运通的 <a href="https://github.com/americanexpress/jest-image-snapshot">Jest Image snanshot</a>。</p>

<h3>整洁代码是自注释的</h3>

<p>以前发生过这种情况吗？你写了一些代码，并且包含详细的注释。后来你发现一个 bug，于是回去修改代码。但是，你有没有改变注释来体现新的逻辑？也许会，也许不会。下一个看你代码的人可能因为注意到这些注释而掉进一个陷阱。</p>

<p>注释只是为了解释复杂的想法，也就是说，不要对显而易见的代码进行注释。同时，更少的注释也减少了视觉上的干扰。</p>

<pre><code class="js">// Dirty
const fetchUser = (id) =&gt; (
  fetch(buildUri`/users/${id}`) // Get User DTO record from REST API
    .then(convertFormat) // Convert to snakeCase
    .then(validateUser) // Make sure the the user is valid
);
</code></pre>

<p>在整洁代码的版本中，我们对一些函数进行重命名，以便更好地描述它们的功能，从而消除注释的必要性，减少视觉干扰。并且避免后续因代码与注释不匹配导致的混淆。</p>

<pre><code class="js">// Clean
const fetchUser = (id) =&gt; (
  fetch(buildUri`/users/${id}`)
    .then(snakeToCamelCase)
    .then(validateUser)
);
</code></pre>

<h3>命名</h3>

<p>在我之前的文章 <a href="http://americanexpress.io/faccs-are-an-antipattern">将函数作为子组件是一种反模式</a>，强调了命名的重要性。每个开发者都应该认真考虑变量名，函数名，甚至是文件名。</p>

<p>这里列举一下命名原则：</p>

<ul>
<li><p>布尔变量或返回布尔值的函数应该以“is”，“has”或“should”开头。</p>

<pre><code class="js">// Dirty
const done = current &gt;= goal;
</code></pre>

<pre><code class="js">// Clean
const isComplete = current &gt;= goal;
</code></pre></li>
<li><p>函数命名应该体现做了什么，而不是是怎样做的。换言之，不要在命名中体现出实现细节。假如有天出现变化，就不需要因此而重构引用该函数的代码。比如，今天可能会从 REST API 加载配置，但是可能明天就会将其直接写入到 JavaScript 中。</p>

<pre><code class="js">// Dirty
const loadConfigFromServer = () =&gt; {
  ...
};
</code></pre>

<pre><code class="js">// Clean
const loadConfig = () =&gt; {
  ...
};
</code></pre></li>
</ul>


<h3>整洁代码遵循成熟的设计模式和最佳实践</h3>

<p>计算机已经存在很长一段时间了。多年以来，程序员通过解决某些特定问题，发现了一些固有套路，被称为设计模式。换言之，有些算法已经被证明是可以工作的，所以应该站在前人的肩膀上，避免犯同样的错误。</p>

<p>那么，什么是最佳实践，与设计模式类似，但是适用范围更广，不仅仅针对编码算法。比如，“应该对代码进行静态检查”或者“当编写一个库时，应该将 React 作为 <code>peerDependency</code>”，这些都可以称为最佳实践。</p>

<p>构建 React 应用程序时，应该遵循以下最佳实践：</p>

<ul>
<li>使用小函数，每个函数具备单一功能，即所谓的单一职责原则（Single responsibility principle）。确保每个函数都能完成一项工作，并做得很好。这样就能将复杂的组件分解成许多较小的组件。同时，将具备更好的可测试性。</li>
<li>小心抽象泄露（leaky abstractions）。换言之，不要强迫消费方去了解内部代码实现细节。</li>
<li>遵循严格的代码检查规则。这将有助于编写整洁，一致的代码。</li>
</ul>


<h3>整洁代码不需要花长时间来编写</h3>

<p>总会听到这样的说法：编写整洁代码会降低生产力。简直是在胡说八道。是的，可能刚开始需要放慢速度，但最终会随着编写更少的代码而节奏加快。</p>

<p>而且，不要小看代码评审导致的重写重构，以及修复问题花费的时间。如果把代码分解成小的模块，每个模块都是单一职责，那么很可能以后再也不用去碰大多数模块了。时间就省下来了，也就是说 “write it and forget it”。</p>

<h2>槽糕代码与整洁代码的实例</h2>

<h3>使用 DRY 原则</h3>

<p>看看下面的代码示例。如上所述，从你的显示器退后一步，发现什么模式了吗？注意 <code>Thingie</code> 组件与 <code>ThingieWithTitle</code> 组件除了 <code>Title</code> 组件几乎完全相同，这是实行 DRY 原则的最佳情形。</p>

<pre><code class="js">// Dirty
import Title from './Title';

export const Thingie = ({ description }) =&gt; (
  &lt;div class="thingie"&gt;
    &lt;div class="description-wrapper"&gt;
      &lt;Description value={description} /&gt;
    &lt;/div&gt;
  &lt;/div&gt;
);

export const ThingieWithTitle = ({ title, description }) =&gt; (
  &lt;div&gt;
    &lt;Title value={title} /&gt;
    &lt;div class="description-wrapper"&gt;
      &lt;Description value={description} /&gt;
    &lt;/div&gt;
  &lt;/div&gt;
);
</code></pre>

<p>在这里，我们将 <code>children</code> 传递给 <code>Thingie</code>。然后创建 <code>ThingieWithTitle</code>，这个组件包含 <code>Thingie</code>，并将 <code>Title</code> 作为其子组件传给 <code>Thingie</code>。</p>

<pre><code class="js">// Clean
import Title from './Title';

export const Thingie = ({ description, children }) =&gt; (
  &lt;div class="thingie"&gt;
    {children}
    &lt;div class="description-wrapper"&gt;
      &lt;Description value={description} /&gt;
    &lt;/div&gt;
  &lt;/div&gt;
);

export const ThingieWithTitle = ({ title, ...others }) =&gt; (
  &lt;Thingie {...others}&gt;
    &lt;Title value={title} /&gt;
  &lt;/Thingie&gt;
);
</code></pre>

<h3>默认值</h3>

<p>看看下面的代码。使用逻辑或将 <code>className</code> 的默认值设置成 “icon-large”，看起来像是上个世纪的人才会写的代码。</p>

<pre><code class="js">// Dirty
const Icon = ({ className, onClick }) =&gt; {
  const additionalClasses = className || 'icon-large';

  return (
    &lt;span
      className={`icon-hover ${additionalClasses}`}
      onClick={onClick}&gt;
    &lt;/span&gt;
  );
};
</code></pre>

<p>这里我们使用 ES6 的默认语法来替换 <code>undefined</code> 时的值，而且还能使用 ES6 的箭头函数表达式写成单一语句形式，从而去除对 <code>return</code> 的依赖。</p>

<pre><code class="js">// Clean
const Icon = ({ className = 'icon-large', onClick }) =&gt; (
  &lt;span className={`icon-hover ${className}`} onClick={onClick} /&gt;
);
</code></pre>

<p>在下面这个更整洁的版本中，使用 React 中的 API 来设置默认值。</p>

<pre><code class="js">// Cleaner
const Icon = ({ className, onClick }) =&gt; (
  &lt;span className={`icon-hover ${className}`} onClick={onClick} /&gt;
);

Icon.defaultProps = {
  className: 'icon-large',
};
</code></pre>

<p>为什么这样显得更加整洁？而且它真的会更好吗？三个版本不是都在做同样的事情吗？某种意义上来说，是对的。让 React 设置 prop 默认值的好处是，可以产生更高效的代码，而且在基于 <code>Class</code> 的生命周期组件中允许通过 <code>propTypes</code> 检查默认值。还有一个优点是：将默认逻辑从组件本身抽离出来。</p>

<p>例如，你可以执行以下操作，将所有默认属性放到一个地方。当然，并不是建议你这样做，只是说具有这样的灵活性。</p>

<pre><code class="js">import defaultProps from './defaultProps';
// ...
Icon.defaultProps = defaultProps.Icon;
</code></pre>

<h3>从渲染分离有状态的部分</h3>

<p>将有状态的数据加载逻辑与渲染逻辑混合可能增加组件复杂性。更好的方式是，写一个负责完成数据加载的有状态的容器组件，然后编写另一个负责显示数据的组件。这被称为 <a href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0">容器模式</a>。</p>

<p>在下面的示例中，用户数据加载和显示功能放在一个组件中。</p>

<pre><code class="js">// Dirty
class User extends Component {
  state = { loading: true };

  render() {
    const { loading, user } = this.state;
    return loading
      ? &lt;div&gt;Loading...&lt;/div&gt;
      : &lt;div&gt;
          &lt;div&gt;
            First name: {user.firstName}
          &lt;/div&gt;
          &lt;div&gt;
            First name: {user.lastName}
          &lt;/div&gt;
          ...
        &lt;/div&gt;;
  }

  componentDidMount() {
    fetchUser(this.props.id)
      .then((user) =&gt; { this.setState({ loading: false, user })})
  }
}
</code></pre>

<p>在整洁版本中，加载数据和显示数据已经分离。这不仅使代码更容易理解，而且能减少测试的工作量，因为可以独立测试每个部分。而且由于 <code>RenderUser</code> 是一个无状态组件，所以结果是可预测的。</p>

<pre><code class="js">// Clean
import RenderUser from './RenderUser';

class User extends Component {
  state = { loading: true };

  render() {
    const { loading, user } = this.state;
    return loading ? &lt;Loading /&gt; : &lt;RenderUser user={user} /&gt;;
  }

  componentDidMount() {
    fetchUser(this.props.id)
      .then(user =&gt; { this.setState({ loading: false, user })})
  }
}
</code></pre>

<h3>使用无状态组件</h3>

<p>React v0.14.0 中引入了无状态函数组件（SFC），被简化成纯渲染组件，但有些开发者还在使用过去的方式。例如，以下组件就应该转换为 SFC。</p>

<pre><code class="js">// Dirty
class TableRowWrapper extends Component {
  render() {
    return (
      &lt;tr&gt;
        {this.props.children}
      &lt;/tr&gt;
    );
  }
}
</code></pre>

<p>整洁版本清除了很多可能导致干扰的信息。通过 React 核心的优化，使用无状态组件将占用更少的内存，因为没有创建 Component 实例。</p>

<pre><code class="js">// Clean
const TableRowWrapper = ({ children }) =&gt; (
  &lt;tr&gt;
    {children}
  &lt;/tr&gt;
);
</code></pre>

<h3>剩余/扩展属性（rest/spread）</h3>

<p>大约在一年前，我还推荐大家多用 <code>Object.assign</code>。但时代变化很快，在 ES2016/ES7 中引入新特性 <a href="https://github.com/tc39/proposal-object-rest-spread">rest/spread</a>。</p>

<p>比如这样一种场景，当传递给一些 props 给一个组件，只希望在组件本身使用 <code>className</code>，但是需要将其他所有 props 传递到子组件。这时，你可能会这样做：</p>

<pre><code class="js">// Dirty
const MyComponent = (props) =&gt; {
  const others = Object.assign({}, props);
  delete others.className;

  return (
    &lt;div className={props.className}&gt;
      {React.createElement(MyOtherComponent, others)}
    &lt;/div&gt;
  );
};
</code></pre>

<p>这不是一个非常优雅的解决方案。但是使用 rest/spread，就能轻而易举地实现，</p>

<pre><code class="js">// Clean
const MyComponent = ({ className, ...others }) =&gt; (
  &lt;div className={className}&gt;
    &lt;MyOtherComponent {...others} /&gt;
  &lt;/div&gt;
);
</code></pre>

<p>我们将剩余属性展开并作为新的 props 传递给 <code>MyOtherComponent</code> 组件。</p>

<h3>合理使用解构</h3>

<p>ES6 引入 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">解构</a>（destructuring） 的概念，这是一个非常棒的特性，用类似对象或数组字面量的语法获取一个对象的属性或一个数组的元素。</p>

<h4>对象解构</h4>

<p>在这个例子中，<code>componentWillReceiveProps</code> 组件接收 <code>newProps</code> 参数，然后将其 <code>active</code> 属性设置为新的 <code>state.active</code>。</p>

<pre><code class="js">// Dirty
componentWillReceiveProps(newProps) {
  this.setState({
    active: newProps.active
  });
}
</code></pre>

<p>在整洁版本中，我们解构 <code>newProps</code>成 <code>active</code>。这样我们不仅不需要引用 <code>newProps.active</code>，而且也可以使用 ES6 的简短属性特性来调用 <code>setState</code>。</p>

<pre><code>// Clean
componentWillReceiveProps({ active }) {
  this.setState({ active });
}
</code></pre>

<h4>数组解构</h4>

<p>一个经常被忽视的 ES6 特性是数组解构。以下面的代码为例，它获取 <code>locale</code> 的值，比如“en-US”，并将其分成 <code>language</code>（en）和 <code>country</code>（US）。</p>

<pre><code class="js">// Dirty
const splitLocale = locale.split('-');
const language = splitLocale[0];
const country = splitLocale[1];
</code></pre>

<p>在整洁版本，使用 ES6 的数组解构特性可以自动完成上述过程：</p>

<pre><code class="js">// Clean
const [language, country] = locale.split('-');
</code></pre>

<h2>所以结论是</h2>

<p>希望这篇文章能有助于你看到编写整洁代码的好处，甚至可以直接使用这里介绍的一些代码示例。一旦你习惯编写整洁代码，将很快就会体会到 “write it and forget it” 的生活方式。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[魔幻语言 JavaScript 系列之 Call、bind 以及上下文]]></title>
    <link href="http://blog.mirreal.net/blog/2017/11/09/call-apply-and-context-in-javascript/"/>
    <updated>2017-11-09T14:24:57+08:00</updated>
    <id>http://blog.mirreal.net/blog/2017/11/09/call-apply-and-context-in-javascript</id>
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="http://blog.bloomca.me/2017/11/08/the-most-clever-line-of-javascript.html">The Most Clever Line of JavaScript</a></p>

<p>作者：<a href="https://twitter.com/blooomca">Seva Zaikov</a></p></blockquote>

<h2>原文</h2>

<p>最近 <a href="https://twitter.com/vedroarbuzov">一个朋友</a> 发给我一段非常有趣的 JavaScript 代码，是他在某个 <a href="https://github.com/pelias/openstreetmap/blob/313f208ea323232919e42bf88871d8e19ddacec3/stream/address_extractor.js#L54">开源库中</a> 看到的：</p>

<pre><code class="javascript">addressParts.map(Function.prototype.call, String.prototype.trim);
</code></pre>

<p>一开始，我觉得这是一个“不错的尝试”。但是，印象中 <code>map</code> 好像只接受一个参数，这里却出现第二个参数，所以去查看了 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map">MDN文档</a>，才知道可以传一个上下文（context）作为第二个参数。在这时候，我还无法解释这段代码，运行完之后感到更加困惑了，因为它竟然能如预期那样工作。</p>

<p>我花了至少半个小时来尝试理解这段代码，这是一个很有趣的例子，可以用来说明 JavaScript 是一门多么魔幻的语言，即使已经写了好几年的 JS。当然，你可以选择自己去弄清楚，如果想看看我的理解，请继续阅读。</p>

<p>那么，它到底是如何工作的呢？让我们从一种更简单的实现开始（实际上这种实现代码更短，并且更易读:)）：</p>

<pre><code class="javascript">addressParts.map(str =&gt; str.trim());
</code></pre>

<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call">Function.prototype.call</a> 是 JavaScript 函数原型中的一个函数，它调用函数，使用第一个参数作为 <code>this</code> 参数，并传递剩余参数作为被调用函数的参数。举个例子：</p>

<pre><code class="javascript">// this function has `Function` in prototype chain
// so `call` is available
function multiply(x, y) {
  return x * y;
}

multiply.call(null, 3, 5); // 15
multiply(3, 5); // same, 15
</code></pre>

<p><code>map</code> 第二个参数的典型用法如下所示，假设有一个基于类的 React 组件，其功能是渲染一个按钮列表：</p>

<pre><code class="javascript">class ExampleComponent extends Component {
  renderButton({ title, name }) {
    // without proper `this` it will fail
    const { isActive } = this.props;
    return (
      &lt;Button key={title} title={title}&gt;
        {name}
      &lt;/Button&gt;
    );
  }

  render() {
    const { buttons } = this.props;

    // without second param our function won't be able
    // to access `this` inside
    const buttonsMarkup = buttons.map(this.renderButton, this);
  }
}
</code></pre>

<p>但是，以我的经验来看，这种使用第二个参数的做法并不常见，更常见的做法是使用类属性或装饰器来避免绑定。</p>

<blockquote><p>译者注：<code>map</code> 第二个参数的用法等同于
<code>javascript
const buttonsMarkup = buttons.map(this.renderButton.bind(this);
</code></p></blockquote>

<p>还有一个类似的方法 &ndash; <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply">Function.prototype.apply</a>，工作原理与 <code>call</code> 相同，只是第二个参数应该是一个数组（译者注：或者是一个类数组），它将被转换成一个参数列表，用逗号分隔。所以，让我们看看如何使用它来计算最大值：</p>

<pre><code class="javascript">Math.max(1, 2, 3); // if we know all numbers upfront
// we can call it like that

Math.max([1, 2, 3]); // won't work!

Math.max.apply(null, [1, 2, 3]); // will work!

// however, ES2015 array destructuring works as well:
Math.max(...[1, 2, 3]);
</code></pre>

<p>现在，我们重新创建一个可以解决问题的函数调用方式。我们想删除字符串两端的空白字符，这个方法位于 <code>String.prototype</code> ，所以我们使用 <code>.</code> 操作符来调用它（虽然，字符串是原始值（primitive），但是当我们进行方法调用时，会在内部被转换成对象）。我们继续：</p>

<pre><code class="javascript">// let's try to imagine how trim method is implemented
// on String.prototype
String.prototype.trim = function() {
  // string itself is contained inside `this`!
  const str = this;
  // this is a very naive implementation
  return str.replace(/(^\s+)|(\s+$)/g, '');
};

// let's try to use `.call` method to invoke `trim`
" aa ".trim.call(thisArg);

// but `this` is our string itself!
// so, next two calls are equivalent:
" aa ".trim.call(" aa ");
String.prototype.trim.call(" aa ");
</code></pre>

<p>我们现在距离答案更近一步，但是仍然没有解释清楚最初那段代码：</p>

<pre><code class="javascript">addressParts.map(Function.prototype.call, String.prototype.trim);
</code></pre>

<p>让我们自己来实现 <code>Function.prototype.call</code>：</p>

<pre><code class="javascript">Function.prototype.call = function(thisArg, ...args) {
  // `this` in our case is actually our function!
  const fn = this;

  // also, pretty naive implementation
  return fn.bind(thisArg)(...args);
};
</code></pre>

<p>现在，我们可以来理一理所有的东西。当我们在 <code>.map</code> 里面声明函数的时候，我们给 <code>Function.prototype.call</code> 绑定<code>String.prototype.trim</code> 作为 <code>this</code> 上下文，然后我们在数组中的每个元素上调用这个函数，把每个字符串作为 <code>thisArg</code> 参数的值传递给 <code>call</code>。这意味着，<code>String.prototype.trim</code> 将使用字符串作为 <code>this</code> 上下文来调用。我们已经知道这样做是有效的，看看下面的例子：</p>

<pre><code class="javascript">String.prototype.trim.call(" aa "); // "aa"
</code></pre>

<p>问题解决了！但是，我认为这并不是一个好的做法，至于应该如何使用一种好的方式来完成这件事， 很简单，只需传递一个匿名函数就能搞定：</p>

<pre><code class="javascript">addressParts.map(str =&gt; str.trim()); // same effect
</code></pre>

<h2>也谈谈 JavaScript 中的 call、apply 和 bind</h2>

<p>作者在最后这一段可能讲得有些简略，尤其是对于 <code>bind</code> 的用法，谈谈我的理解思路：</p>

<pre><code class="javascript">// 我们从常用的 slice 说起
// 相信很多人都写过这样的代码
// 我们称之为方法借用
Array.prototype.slice.call([1, 2, 3], 1) // [ 2, 3]

// 也会有人这样写
[].slice.call([1, 2, 3], 1) // [2, 3]

// 但上面的例子其实不是其真实的使用场景，因为 [1, 2, 3] 本身就是一个 array，可以直接调用 slice
[1, 2, 3].slice(1) // [2, 3]

// 之前比较常见的场景是处理 argumnents，通过这种方式将这种类数组转换成真正的数组
Array.prototype.slice.call(arguments)

// 回到最上面的例子，我们已经知道使用 call 可以让你在某个特定上下文(context)调用函数(fn)
// fn.call(context [, ...args])
// 而对 call 来说，它的上下文就是 fn
// 所以 call 本身也是有上下文的，那我们为什么不可以直接给 call 指定一个上下文，就像这样：
Function.prototype.call.call(Array.prototype.slice, [1, 2, 3], 1) // [2, 3]

// 或者是这样，apply 接受一个数组
Function.prototype.call.apply(Array.prototype.slice, [[1, 2, 3], 1]) // [2, 3]

// 当然，也可以使用一下 bind，这样会返回一个新的函数
// 我们直接将 slice 绑定到 call 的上下文
var slice = Function.prototype.call.bind(Array.prototype.slice)
slice([1, 2, 3], 1) // [2, 3]

// 我们来稍微改动一下，跟上述 slice 的例子一致
var trim = Function.prototype.call.bind(String.prototype.trim)

// 上述 slice 等同于 Array.prototype.slice.call
// 所以这里的 trim，等同于 String.prototype.trim.call
// 那么
trim(' node') // 'node'

// 现在，在 map 里使用 trim
addressParts.map(Function.prototype.call.bind(String.prototype.trim))

// 回到最初的那段代码，这里面包含一个隐式的 bind 操作，与上面的代码等效
// 问题到这里就已经解决
addressParts.map(Function.prototype.call, String.prototype.trim)


// 如作者所言，这样的代码确实不容易阅读，不过对于我们理解 call、bind 以及 context 的概念仍是个很好的例子
// 我们还可以写得更复杂
// 不用担心，下面这段代码什么新东西都没有，不过是给 map 绑定到 call 而已
Function.prototype.call.bind(Array.prototype.map)(addressParts, Function.prototype.call, String.prototype.trim)
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[编写扁平化的代码]]></title>
    <link href="http://blog.mirreal.net/blog/2017/11/02/writing-flat-and-declarative-code/"/>
    <updated>2017-11-02T11:20:03+08:00</updated>
    <id>http://blog.mirreal.net/blog/2017/11/02/writing-flat-and-declarative-code</id>
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="https://peeke.nl/writing-flat-code">Writing flat &amp; declarative code</a></p>

<p>作者：<a href="https://twitter.com/peeke__">Peeke Kuepers</a></p></blockquote>

<p>&ndash; <em>给你的代码增加一点点函数式编程的特性</em></p>

<p><strong>最近我对函数式编程非常感兴趣。这个概念让我着迷：应用数学来增强抽象性和强制纯粹性，以避免副作用，并实现代码的良好可复用性。同时，函数式编程非常复杂。</strong></p>

<p>函数式编程有一个非常陡峭的学习曲线，因为它来源于数学中的<a href="https://github.com/MostlyAdequate/mostly-adequate-guide/blob/master/ch5.md#category-theory">范畴论</a>。接触不久之后，就将遇到诸如组合（composition）、恒等（identity），函子（functor）、单子（monad），以及逆变（contravariant）等术语。我根本不太了解这些概念，可能这也是我从来没有在实践中运用函数式编程的原因。</p>

<p>我开始思考：在常规的命令式编程和完全的函数式编程之间是否可能会有一些中间形式？既允许在代码库引入函数式编程的一些很好的特性，同时暂时保留已有的旧代码。</p>

<p>对我而言，函数式编程最大的作用就是强制你编写声明性代码：代码描述你做什么，而不是在描述如何做。这样就可以轻松了解特定代码块的功能，而无需了解其真正的运行原理。事实证明，编写声明式代码是函数式编程中最简单的部分之一。</p>

<h2>循环</h2>

<blockquote><p>&hellip;一个循环就是一个命令式控制结构，难以重用，并且难以插入到其他操作中。此外，它还得不断变化代码来响应新的迭代需求。</p>

<p>&ndash; Luis Atencio</p></blockquote>

<p>所以，让我们先看一下循环，循环是命令式编程的一个很好的例子。循环涉及很多语法，都是描述它们的行为是如何工作，而不是它们在做什么。例如，看看这段代码：</p>

<pre><code class="javascript">function helloworld(arr) {
    for (let i = 1; i &lt; arr.length; i++) {
        arr[i] *= 2
        if (arr[i] % 2 === 0) {
            doSomething(arr[i])
        }
    }
}
</code></pre>

<p>这段代码在做什么呢？它将数组内除第一个数字 （<code>let i = 1</code>）的其他所有数字乘以 2，如果是偶数的话（<code>if (arr % 2 === 0)</code>），就进行某些操作。在此过程中，原始数组的值会被改变。但这通常是不必要的，因为数组可能还会在代码库中的其他地方用到，所以刚才所做的改变可能会导致意外的结果。</p>

<p>但最主要的原因是，这段代码看起来很难一目了然。它是命令式的，for 循环告诉我们如何遍历数组，在里面，使用一个 if 语句有条件地调用一个函数。</p>

<p>我们可以通过使用数组方法以声明式的方式重写这段代码。数组方法直接表达所做的事，比较常见的方法包括：<code>forEach</code>，<code>map</code>，<code>filter</code>，<code>reduce</code> 和 <code>slice</code>。</p>

<p>结果就像下面这样：</p>

<pre><code class="javascript">function helloworld(arr) {
    const evenNumbers = n =&gt; n % 2 === 0

    arr
        .slice(1)
        .map(v =&gt; v * 2)
        .filter(evenNumbers)
        .forEach(v =&gt; doSomething(v))    
}
</code></pre>

<p>在这个例子中，我们使用一种很好的，扁平的链式结构去描述我们在做什么，明确表明意图。此外，我们避免了改变原始数组，从而避免不必要的副作用，因为大多数数组方法会返回一个新数组。当箭头函数开始变得越来越复杂时，可以地将其提取到一个特定的函数中，比如 <code>evenNumbers</code>， 从而尽量保持结构简单易读。</p>

<p>在上面的例子，链式调用并没有返回值，而是以 forEach 结束。然而，我们可以轻松地剥离最后一部分，并返回结果，以便我们可以在其他地方处理它。如果还需要返回除数组以外的任何东西，可以使用 <code>reduce</code> 函数。</p>

<p>对于接下来的一个例子，假设我们有一组 JSON 数据，其中包含在一个虚构歌唱比赛中不同国家获得的积分：</p>

<pre><code class="json">[
    {
        "country": "NL",
        "points": 12
    },
    {
        "country": "BE",
        "points": 3
    },
    {
        "country": "NL",
        "points": 0
    },
    ...
]
</code></pre>

<p>我们想计算荷兰（NL）获得的总积分，根据印象中其强大的音乐能力，我们可以认为这是一个非常高的分数，但我们想要更精确地确认这一点。</p>

<p>使用循环可能会是这样：</p>

<pre><code class="javascript">function countVotes(votes) {
    let score = 0;

    for (let i = 0; i &lt; votes.length; i++) {
        if (votes[i].country === 'NL') {
            score += votes[i].points;
        }
    }

    return score;
}
</code></pre>

<p>使用数组方法重构，我们得到一个更干净的代码片段：</p>

<pre><code class="javascript">function countVotes(votes) {
    const sum = (a, b) =&gt; a + b;

    return votes
        .filter(vote =&gt; vote.country === 'NL')
        .map(vote =&gt; vote.points)
        .reduce(sum);
}
</code></pre>

<p>有时候 <code>reduce</code> 可能有点难以阅读，将 <code>reduce</code> 函数提取出来会在理解上有帮助。在上面的代码片段中，我们定义了一个 <code>sum</code> 函数来描述函数的作用，因此方法链仍然保持很好的可读性。</p>

<h2>if else 语句</h2>

<p>接下来，我们来聊聊大家都很喜欢的 if else 语句，if else 语句也是命令式代码里一个很好的例子。为了使我们的代码更具声明式，我们将使用三元表达式。</p>

<p>一个三元表达式是 if else 语句的替代语法。以下两个代码块具有相同的效果：</p>

<pre><code class="javascript">// Block 1
if (condition) {
    doThis();
} else {
    doThat();
}

// Block 2
const value = condition ? doThis() : doThat();
</code></pre>

<p>当在定义（或返回）一个常量时，三元表达式非常有用。使用 if else 语句会将该变量的使用范围限制在语句内，通过使用三元语句，我们可以避免这个问题：</p>

<pre><code class="javascript">if (condition) {
    const a = 'foo';
} else {
    const a = 'bar';
}

const b = condition ? 'foo' : 'bar';

console.log(a); // Uncaught ReferenceError: a is not defined
console.log(b); // 'bar'
</code></pre>

<p>现在，我们来看看如何应用这一点来重构一些更重要的代码：</p>

<pre><code class="javascript">const box = element.getBoundingClientRect();

if (box.top - document.body.scrollTop &gt; 0 &amp;&amp; box.bottom - document.body.scrollTop &lt; window.innerHeight) {
    reveal();
} else {
    hide();
}
</code></pre>

<p>那么，上面的代码发生了什么呢？if 语句检查元素当前是否在页面的可见部分内，这个信息在代码的任何地方都没有表达出来。基于此布尔值，再调用 <code>reveal()</code> 或者 <code>hide()</code> 函数。</p>

<p>将这个 if 语句转换成三元表达式迫使我们将条件移动到它自己的变量中。这样我们可以将三元表达式组合在一行上，现在通过变量的名称来传达布尔值表示的内容，这样还不错。</p>

<pre><code class="javascript">const box = element.getBoundingClientRect();
const isInViewport =
    box.top - document.body.scrollTop &gt; 0 &amp;&amp;
    box.bottom - document.body.scrollTop &lt; window.innerHeight;

isInViewport ? reveal() : hide();
</code></pre>

<p>通过这个例子，重构带来的好处可能看起来不大。接下来会有一个相比更复杂的例子：</p>

<pre><code class="javascript">elements
    .forEach(element =&gt; {
        const box = element.getBoundingClientRect();

        if (box.top - document.body.scrollTop &gt; 0 &amp;&amp; box.bottom - document.body.scrollTop &lt; window.innerHeight) {
            reveal();
        } else {
            hide();
        }

    });
</code></pre>

<p>这很不好，打破了我们优雅的扁平的调用链，从而使代码更难读。我们再次使用三元操作符，而在使用它的时候，使用 <code>isInViewport</code> 检查，并跟它自己的动态函数分开。</p>

<pre><code class="javascript">const isInViewport = element =&gt; {
    const box = element.getBoundingClientRect();
    const topInViewport = box.top - document.body.scrollTop &gt; 0;
    const bottomInViewport = box.bottom - document.body.scrollTop &lt; window.innerHeight;
    return topInViewport &amp;&amp; bottomInViewport;
};

elements
    .forEach(elem =&gt; isInViewport(elem) ? reveal() : hide());
</code></pre>

<p>此外，现在我们将 <code>isInViewport</code> 移动到一个独立函数，可以很容易地把它放在它自己的 helper 类/对象之内：</p>

<pre><code class="javascript">import { isInViewport } from 'helpers';

elements
    .forEach(elem =&gt; isInViewport(elem) ? reveal() : hide());
</code></pre>

<p>虽然上面的例子依赖于所处理的是数组，但是在不明确是在数组的情况下，也可以采用这种编码风格。</p>

<p>例如，看看下面的函数，它通过三条规则来验证密码的有效性。</p>

<pre><code class="javascript">import { passwordRegex as requiredChars } from 'regexes'
import { getJson } from 'helpers'

const validatePassword = async value =&gt; {
  if (value.length &lt; 6) return false
  if (!requiredChars.test(value)) return false

  const forbidden = await getJson('/forbidden-passwords')
  if (forbidden.includes(value)) return false

  return value
}

validatePassword(someValue).then(persist)
</code></pre>

<p>如果我们使用数组包装初始值，就可以使用在上面的例子中里面所用到的所有数组方法。此外，我们已经将验证函数打包成 <code>validationRules</code> 使其可重用。</p>

<pre><code class="javascript">import { minLength, matchesRegex, notBlacklisted } from 'validationRules'
import { passwordRegex as requiredChars } from 'regexes'
import { getJson } from 'helpers'

const validatePassword = async value =&gt; {
  const result = Array.from(value)
    .filter(minLength(6))
    .filter(matchesRegex(requiredChars))
    .filter(await notBlacklisted('/forbidden-passwords'))
    .shift()

  if (result) return result
  throw new Error('something went wrong...')
}

validatePassword(someValue).then(persist)
</code></pre>

<p>目前在 JavaScript 中有一个 <a href="https://github.com/tc39/proposal-pipeline-operator">管道操作符</a> 的提案。使用这个操作符，就不用再把原始值换成数组了。可以直接在前面的值调用管道操作符之后的函数，有点像 <code>Array</code> 的 <code>map</code> 功能。修改之后的代码大概就像这样：</p>

<pre><code class="javascript">import { minLength, matchesRegex, notBlacklisted } from 'validationRules'
import { passwordRegex as requiredChars } from 'regexes'
import { getJson } from 'helpers'

const validatePassword = async value =&gt;
  value
    |&gt; minLength(6)
    |&gt; matchesRegex(requiredChars)
    |&gt; await notBlacklisted('/forbidden-passwords')

try { someValue |&gt; await validatePassword |&gt; persist }
catch(e) {
  // handle specific error, thrown in validation rule
}
</code></pre>

<p>但需要注意的是，这仍然是一个非常早期的提案，不过可以稍微期待一下。</p>

<h2>事件</h2>

<p>最后，我们来看看事件处理。一直以来，事件处理很难以扁平化的方式编写代码。可以 <code>Promise</code> 化来保持一种链式的，扁平化的编程风格，但 <code>Promise</code> 只能 <code>resolve</code> 一次，而事件绝对会多次触发。</p>

<p>在下面的示例中，我们创建一个类，它对用户的每个输入值进行检索，结果是一个自动补全的数组。首先检查字符串是否长于给定的阈值长度。如果满足条件，将从服务器检索自动补全的结果，并将其渲染成一系列标签。</p>

<p>注意代码的不“纯”，频繁地使用 <code>this</code> 关键字。几乎每个函数都在访问 <code>this</code> 这个关键字：</p>

<blockquote><p>译注：作者在这里使用 &ldquo;this keyword&#8221;，有一种双关的意味</p></blockquote>

<pre><code class="javascript">import { apiCall } from 'helpers'

class AutoComplete {

  constructor (options) {

    this._endpoint = options.endpoint
    this._threshold = options.threshold
    this._inputElement = options.inputElement
    this._containerElement = options.list

    this._inputElement.addEventListener('input', () =&gt;
      this._onInput())

  }

  _onInput () {

    const value = this._inputElement.value

    if (value &gt; this._options.threshold) {
      this._updateList(value)
    }

  }

  _updateList (value) {

    apiCall(this._endpoint, { value })
      .then(items =&gt; this._render(items))
      .then(html =&gt; this._containerElement = html)

  }

  _render (items) {

    let html = ''

    items.forEach(item =&gt; {
      html += `&lt;a href="${ item.href }"&gt;${ item.label }&lt;/a&gt;`
    })

    return html

  }

}
</code></pre>

<p>通过使用 <code>Observable</code>，我们将用一种更好的方式对这段代码进行重写。可以简单将 <code>Observable</code> 理解成一个能够多次 <code>resolve</code> 的 <code>Promise</code>。</p>

<blockquote><p>Observable 类型可用于基于推送模型的数据源，如 DOM 事件，定时器和套接字</p></blockquote>

<p><code>Observable</code> 提案目前处于 Stage-1。在下面 <code>listen</code> 函数的实现是从 GitHub 上的<a href="https://github.com/tc39/proposal-observable">提案</a>中直接复制的，主要是将事件监听器转换成 <code>Observable</code>。可以看到，我们可以将整个 <code>AutoComplete</code> 类重写为单个方法的函数链。</p>

<pre><code class="javascript">import { apiCall, listen } from 'helpers';
import { renderItems } from 'templates';

function AutoComplete ({ endpoint, threshold, input, container }) {

  listen(input, 'input')
    .map(e =&gt; e.target.value)
    .filter(value =&gt; value.length &gt;= threshold)
    .forEach(value =&gt; apiCall(endpoint, { value }))
    .then(items =&gt; renderItems(items))
    .then(html =&gt; container.innerHTML = html)

}
</code></pre>

<p>由于大多数 <code>Observable</code> 库的实现过于庞大，我很期待 ES 原生的实现。<code>map</code>，<code>filter</code> 和 <code>forEach</code>方法还不是规范的一部分，但是在 <a href="https://github.com/zenparsing/zen-observable">zen-observable</a> 已经在扩展 API 实现，而 zen-observable 本身是 ES Observables 的一种实现 。</p>

<p>&ndash;</p>

<p>我希望你会对这些“扁平化”模式感兴趣。就个人而言，我很喜欢以这种方式重写我的程序。你接触到的每一段代码都可以更易读。使用这种技术获得的经验越多，就越来越能认识到这一点。记住这个简单的法则：</p>

<p><strong>The flatter the better!</strong></p>
]]></content>
  </entry>
  
</feed>
