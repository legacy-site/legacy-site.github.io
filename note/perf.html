<!doctype html>
<!-- paulirish.com/2008/conditional-stylesheets-vs-css-hacks-answer-neither/ -->
<!--[if lt IE 7]> <html class="no-js ie6 oldie" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js ie7 oldie" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js ie8 oldie" lang="en"> <![endif]-->
<!-- Consider adding an manifest.appcache: h5bp.com/d/Offline -->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->
<head>
  <meta charset="utf-8">

  <!-- Use the .htaccess and remove these lines to avoid edge case issues.
       More info: h5bp.com/b/378 -->
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

  <title>perf |  Patrick Ran</title>
  <meta name="author" content="Patrick Ran">
  

  
  <!-- Mobile viewport optimized: j.mp/bplateviewport -->
  <meta name="viewport" content="width=device-width,initial-scale=1">

  <!-- Place favicon.ico and apple-touch-icon.png in the root directory: mathiasbynens.be/notes/touch-icons -->

  <!-- CSS: implied media=all -->
  <!-- CSS concatenated and minified via ant build script-->
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href='https://fonts.googleapis.com/css?family=Inconsolata' rel='stylesheet' type='text/css'>
  <!-- end CSS-->

  <!-- More ideas for your <head> here: h5bp.com/d/head-Tips &#8211;>

  <!-- All JavaScript at the bottom, except for Modernizr / Respond.
       Modernizr enables HTML5 elements & feature detects; Respond is a polyfill for min/max-width CSS3 Media Queries
       For optimal performance, use a custom Modernizr build: www.modernizr.com/download/ -->
  <script src="/javascripts/libs/modernizr-2.0.6.min.js"></script>
</head>

<body id="article">

  <div id="container" style="margin-top: 30px;">
    <nav role="navigation" ><ul class="main-navigation">
  <li style='float:left;margin-right:5px'><a class='nav' href="http://mirreal.net/">HOME</a></li>
  <li style="float:left;margin-right:7px"><a class="nav" href="/">BLOG</a></li>
  <li style='float:left;margin-right:7px'><a class='nav' href="/archives">ARCHIVES</a></li>
  <li style="float:left;margin-right:7px"><a class="nav" href="/note">NOTE</a></li>
  <li style="float:left;margin-right:7px"><a class="nav" href="/weekly">WEEKLY</a></li>
  <li style="float:left;margin-right:7px"><a class="nav" href="/project">PROJECT</a></li>
  <li style="float:left;margin-right:7px"><a class="nav" href="/about">ABOUT</a></li>
</ul>
<br><br>
</nav>
    <article>
  <h1 class="article-title">Perf</h1>
  <div class="sharing">
  
  
</div>

  <div class="article-content"><h3>性能准则 <code>★★★★★</code></h3>

<ul>
<li><a href="http://developer.yahoo.com/performance/rules.html">雅虎性能军规</a>、<a href="http://www.cnblogs.com/li0803/archive/2009/09/20/1570581.html">中文文章</a></li>
<li><a href="https://developers.google.com/speed/articles/">谷歌性能优化文章</a> 推荐</li>
</ul>


<h3>分析工具 <code>★★★</code></h3>

<p><strong>入门</strong></p>

<ul>
<li><a href="https://developers.google.com/speed/pagespeed/">pageSpeed</a> 基于谷歌性能准则的检测，可浏览器安装插件运行</li>
<li><a href="http://www.yslow.net/show.php?tid=123">Yslow</a> 基于雅虎性能准则的检测工具，可浏览器安装插件运行</li>
<li><a href="http://fe.baidu.com/pagecheck/">pageCheck</a> 百度内部开发，指标齐全，支持自动运行</li>
</ul>


<p><strong>进阶</strong></p>

<ul>
<li><a href="http://www.webpagetest.org/">webPageTest</a> 查看页面加载瀑布流等数据，进阶必备工具</li>
<li><a href="http://coding.smashingmagazine.com/2012/06/12/javascript-profiling-chrome-developer-tools/">Chrome 开发者工具</a> 功能强大，值得学习</li>
<li><a href="http://phantomjs.org/">PhantomJS</a> 功能强大的分析工具，高手必备瑞士军刀</li>
<li><a href="http://jsperf.com/">JsPerf</a> JS 执行性能分析网站，谁用谁知道</li>
</ul>


<h3>浏览器与 Html 标准 <code>★★</code></h3>

<p><strong>入门</strong></p>

<ul>
<li><a href="http://www.mangguo.org/browser-cache-mechanism-detailed/">浏览器缓存机制</a></li>
<li><a href="http://www.w3.org/TR/navigation-timing/">Navigation Timing</a>、<a href="http://www.w3.org/TR/resource-timing/">Resource Timing</a> 相关文章请谷歌，必备知识</li>
<li><a href="http://www.ecdoer.com/post/dns.html">DNS 解析过程原理</a></li>
<li><a href="http://blog.csdn.net/xingtian713/article/details/11882795">高性能浏览器网络翻译系列</a></li>
</ul>


<p><strong>进阶</strong></p>

<ul>
<li><a href="http://network.51cto.com/art/201401/426957.htm">SPDY 协议</a> 基于此的 Http2.0 协议即将发布</li>
<li><a href="http://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/">浏览器渲染原理</a> 比较难懂，但是非常经典</li>
<li><a href="http://fe.baidu.com/doc/wpo/research/chromium-gettingstart-guide.text">Chrome 实现原理学习指南</a> 多益大牛的总结</li>
</ul>


<h3>开发实战 <code>★★★★</code></h3>

<p><strong>通用</strong></p>

<ul>
<li><a href="http://book.douban.com/subject/5362856/">高性能 JavaScript</a></li>
<li><a href="http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/">writing-fast-memory-efficient-javascript</a></li>
<li><a href="http://msdn.microsoft.com/en-us/library/bb250448.aspx">Understanding and Solving Internet Explorer Leak Patterns</a></li>
<li>模块化加载 <a href="https://fis.baidu.com/">FIS</a>、SeaJS。FIS 有完善的静态资源管理和优化方案，推荐。</li>
<li><a href="http://www.iteye.com/magazines/116-Web-Front-Performance-Best-Practice">前端性能优化最佳实践</a></li>
</ul>


<p><strong>动画与渲染</strong></p>

<ul>
<li><a href="http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/">requestAnimationFrame</a></li>
<li><a href="http://velocity.oreilly.com.cn/2013/ppts/16_ms_optimization--web_front-end_performance_optimization.pdf">16ms 的优化</a></li>
<li><a href="http://www.stubbornella.org/content/2009/03/27/reflows-repaints-css-performance-making-your-javascript-slow/">css</a>、<a href="http://mir.aculo.us/2010/08/17/when-does-javascript-trigger-reflows-and-rendering/">JS</a>不要引起 Repaint &amp; Reflow</li>
</ul>


<p><strong>移动端开发</strong></p>

<ul>
<li><a href="http://www.html5rocks.com/en/tutorials/speed/html5/">Improving the Performance of your HTML5 App</a></li>
<li><a href="http://stevesouders.com/mobileperf/">Steve Souders</a></li>
<li><a href="http://mobile.smashingmagazine.com/2013/08/12/creating-high-performance-mobile-websites/">Creating High-Performance Mobile Websites</a></li>
<li><a href="http://www.html5rocks.com/en/mobile/optimization-and-performance/">HTML5 Techniques for Optimizing Mobile Performance</a></li>
<li><a href="https://developers.google.com/webmasters/smartphone-sites/website-improvement-checklist">移动 web 站点优化指南</a></li>
</ul>


<h3>性能监控 <code>★★★★</code></h3>

<ul>
<li><a href="http://blog.smartbear.com/performance/essential-web-performance-metrics-part-2/">监控指标选取</a></li>
<li><a href="http://www.slideshare.net/watchingwebsites/complete-web-monitoring-web-performance-at-emetrics?qid=a6296849-f0ce-4c71-9322-0be0f6eedb27&amp;v=qf1&amp;b=&amp;from_search=11">Complete Web Monitoring - Web Performance at eMetrics</a></li>
<li><a href="http://tech.weibo.com/?p=2150">berserkJS 建立前端性能监控平台</a></li>
<li><a href="http://www.slideshare.net/catchpoint/ny-webperf-peelingonion?qid=a6296849-f0ce-4c71-9322-0be0f6eedb27&amp;v=qf1&amp;b=&amp;from_search=8">NY Web Perf Meetup: Peeling the Web Performance Onion</a></li>
</ul>


<h3>相关会议 <code>★★★</code></h3>

<ul>
<li><a href="http://velocity.oreilly.com.cn/2012/">velocity</a> 业内最出名的国际会议之一</li>
<li><a href="https://developers.google.com/events/io/">Google I/O</a></li>
<li><a href="http://www.qconbeijing.com/">Qcon</a></li>
</ul>


<h3>推荐博客 <code>★★★</code></h3>

<ul>
<li><a href="http://www.webperformancetoday.com/">web performance today</a></li>
<li><a href="http://www.perfplanet.com/">perfplanet</a></li>
<li><a href="http://www.stevesouders.com/blog/">stevesouders.com</a></li>
<li><a href="http://www.yottaa.com/blog/topic/site-performance-and-optimization">site-performance-and-optimization</a></li>
</ul>


<h2>性能指标</h2>

<p>衡量页面性能有一些主要的指标：</p>

<ul>
<li>白屏时间(首次渲染时间) ：用户从打开页面开始到页面开始有东西呈现为止，这过程中占用的时间就是白屏时间</li>
<li>用户可操作时间（DOM Ready）：用户可以进行正常的点击、输入等交互操作</li>
<li>页面总下载时间（Page loading）：页面所有资源都加载完成并呈现出来所花的时间，即页面 onload 的时间</li>
<li>页面流畅度：主观感受上就是卡顿</li>
</ul>


<h3>一、白屏时间(首次渲染时间) Start Render</h3>

<h4>用户体验</h4>

<p>如果时间越短给用户的体验则是页面速度越快，这样用户等待其余内容展现的耐心也会更大一些。如果时间过长，则用户会在长时间内面对的都是一个空白的页面，这对用户的耐心将是一个考验。总的来说，Start Render时间是越短越好，而且是非常关键的指标。</p>

<h4>影响因素</h4>

<p>要想知道Start Render时间受哪些因素的影响，首先要知道这个时间是怎么计算的。归纳一下，大概可以用以下这个公式来表示：</p>

<p>Time To Start Render = TTFB + TTDD + TTHE</p>

<p>其中：</p>

<ul>
<li>TTFB(Time To First Byte)：发起请求到服务器返回数据的时间</li>
<li>TTDD(Time To Document Download)：从服务器加载HTML文档的时间</li>
<li>TTHE(Time To Head End)：HTML文档头部解析完成所需要的时间</li>
</ul>


<p>通过以上公式可以看到Start Render主要受以下因素影响：</p>

<ol>
<li>服务器响应时间</li>
<li>HTML文档的大小</li>
<li>Head中资源使用情况</li>
</ol>


<h3>二、用户可操作时间 DOM Ready</h3>

<p>在高级浏览器里有对应的DOM事件 - DOMContentLoaded</p>

<p>文档的解析至少应该包括以下操作：HTML文档分析以及DOM树的创建、外链脚本的加载、外链脚本的执行以及内联脚本的执行，但是不包括图片、iframe等其它资源的加载。</p>

<h4>影响因素</h4>

<p>先来看看一个粗略的时间组成公式：</p>

<p>Time To Dom Ready = TTSR + TTDC + TTST</p>

<p>其中：</p>

<ul>
<li>TTSR(Time To Start Render)：浏览器开始渲染的时间</li>
<li>TTDC(Time To Dom Created)：DOM树创建所耗时间</li>
<li>TTST(Time To Script)：BODY中所有脚本加载和执行的时间</li>
</ul>


<p>通过以上公式可以看到 DOM Ready 主要受以下因素影响(开发人员可控)：</p>

<ul>
<li>DOM结构的复杂程度</li>
<li>BODY中脚本使用情况</li>
</ul>


<h4>用户体验</h4>

<p>Start Render指标直接决定着用户对页面速度的体验，与此不同，DOM Ready指标并不直接影响感官体验，往往影响的是交互功能何时可用。</p>

<h3>三、页面总加载时间 Page loading</h3>

<p>Page Load时间指的就是window.onload事件触发的时间。与DOM Ready时间相比，Page Load的时间往往要更靠后一些，因为Page Load不仅仅是HTML文档解析完毕还包括了所有资源加载所需要的时间，例如图片资源的加载</p>

<h4>用户体验</h4>

<p>大家可能觉得Page Load时间长一点无关紧要，实际上该指标从以下两方面影响着用户体验：</p>

<p>window.onload事件触发的时间(Page Load)也就是所有资源加载完成的时间，该时间越长意味着用户需要等待越久才能看见某些内容，例如图片，这些内容也许并不是最总要的，但这是一个完整页面的组成部分，这部分内容如果加载过慢，也会在一定程度上影响用户对页面完整性的体验。</p>

<h4>影响因素</h4>

<p>如果没有任何外链资源，则Page Load时间与DOM Ready时间几乎是相等的，随着图片等资源的增加，Page Load与DOM Ready的差距也会越来越大。（外链脚本除外，因为外链脚本也同样会增加DOM Ready时间）</p>

<h3>四、页面流畅度</h3>

<p>卡顿的感受会在很多地方出现，但是怎么来衡量这个卡顿的程度呢</p>

<h4>如何客观的度量页面卡顿程度</h4>

<p>一般我们要求页面要达到 60 FPS（ 60 帧/秒）。如果按照 60 FPS 计算，那么每一帧执行时间为 1/60s，也就是 16.7ms。</p>

<p>为什么页面会看起来比较卡？浏览器的渲染是单线程的，在某一个时刻要么在进行 JS 运算，要么在进行 UI 渲染。</p>

<p>如果我们的脚本在改变 UI 那么这个脚本的执行时间不要超过了 16.7ms，否则页面在这个周期中无法进行 UI 变化，那么看起来就是跳帧（卡顿）了。</p>

<h3>Tip 60fps 与设备刷新率</h3>

<p>用户与网站进行交互。
目前大多数设备的屏幕刷新率为 60 次/秒。因此，如果在页面中有一个动画或渐变效果，或者用户正在滚动页面，那么浏览器渲染动画或页面的每一帧的速率也需要跟设备屏幕的刷新率保持一致。</p>

<p>其中每个帧的预算时间仅比 16 毫秒多一点 (1 秒/ 60 = 16.66 毫秒)。但实际上，浏览器有整理工作要做，因此您的所有工作需要在 10 毫秒内完成。如果无法符合此预算，帧率将下降，并且内容会在屏幕上抖动。 此现象通常称为卡顿，会对用户体验产生负面影响。</p>

<h3>我们能做些什么</h3>

<p>首先，使用评估工具确认当前页面性能处于一个怎样的水平，并找出影响性能的点。</p>

<p>页面性能评估工具：</p>

<ul>
<li>Page Speed <a href="https://developers.google.com/speed/pagespeed/">https://developers.google.com/speed/pagespeed/</a></li>
<li>WebPagetest</li>
<li>PhantomJS</li>
<li>Performance api</li>
<li>gtmetrix.com</li>
</ul>


<h4>页面加载时间</h4>

<ul>
<li>减少 HTTP 请求</li>
<li>移除重复和无用模块，减少页面大小</li>
</ul>


<h4>页面流畅度</h4>

<p>我们可以通过一些特殊的方式采集页面卡顿的程度</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">var</span> <span class="nx">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">();</span>
</span><span class='line'><span class="nx">setInterval</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
</span><span class='line'>  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">new</span> <span class="nb">Date</span><span class="p">()</span> <span class="o">-</span> <span class="nx">t</span><span class="p">);</span>
</span><span class='line'>  <span class="nx">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">();</span>
</span><span class='line'><span class="p">},</span> <span class="mi">100</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>找到导致卡顿的问题，优化代码，大致分为：</p>

<ul>
<li>减少会引起页面重绘（redraw）的方法的调用</li>
<li>减少 DOM 操作，避免使用 JavaScript 修复布局</li>
<li>合理架构，使 DOM 结构尽量保持简单</li>
<li>使用高效的事件处理，对于 resize、scroll 等触发频率极高的事件，应该通过 debounce 等机制降低处理程序执行频率</li>
<li>将某些耗时的操作放到空闲的时候再去做（setTimout）</li>
<li>涉及到页面的动画元素能用 GPU 最佳</li>
</ul>


<h2>参考</h2>

<p><a href="https://developers.google.com/web/fundamentals/performance/">https://developers.google.com/web/fundamentals/performance/</a></p>

<p><a href="https://github.com/grz/cpujs">cpujs</a></p>

<p><a href="http://fex.baidu.com/blog/2014/05/build-performance-monitor-in-7-days/">7 天打造前端性能监控系统</a></p>

<p><a href="http://taobaofed.org/blog/2015/11/09/web-performance/">如何评价页面的性能</a></p>

<p><a href="http://www.cnblogs.com/onflying/archive/2013/04/23/3037789.html">前端性能指标分析</a></p>

<p><a href="https://segmentfault.com/a/1190000003646305#articleHeader13">前端性能优化指南</a></p>

<h1>前端性能优化指南</h1>

<h3><code>AJAX</code>优化</h3>

<hr />

<blockquote><ul>
<li>缓存<code>AJAX</code>：

<ul>
<li><code>异步</code>并不等于<code>即时</code>。</li>
</ul>
</li>
<li>请求使用<code>GET</code>：

<ul>
<li>当使用<code>XMLHttpRequest</code>时，而URL长度不到<code>2K</code>，可以使用<code>GET</code>请求数据，<code>GET</code>相比<code>POST</code>更快速。

<ul>
<li><code>POST</code>类型请求要发送两个<code>TCP</code>数据包。

<ul>
<li>先发送文件头。</li>
<li>再发送数据。</li>
</ul>
</li>
<li><code>GET</code>类型请求只需要发送一个<code>TCP</code>数据包。

<ul>
<li>取决于你的<code>cookie</code>数量。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>

<h3><code>COOKIE</code>专题</h3>

<hr />

<blockquote><ul>
<li>减少<code>COOKIE</code>的大小。</li>
<li>使用无<code>COOKIE</code>的域。

<ul>
<li>比如图片<code>CSS</code>等静态文件放在静态资源服务器上并配置单独域名，客户端请求静态文件的时候，减少<code>COOKIE</code>反复传输时对主域名的影响。</li>
</ul>
</li>
</ul>
</blockquote>

<h3><code>DOM</code>优化</h3>

<hr />

<blockquote><ul>
<li><p>优化节点修改。</p>

<ul>
<li><p>使用<code>cloneNode</code>在外部更新节点然后再通过<code>replace</code>与原始节点互换。</p>

<p>var orig = document.getElementById(&lsquo;container&rsquo;);
var clone = orig.cloneNode(true);
var list = [&lsquo;foo&rsquo;, &lsquo;bar&rsquo;, &lsquo;baz&rsquo;];
var content;
for (var i = 0; i &lt; list.length; i++) {
content = document.createTextNode(list[i]);
clone.appendChild(content);
}
orig.parentNode.replaceChild(clone, orig);</p></li>
</ul>
</li>
<li><p>优化节点添加</p>

<blockquote><p>多个节点插入操作，即使在外面设置节点的元素和风格再插入，由于多个节点还是会引发多次reflow。</p></blockquote>

<ul>
<li><p>优化的方法是创建<code>DocumentFragment</code>，在其中插入节点后再添加到页面。</p>

<ul>
<li><p>如<code>JQuery</code>中所有的添加节点的操作如<code>append</code>，都是最终调用<code>DocumentFragment</code>来实现的，</p>

<pre><code>createSafeFragment(document) {
</code></pre>

<p>var list = nodeNames.split( &ldquo;|&rdquo; ),</p>

<pre><code>safeFrag = document.createDocumentFragment();
</code></pre>

<p>if (safeFrag.createElement) {</p>

<pre><code>while (list.length) {
    safeFrag.createElement(
        list.pop();
    );
};
</code></pre>

<p>};return safeFrag;</p>

<pre><code>};
</code></pre></li>
</ul>
</li>
</ul>
</li>
<li><p>优化<code>CSS</code>样式转换。</p>

<blockquote><p>如果需要动态更改CSS样式，尽量采用触发reflow次数较少的方式。</p></blockquote>

<ul>
<li><p>如以下代码逐条更改元素的几何属性，理论上会触发多次<code>reflow</code>。</p>

<pre><code>    element.style.fontWeight = 'bold' ;
    element.style.marginLeft= '30px' ;
    element.style.marginRight = '30px' ;
</code></pre></li>
<li><p>可以通过直接设置元素的<code>className</code>直接设置，只会触发一次<code>reflow</code>。</p>

<pre><code>element.className = 'selectedAnchor' ;
</code></pre></li>
</ul>
</li>
<li><p>减少<code>DOM</code>元素数量</p>

<ul>
<li><p>在<code>console</code>中执行命令查看<code>DOM</code>元素数量。</p>

<pre><code>`document.getElementsByTagName( '*' ).length`
</code></pre></li>
<li><p>正常页面的<code>DOM</code>元素数量一般不应该超过<code>1000</code>。</p></li>
<li><p><code>DOM</code>元素过多会使<code>DOM</code>元素查询效率，样式表匹配效率降低，是页面性能最主要的瓶颈之一。</p></li>
</ul>
</li>
<li><p><code>DOM</code>操作优化。</p>

<ul>
<li><code>DOM</code>操作性能问题主要有以下原因。

<ul>
<li><code>DOM</code>元素过多导致元素定位缓慢。</li>
<li>大量的<code>DOM</code>接口调用。

<ul>
<li><code>JAVASCRIPT</code>和<code>DOM</code>之间的交互需要通过函数<code>API</code>接口来完成，造成延时，尤其是在循环语句中。</li>
</ul>
</li>
<li><code>DOM</code>操作触发频繁的<code>reflow(layout)</code>和<code>repaint</code>。</li>
<li><code>layout</code>发生在<code>repaint</code>之前，所以layout相对来说会造成更多性能损耗。

<ul>
<li><code>reflow(layout)</code>就是计算页面元素的几何信息。</li>
<li><code>repaint</code>就是绘制页面元素。</li>
</ul>
</li>
<li>对<code>DOM</code>进行操作会导致浏览器执行回流<code>reflow</code>。</li>
</ul>
</li>
<li>解决方案。

<ul>
<li>纯<code>JAVASCRIPT</code>执行时间是很短的。</li>
<li>最小化<code>DOM</code>访问次数，尽可能在js端执行。</li>
<li>如果需要多次访问某个<code>DOM</code>节点，请使用局部变量存储对它的引用。</li>
<li>谨慎处理<code>HTML</code>集合（<code>HTML</code>集合实时连系底层文档），把集合的长度缓存到一个变量中，并在迭代中使用它，如果需要经常操作集合，建议把它拷贝到一个数组中。</li>
<li>如果可能的话，使用速度更快的API，比如<code>querySelectorAll</code>和<code>firstElementChild</code>。</li>
<li>要留意重绘和重排。</li>
<li>批量修改样式时，<code>离线</code>操作<code>DOM</code>树。</li>
<li>使用缓存，并减少访问布局的次数。</li>
<li>动画中使用绝对定位，使用拖放代理。</li>
<li>使用事件委托来减少事件处理器的数量。</li>
</ul>
</li>
</ul>
</li>
<li><p>优化<code>DOM</code>交互</p>

<blockquote><p>在<code>JAVASCRIPT</code>中，<code>DOM</code>操作和交互要消耗大量时间，因为它们往往需要重新渲染整个页面或者某一个部分。</p></blockquote>

<ul>
<li><p>最小化<code>现场更新</code>。</p>

<ul>
<li>当需要访问的<code>DOM</code>部分已经已经被渲染为页面中的一部分，那么<code>DOM</code>操作和交互的过程就是再进行一次<code>现场更新</code>。

<ul>
<li><code>现场更新</code>是需要针对<code>现场</code>（相关显示页面的部分结构）立即进行更新，每一个更改（不管是插入单个字符还是移除整个片段），都有一个性能损耗。</li>
<li>现场更新进行的越多，代码完成执行所花的时间也越长。</li>
</ul>
</li>
</ul>
</li>
<li><p>多使用<code>innerHTML</code>。</p>

<ul>
<li><p>有两种在页面上创建<code>DOM</code>节点的方法：</p>

<ul>
<li>使用诸如<code>createElement()</code>和<code>appendChild()</code>之类的<code>DOM</code>方法。</li>
<li>使用<code>innerHTML</code>。

<ul>
<li>当使用<code>innerHTML</code>设置为某个值时，后台会创建一个<code>HTML</code>解释器，然后使用内部的<code>DOM</code>调用来创建<code>DOM</code>结构，而非基于<code>JAVASCRIPT</code>的<code>DOM</code>调用。由于内部方法是编译好的而非解释执行，故执行的更快。</li>
</ul>
</li>
</ul>


<blockquote><p>对于小的<code>DOM</code>更改，两者效率差不多，但对于大的<code>DOM</code>更改，<code>innerHTML</code>要比标准的<code>DOM</code>方法创建同样的<code>DOM</code>结构快得多。</p></blockquote></li>
</ul>
</li>
</ul>
</li>
<li><p>回流<code>reflow</code>。</p>

<ul>
<li><p>发生场景。</p>

<ul>
<li>改变窗体大小。</li>
<li>更改字体。</li>
<li>添加移除stylesheet块。</li>
<li>内容改变哪怕是输入框输入文字。</li>
<li>CSS虚类被触发如 :hover。</li>
<li>更改元素的className。</li>
<li>当对DOM节点执行新增或者删除操作或内容更改时。</li>
<li>动态设置一个style样式时（比如element.style.width=&ldquo;10px&#8221;）。</li>
<li>当获取一个必须经过计算的尺寸值时，比如访问offsetWidth、clientHeight或者其他需要经过计算的CSS值。</li>
</ul>
</li>
<li><p>解决问题的关键，就是限制通过DOM操作所引发回流的次数。</p>

<ul>
<li><p>在对当前DOM进行操作之前，尽可能多的做一些准备工作，保证N次创建，1次写入。</p></li>
<li><p>在对DOM操作之前，把要操作的元素，先从当前DOM结构中删除：</p>

<ul>
<li>通过removeChild()或者replaceChild()实现真正意义上的删除。</li>
<li>设置该元素的display样式为“none”。</li>
</ul>
</li>
<li><p>每次修改元素的style属性都会触发回流操作。</p>

<p>element.style.backgroundColor = &ldquo;blue&rdquo;;</p>

<ul>
<li>使用更改<code>className</code>的方式替换<code>style.xxx=xxx</code>的方式。</li>
<li>使用<code>style.cssText = '';</code>一次写入样式。</li>
<li>避免设置过多的行内样式。</li>
<li>添加的结构外元素尽量设置它们的位置为<code>fixed</code>或<code>absolute</code>。</li>
<li>避免使用表格来布局。</li>
<li>避免在<code>CSS</code>中使用<code>JavaScript expressions(IE only)</code>。</li>
</ul>
</li>
<li><p>将获取的<code>DOM</code>数据缓存起来。这种方法，对获取那些会触发回流操作的属性（比如<code>offsetWidth</code>等）尤为重要。</p></li>
<li><p>当对HTMLCollection对象进行操作时，应该将访问的次数尽可能的降至最低，最简单的，你可以将length属性缓存在一个本地变量中，这样就能大幅度的提高循环的效率。</p></li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>

<h3>eval优化</h3>

<hr />

<blockquote><ul>
<li>避免<code>eval</code>：

<ul>
<li><code>eval</code>会在时间方面带来一些效率，但也有很多缺点。

<ul>
<li><code>eval</code>会导致代码看起来更脏。</li>
<li><code>eval</code>会需要消耗大量时间。</li>
<li><code>eval</code>会逃过大多数压缩工具的压缩。</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>

<h3><code>HTML</code>优化</h3>

<hr />

<blockquote><ul>
<li>插入<code>HTML</code>。

<ul>
<li><code>JavaScript</code>中使用<code>document.write</code>生成页面内容会效率较低，可以找一个容器元素，比如指定一个<code>div</code>，并使用<code>innerHTML</code>来将<code>HTML</code>代码插入到页面中。</li>
</ul>
</li>
<li>避免空的<code>src</code>和<code>href</code>。

<ul>
<li>当<code>link</code>标签的<code>href</code>属性为空、<code>script</code>标签的<code>src</code>属性为空的时候，浏览器渲染的时候会把当前页面的<code>URL</code>作为它们的属性值，从而把页面的内容加载进来作为它们的值。</li>
</ul>
</li>
<li>为文件头指定<code>Expires</code>。

<ul>
<li>使内容具有缓存性，避免了接下来的页面访问中不必要的HTTP请求。</li>
</ul>
</li>
<li>重构HTML，把重要内容的优先级提高。</li>
<li>Post-load（次要加载）不是必须的资源。</li>
<li>利用预加载优化资源。</li>
<li>合理架构，使DOM结构尽量简单。</li>
<li>利用<code>LocalStorage</code>合理缓存资源。</li>
<li>尽量避免CSS表达式和滤镜。</li>
<li>尝试使用defer方式加载Js脚本。</li>
<li>新特性：will-change，把即将发生的改变预先告诉浏览器。</li>
<li>新特性Beacon，不堵塞队列的异步数据发送。</li>
<li>不同之处：网络缓慢，缓存更小，不令人满意的浏览器处理机制。</li>
<li>尽量多地缓存文件。</li>
<li>使用HTML5 Web Workers来允许多线程工作。</li>
<li>为不同的Viewports设置不同大小的Content。</li>
<li>正确设置可Tap的目标的大小。</li>
<li>使用响应式图片。</li>
<li>支持新接口协议（如HTTP2）。</li>
<li>未来的缓存离线机制：Service Workers。</li>
<li>未来的资源优化Resource Hints(preconnect, preload, 和prerender)。</li>
<li>使用Server-sent Events。</li>
<li>设置一个Meta Viewport。</li>
</ul>
</blockquote>

<h3><code>JIT</code>与<code>GC</code>优化</h3>

<hr />

<blockquote><ul>
<li><p><code>untyped</code>（无类型）。</p>

<ul>
<li><p><code>JAVASCRIPT</code>是个无类型的语言，这导致了如<code>x=y+ｚ</code>这种表达式可以有很多含义。</p>

<ul>
<li><code>y</code>，<code>z</code>是数字，则<code>+</code>表示加法。</li>
<li><code>y</code>，<code>z</code>是字符串，则<code>+</code>表示字符串连接。</li>
</ul>


<p>而JS引擎内部则使用“<code>细粒度</code>”的类型，比如：</p>

<ul>
<li>32-bit* integer。</li>
<li>64-bit* floating-point。</li>
</ul>


<p>这就要求js类型-js引擎类型，需要做“boxed/unboxed（装箱/解箱）”，在处理一次<code>x=y+z</code>这种计算，需要经过的步骤如下。</p>

<ol>
<li>从内存，读取<code>x=y+z</code>的操作符。</li>
<li>从内存，读取<code>y</code>，<code>z</code>。</li>
<li>检查y，z类型，确定操作的行为。</li>
<li><code>unbox y，z</code>。</li>
<li>执行操作符的行为。</li>
<li><code>box x</code>。</li>
<li>把<code>x</code>写入内存。</li>
</ol>


<p>只有第<code>5</code>步骤是真正有效的操作，其他步骤都是为第<code>5</code>步骤做准备/收尾，<code>JAVASCRIPT</code>的<code>untyped</code>特性很好用，但也为此付出了很大的性能代价。</p></li>
</ul>
</li>
<li><p><code>JIT</code>。</p>

<ul>
<li><p>先看看<code>JIT</code>对<code>untyped</code>的优化，在<code>JIT</code>下，执行<code>x=y+z</code>流程。</p>

<ol>
<li>从内存，读取<code>x=y+z</code>的操作符。</li>
<li>从内存，读取 <code>y</code>，<code>z</code>。</li>
<li>检查<code>y</code>，<code>z</code>类型，确定操作的行为。</li>
<li><code>unbox y，z</code>。</li>
<li>执行 操作符 的行为。</li>
<li><code>box x</code>。</li>
<li>把<code>x</code>写入内存。</li>
</ol>


<p>其中<code>1</code>，<code>2</code>步骤由<code>CPU</code>负责，<code>7</code>步骤<code>JIT</code>把结果保存在寄存器里。但可惜不是所有情况都能使用JIT，当<code>number+number</code>，<code>string+string</code> 等等可以使用<code>JIT</code>，但特殊情况，如：<code>number+undefined</code>就不行了，只能走旧解析器。</p></li>
<li><p>新引擎还对“对象属性”访问做了优化，解决方案叫<code>inline caching</code>，简称：<code>IC</code>。简单的说，就是做<code>cache</code>。但如果当<code>list</code>很大时，这种方案反而影响效率。</p></li>
</ul>
</li>
<li><p><code>Type-specializing JIT</code></p>

<blockquote><p><code>Type-specializing JIT</code>引擎用来处理<code>typed</code>类型（声明类型）变量，但<code>JAVASCRIPT</code>都是<code>untype</code>类型的。</p></blockquote>

<ul>
<li><code>Type-specializing JIT</code>的解决方案是：

<ul>
<li>先通过扫描，监测类型。</li>
<li>通过编译优化（优化对象不仅仅只是“类型”，还包括对JS代码的优化，但核心是类型优化），生成类型变量。</li>
<li>再做后续计算。</li>
</ul>
</li>
<li><code>Type-specializing JIT</code>的执行<code>x=y+z</code>流程：

<ul>
<li>从内存，读取<code>x=y+z</code>的操作符。</li>
<li>从内存，读取<code>y</code>，<code>z</code>。</li>
<li>检查<code>y</code>，<code>z</code>类型，确定操作的行为。</li>
<li><code>unbox y，z</code>。</li>
<li>执行操作符的行为。</li>
<li><code>box x</code>。</li>
<li>把<code>x</code>写入内存。</li>
</ul>
</li>
</ul>


<p>代价是：</p>

<ul>
<li>前置的扫描类型</li>
<li>编译优化。</li>
</ul>


<p>所以·Type-specializing JIT·的应用是有选择性，选择使用这个引擎的场景包括：</p>

<ul>
<li>热点代码。</li>
<li>通过启发式算法估算出来的有价值的代码。</li>
</ul>


<p>另外，有2点也需要注意：</p>

<ul>
<li>当变量类型 发生变化时，引擎有2种处理方式：

<ul>
<li>少量变更，重编译，再执行。</li>
<li>大量变更，交给JIT执行。</li>
</ul>
</li>
<li><code>数组</code>，<code>object properties</code>， 闭包变量 不在优化范畴之列。</li>
</ul>
</li>
</ul>
</blockquote>

<h3>js载入优化</h3>

<hr />

<blockquote><ul>
<li><p>加快JavaScript装入速度的工具：</p>

<ul>
<li>Lab.js

<ul>
<li>借助LAB.js（装入和阻止JavaScript），你就可以并行装入JavaScript文件，加快总的装入过程。此外，你还可以为需要装入的脚本设置某个顺序，那样就能确保依赖关系的完整性。此外，开发者声称其网站上的速度提升了2倍。</li>
</ul>
</li>
</ul>
</li>
<li><p>使用适当的CDN：</p>

<ul>
<li>现在许多网页使用内容分发网络（CDN）。它可以改进你的缓存机制，因为每个人都可以使用它。它还能为你节省一些带宽。你很容易使用ping检测或使用Firebug调试那些服务器，以便搞清可以从哪些方面加快数据的速度。选择CDN时，要照顾到你网站那些访客的位置。记得尽可能使用公共存储库。</li>
</ul>
</li>
<li><p>网页末尾装入JavaScript：</p>

<ul>
<li>也可以在头部分放置需要装入的一些JavaScript，但是前提是它以异步方式装入。</li>
</ul>
</li>
<li><p>异步装入跟踪代码：</p>

<blockquote><p>脚本加载与解析会阻塞HTML渲染，可以通过异步加载方式来避免渲染阻塞，步加载的方式很多，比较通用的方法如下。</p>

<pre><code>var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-XXXXXXX-XX']);
    _gaq.push(['_trackPageview']);
(function() {
    var ga = document.createElement('script'); ga.type = 'text/JavaScript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</code></pre></blockquote></li>
</ul>


<p>或者</p>

<pre><code>    function loadjs (script_filename){
         var script = document.createElement( 'script' );
         script.setAttribute( 'type' , 'text/javascript' );
         script.setAttribute( 'src' , script_filename);
         script.setAttribute( 'id' , 'script-id' );

         scriptElement = document.getElementById( 'script-id' );
         if (scriptElement){
             document.getElementsByTagName( 'head' )[0].removeChild(scriptElement);
         }
         document.getElementsByTagName( 'head' )[0].appendChild(script);
    }
    var script = 'scripts/alert.js' ;
    loadjs(script);
</code></pre>

<ul>
<li><p>把你的JavaScript打包成PNG文件</p>

<ul>
<li>将JavaScript/css数据打包成PNG文件。之后进行拆包，只要使用画布API的getImageData()。可以在不缩小数据的情况下，多压缩35%左右。而且是无损压缩，对比较庞大的脚本来说，在图片指向画布、读取像素的过程中，你会觉得有“一段”装入时间。</li>
</ul>
</li>
<li><p>设置Cache-Control和Expires头</p>

<p>通过Cache-Control和Expires头可以将脚本文件缓存在客户端或者代理服务器上，可以减少脚本下载的时间。</p>

<blockquote><p>Expires格式:</p>

<pre><code>Expires = "Expires" ":" HTTP-date
Expires: Thu, 01 Dec 1994 16:00:00 GMT
Note: if a response includes a Cache-Control field with the max-age directive that directive overrides the
Expires field.
</code></pre>

<p>Cache-Control格式：</p>

<pre><code>Cache-Control   = "Cache-Control" ":" 1#cache-directive
Cache-Control: public
</code></pre></blockquote></li>
</ul>


<p>具体的标准定义可以参考http1.1中的定义，简单来说Expires控制过期时间是多久，Cache-Control控制什么地方可以缓存 。</p></blockquote>

<h3><code>with</code>优化</h3>

<hr />

<blockquote><ul>
<li><p>尽可能地少用<code>with</code>语句，因为它会增加<code>with</code>语句以外的数据的访问代价。</p></li>
<li><p>避免使用<code>with</code></p>

<pre><code>&gt;
`with`语句将一个新的可变对象推入作用域链的头部，函数的所有局部变量现在处于第二个作用域链对象中，从而使局部变量的访问代价提高。
</code></pre>

<p>var person = {</p>

<pre><code> name: “Nicholas",
 age: 30
</code></pre>

<p>}function displayInfo() {</p>

<pre><code> var count = 5;
 with (person) {
     alert(name + ' is ' + age);
     alert( 'count is ' + count);
 }
</code></pre>

<p>}</p></li>
</ul>
</blockquote>

<h3>变量专题</h3>

<hr />

<blockquote><ul>
<li><p>全局变量</p>

<ul>
<li>当一个变量被定义在全局作用域中，默认情况下<code>JAVASCRIPT</code>引擎就不会将其回收销毁。如此该变量就会一直存在于老生代堆内存中，直到页面被关闭。</li>
<li><code>全局变量</code>缺点。

<ul>
<li>使变量不易被回收。

<ul>
<li>多人协作时容易产生混淆。</li>
</ul>
</li>
<li>在作用域链中容易被干扰。</li>
</ul>
</li>
<li>可以通过包装函数来处理<code>全局变量</code>。</li>
</ul>
</li>
<li><p>局部变量。</p>

<ul>
<li>尽量选用局部变量而不是全局变量。</li>
<li>局部变量的访问速度要比全局变量的访问速度更快，因为全局变量其实是<code>window</code>对象的成员，而局部变量是放在函数的栈里的。</li>
</ul>
</li>
<li><p>手工解除变量引用</p>

<ul>
<li><p>在业务代码中，一个变量已经确定不再需要了，那么就可以手工解除变量引用，以使其被回收。</p>

<p>var data = { /<em> some big data </em>/ };
// &hellip;
data = null;</p></li>
</ul>
</li>
<li><p>变量查找优化。</p>

<ul>
<li>变量声明带上<code>var</code>，如果声明变量忘记了<code>var</code>，那么<code>JAVASCRIPT</code>引擎将会遍历整个作用域查找这个变量，结果不管找到与否，都会造成性能损耗。

<ul>
<li>如果在上级作用域找到了这个变量，上级作用域变量的内容将被无声的改写，导致莫名奇妙的错误发生。</li>
<li>如果在上级作用域没有找到该变量，这个变量将自动被声明为全局变量，然而却都找不到这个全局变量的定义。</li>
</ul>
</li>
<li><p>慎用全局变量。</p>

<ul>
<li>全局变量需要搜索更长的作用域链。</li>
<li>全局变量的生命周期比局部变量长，不利于内存释放。</li>
<li>过多的全局变量容易造成混淆，增大产生bug的可能性。</li>
</ul>
</li>
<li><p>具有相同作用域变量通过一个var声明。</p>

<pre><code>jQuery.extend = jQuery.fn.extend = function () {
    var options,
        name,
        src,
        copy,
        copyIsArray,
        clone,target = arguments[0] || {},
        i = 1,
        length = arguments.length,
        deep = false ;
}
</code></pre></li>
<li><p>缓存重复使用的全局变量。</p>

<ul>
<li><p>全局变量要比局部变量需要搜索的作用域长</p></li>
<li><p>重复调用的方法也可以通过局部缓存来提速</p></li>
<li><p>该项优化在IE上体现比较明显</p>

<p>var docElem = window.document.documentElement,</p>

<pre><code>selector_hasDuplicate,
matches = docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector ||docElem.msMatchesSelector,
selector_sortOrder = function ( a, b ) {
    // Flag for duplicate removal
    if ( a === b ) {
         selector_hasDuplicate = true ;
         return 0;
    }
}
</code></pre></li>
</ul>
</li>
</ul>
</li>
<li><p>善用回调。</p>

<ul>
<li><p>除了使用闭包进行内部变量访问，我们还可以使用现在十分流行的回调函数来进行业务处理。</p>

<pre><code>    function getData(callback) {
      var data = 'some big data';
      callback(null, data);
    }
    getData(function(err, data) {
      console.log(data);
    });
</code></pre>

<ul>
<li>回调函数是一种后续传递风格(<code>Continuation Passing Style</code>, <code>CPS</code>)的技术，这种风格的程序编写将函数的业务重点从返回值转移到回调函数中去。而且其相比闭包的好处也有很多。

<ul>
<li>如果传入的参数是基础类型（如字符串、数值），回调函数中传入的形参就会是复制值，业务代码使用完毕以后，更容易被回收。</li>
<li>通过回调，我们除了可以完成同步的请求外，还可以用在异步编程中，这也就是现在非常流行的一种编写风格。</li>
<li>回调函数自身通常也是临时的匿名函数，一旦请求函数执行完毕，回调函数自身的引用就会被解除，自身也得到回收。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>

<h3>常规优化</h3>

<hr />

<blockquote><ul>
<li><p>传递方法取代方法字符串</p>

<p>一些方法例如<code>setTimeout()</code>、<code>setInterval()</code>，接受<code>字符串</code>或者<code>方法实例</code>作为参数。直接传递方法对象作为参数来避免对字符串的二次解析。</p></li>
<li><ul>
<li><p>传递方法</p>

<pre><code>   setTimeout(test, 1);
</code></pre></li>
</ul>
</li>
<li><ul>
<li><p>传递方法字符串</p>

<pre><code>setTimeout('test()', 1);
</code></pre></li>
</ul>
</li>
<li><p>使用原始操作代替方法调用</p>

<p>方法调用一般封装了原始操作，在性能要求高的逻辑中，可以使用原始操作代替方法调用来提高性能。</p>

<ul>
<li><p>原始操作</p>

<p>var min = a&lt;b?a:b;</p></li>
<li><p>方法实例</p>

<p>var min = Math.min(a, b);</p></li>
</ul>
</li>
<li><p>定时器</p>

<p>如果针对的是不断运行的代码，不应该使用<code>setTimeout</code>，而应该是用<code>setInterval</code>。<code>setTimeout</code>每次要重新设置一个定时器。</p></li>
<li><p>避免双重解释</p></li>
</ul>


<p>当<code>JAVASCRIPT</code>代码想解析<code>JAVASCRIPT</code>代码时就会存在双重解释惩罚，双重解释一般在使用<code>eval</code>函数、<code>new Function</code>构造函数和<code>setTimeout</code>传一个字符串时等情况下会遇到，如。</p>

<pre><code>    eval("alert('hello world');");
    var sayHi = new Function("alert('hello world');");
    setTimeout("alert('hello world');", 100);
</code></pre>

<p>上述<code>alert('hello world');</code>语句包含在字符串中，即在JS代码运行的同时必须新启运一个解析器来解析新的代码，而实例化一个新的解析器有很大的性能损耗。</p>

<pre><code>   我们看看下面的例子：

    var sum, num1 = 1, num2 = 2;
    /**效率低**/
    for(var i = 0; i &lt; 10000; i++){
        var func = new Function("sum+=num1;num1+=num2;num2++;");
        func();
        //eval("sum+=num1;num1+=num2;num2++;");
    }
    /**效率高**/
    for(var i = 0; i &lt; 10000; i++){
        sum+=num1;
        num1+=num2;
        num2++;
    }
</code></pre>

<p>第一种情况我们是使用了new Function来进行双重解释，而第二种是避免了双重解释。</p>

<ul>
<li><p>原生方法更快</p>

<ul>
<li>只要有可能，使用原生方法而不是自已用JS重写。原生方法是用诸如C/C++之类的编译型语言写出来的，要比JS的快多了。</li>
</ul>
</li>
<li><p>最小化语句数</p>

<p>JS代码中的语句数量也会影响所执行的操作的速度，完成多个操作的单个语句要比完成单个操作的多个语句块快。故要找出可以组合在一起的语句，以减来整体的执行时间。这里列举几种模式</p>

<ul>
<li><p>多个变量声明</p>

<p>/<strong>不提倡</strong>/
var i = 1;
var j = &ldquo;hello&rdquo;;
var arr = [1,2,3];
var now = new Date();
/<strong>提倡</strong>/
var i = 1,</p>

<pre><code>j = "hello",
arr = [1,2,3],
now = new Date();
</code></pre></li>
<li><p>插入迭代值</p>

<p>/<strong>不提倡</strong>/
var name = values[i];
i++;
/<strong>提倡</strong>/
var name = values[i++];</p></li>
<li><p>使用数组和对象字面量，避免使用构造函数Array(),Object()</p>

<p>/<strong>不提倡</strong>/
var a = new Array();
a[0] = 1;
a[1] = &ldquo;hello&rdquo;;
a[2] = 45;
var o = new Obejct();
o.name = &ldquo;bill&rdquo;;
o.age = 13;
/<strong>提倡</strong>/
var a = [1, &ldquo;hello&rdquo;, 45];
var o = {</p>

<pre><code>name : "bill",
age : 13
</code></pre>

<p>};</p></li>
</ul>
</li>
<li><p>避免使用属性访问方法</p>

<ul>
<li><p>JavaScript不需要属性访问方法，因为所有的属性都是外部可见的。</p></li>
<li><p>添加属性访问方法只是增加了一层重定向 ，对于访问控制没有意义。</p>

<pre><code>使用属性访问方法示例
</code></pre>

<p>function Car() {
this .m_tireSize = 17;
this .m_maxSpeed = 250;
this .GetTireSize = Car_get_tireSize;
this .SetTireSize = Car_put_tireSize;
}</p>

<p>function Car_get_tireSize() {
return this .m_tireSize;
}</p>

<p>function Car_put_tireSize(value) {
this .m_tireSize = value;
}
var ooCar = new Car();
var iTireSize = ooCar.GetTireSize();
ooCar.SetTireSize(iTireSize + 1);</p>

<pre><code>直接访问属性示例
</code></pre>

<p>function Car() {
this .m_tireSize = 17;
this .m_maxSpeed = 250;
}
var perfCar = new Car();
var iTireSize = perfCar.m_tireSize;
perfCar.m_tireSize = iTireSize + 1;</p></li>
</ul>
</li>
<li><p>减少使用元素位置操作</p>

<ul>
<li><p>一般浏览器都会使用增量reflow的方式将需要reflow的操作积累到一定程度然后再一起触发，但是如果脚本中要获取以下属性，那么积累的reflow将会马上执行，已得到准确的位置信息。</p>

<pre><code>     offsetLeft
     offsetTop
     offsetHeight
     offsetWidth
     scrollTop/Left/Width/Height
     clientTop/Left/Width/Height
     getComputedStyle()
</code></pre></li>
</ul>
</li>
</ul>
</blockquote>

<h3>代码压缩</h3>

<hr />

<blockquote><ul>
<li><p>代码压缩工具</p>

<blockquote><p>精简代码就是将代码中的<code>空格</code>和<code>注释</code>去除，也有更进一步的会对变量名称<code>混淆</code>、<code>精简</code>。根据统计精简后文件大小会平均减少<code>21%</code>，即使<code>Gzip</code>之后文件也会减少<code>5%</code>。</p></blockquote>

<ul>
<li>YUICompressor</li>
<li>Dean Edwards Packer</li>
<li>JSMin</li>
<li>GZip压缩

<ul>
<li><code>GZip</code>缩短在浏览器和服务器之间传送数据的时间，缩短时间后得到标题是<code>Accept-Encoding</code>: <code>gzip</code>,<code>deflate</code>的一个文件。不过这种压缩方法同样也有缺点。

<ul>
<li>它在服务器端和客户端都要占用处理器资源（以便压缩和解压缩）。</li>
<li>占用磁盘空间。</li>
</ul>
</li>
<li><code>Gzip</code>通常可以减少70%网页内容的大小，包括脚本、样式表、图片等任何一个文本类型的响应，包括<code>XML</code>和<code>JSON</code>。<code>Gzip</code>比<code>deflate</code>更高效，主流服务器都有相应的压缩支持模块。</li>
<li><code>Gzip</code>的工作流程为

<ul>
<li>客户端在请求<code>Accept-Encoding</code>中声明可以支持<code>Gzip</code>。</li>
<li>服务器将请求文档压缩，并在<code>Content-Encoding</code>中声明该回复为<code>Gzip</code>格式。</li>
<li>客户端收到之后按照<code>Gzip</code>解压缩。</li>
</ul>
</li>
</ul>
</li>
<li>Closure compiler</li>
</ul>
</li>
</ul>
</blockquote>

<h3>代码优化</h3>

<hr />

<blockquote><ul>
<li><p>优化原则：</p>

<blockquote><p>JS与其他语言不同在于它的执行效率很大程度是取决于<code>JS engine</code>的效率。除了<code>引擎实现</code>的优劣外，<code>引擎</code>自己也会为一些特殊的<code>代码模式</code>采取一些优化的策略。例如<code>FF</code>、<code>Opera</code>和<code>Safari</code>的<code>JAVASCRIPT</code>引擎，都对字符串的拼接运算（<code>+</code>）做了特别优化。所以应该根据不同引擎进行不同优化。</p></blockquote>

<p>而如果做跨浏览器的web编程，则最大的问题是在于IE6（JScript 5.6），因为在不打hotfix的情况下，JScript引擎的垃圾回收的bug，会导致其在真实应用中的performance跟其他浏览器根本不在一个数量级上。因此在这种场合做优化，实际上就是为JScript做优化，所以第一原则就是只需要为IE6（未打补丁的JScript 5.6或更早版本）做优化。</p>

<ul>
<li><p>JS优化总是出现在大规模循环的地方：</p>

<pre><code> 这倒不是说循环本身有性能问题，而是循环会迅速放大可能存在的性能问题，所以第二原则就是以大规模循环体为最主要优化对象。
</code></pre></li>
</ul>


<p>以下的优化原则，只在大规模循环中才有意义，在循环体之外做此类优化基本上是没有意义的。</p>

<p>目前绝大多数JS引擎都是解释执行的，而解释执行的情况下，在所有操作中，函数调用的效率是较低的。此外，过深的prototype继承链或者多级引用也会降低效率。JScript中，10级引用的开销大体是一次空函数调用开销的1/2。这两者的开销都远远大于简单操作（如四则运算）。</p>

<ul>
<li><p>尽量避免过多的引用层级和不必要的多次方法调用：</p>

<pre><code>特别要注意的是，有些情况下看似是属性访问，实际上是方法调用。例如所有DOM的属性，实际上都是方法。在遍历一个NodeList的时候，循环 条件对于nodes.length的访问，看似属性读取，实际上是等价于函数调用的。而且IE DOM的实现上，childNodes.length每次是要通过内部遍历重新计数的。（My god，但是这是真的！因为我测过，childNodes.length的访问时间与childNodes.length的值成正比！）这非常耗费。所以 预先把nodes.length保存到js变量，当然可以提高遍历的性能。
</code></pre></li>
</ul>


<p>同样是函数调用，用户自定义函数的效率又远远低于语言内建函数，因为后者是对引擎本地方法的包装，而引擎通常是c,c++,java写的。进一步，同样的功能，语言内建构造的开销通常又比内建函数调用要效率高，因为前者在JS代码的parse阶段就可以确定和优化。</p>

<ul>
<li><p>尽量使用语言本身的构造和内建函数：</p>

<pre><code>这里有一个例子是高性能的String.format方法。 String.format传统的实现方式是用String.replace(regex, func)，在pattern包含n个占位符（包括重复的）时，自定义函数func就被调用n次。而这个高性能实现中，每次format调用所作的只是一次Array.join然后一次String.replace(regex, string)的操作，两者都是引擎内建方法，而不会有任何自定义函数调用。两次内建方法调用和n次的自定义方法调用，这就是性能上的差别。
</code></pre></li>
</ul>


<p>同样是内建特性，性能上也还是有差别的。例如在JScript中对于arguments的访问性能就很差，几乎赶上一次函数调用了。因此如果一个 可变参数的简单函数成为性能瓶颈的时候，可以将其内部做一些改变，不要访问arguments，而是通过对参数的显式判断来处理，比如：</p></li>
</ul>
</blockquote>

<h3>动画优化</h3>

<hr />

<blockquote><ul>
<li><p>动画效果在缺少硬件加速支持的情况下反应缓慢，例如手机客户端。</p>

<ul>
<li><p>特效应该只在确实能改善用户体验时才使用，而不应用于炫耀或者弥补功能与可用性上的缺陷。</p></li>
<li><p>至少要给用户一个选择可以禁用动画效果。</p></li>
<li><p>设置动画元素为absolute或fixed。</p>

<ul>
<li><code>position: static</code>或<code>position: relative</code>元素应用动画效果会造成频繁的<code>reflow</code>。</li>
<li><code>position: absolute</code>或<code>position: fixed</code>的元素应用动画效果只需要<code>repaint</code>。</li>
</ul>
</li>
<li><p>使用一个<code>timer</code>完成多个元素动画。</p>

<ul>
<li><code>setInterval</code>和<code>setTimeout</code>是两个常用的实现动画的接口，用以间隔更新元素的风格与布局。。</li>
</ul>
</li>
<li><p>动画效果的帧率最优化的情况是使用一个<code>timer</code>完成多个对象的动画效果，其原因在于多个<code>timer</code>的调用本身就会损耗一定性能。</p>

<pre><code>setInterval(function() {
  animateFirst('');
}, 10);
setInterval(function() {
  animateSecond('');
}, 10);
</code></pre></li>
</ul>


<p>使用同一个<code>timer</code>。</p>

<pre><code>    setInterval(function() {
      animateFirst('');
      animateSecond('');
    }, 10);
</code></pre></li>
<li><p>以脚本为基础的动画，由浏览器控制动画的更新频率。</p></li>
</ul>
</blockquote>

<h3>对象专题</h3>

<hr />

<blockquote><ul>
<li><p>减少不必要的对象创建：</p>

<ul>
<li>创建对象本身对性能影响并不大，但由于<code>JAVASCRIPT</code>的垃圾回收调度算法，导致随着对象个数的增加，性能会开始严重下降（复杂度<code>O(n^2)</code>）。

<ul>
<li>如常见的字符串拼接问题，单纯的多次创建字符串对象其实根本不是降低性能的主要原因，而是是在对象创建期间的无谓的垃圾回收的开销。而<code>Array.join</code>的方式，不会创建中间字符串对象，因此就减少了垃圾回收的开销。</li>
</ul>
</li>
<li>复杂的<code>JAVASCRIPT</code>对象，其创建时时间和空间的开销都很大，应该尽量考虑采用缓存。</li>
<li>尽量作用<code>JSON</code>格式来创建对象，而不是<code>var obj=new Object()</code>方法。前者是直接复制，而后者需要调用构造器。</li>
</ul>
</li>
<li><p>对象查找</p>

<ul>
<li>避免对象的嵌套查询，因为<code>JAVASCRIPT</code>的解释性，<code>a.b.c.d.e</code>嵌套对象，需要进行<code>4</code>次查询，嵌套的对象成员会明显影响性能。</li>
<li>如果出现嵌套对象，可以利用局部变量，把它放入一个临时的地方进行查询。</li>
</ul>
</li>
<li><p>对象属性</p>

<ul>
<li><p>访问对象属性消耗性能过程（<code>JAVASCRIPT</code>对象存储）。</p>

<ul>
<li><p>先从本地变量表找到<code>对象</code>。</p></li>
<li><p>然后遍历<code>属性</code>。</p></li>
<li><p>如果在<code>当前对象</code>的<code>属性列表</code>里没找到。</p></li>
<li><p>继续从<code>prototype</code>向上查找。</p></li>
<li><p>且不能直接索引，只能遍历。</p>

<p>function f(obj) {</p>

<pre><code>return obj.a + 1;
</code></pre>

<p>}</p></li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>

<h3>服务端优化</h3>

<hr />

<blockquote><ul>
<li><p>避免404。</p>

<ul>
<li>更改404错误响应页面可以改进用户体验，但是同样也会浪费服务器资源。</li>
<li>指向外部<code>JAVASCRIPT</code>的链接出现问题并返回404代码。

<ul>
<li>这种加载会破坏并行加载。</li>
<li>其次浏览器会把试图在返回的404响应内容中找到可能有用的部分当作JavaScript代码来执行。</li>
</ul>
</li>
</ul>
</li>
<li><p>删除重复的<code>JAVASCRIPT</code>和<code>CSS</code>。</p>

<ul>
<li>重复调用脚本缺点。

<ul>
<li>增加额外的HTTP请求。</li>
<li>多次运算也会浪费时间。在IE和Firefox中不管脚本是否可缓存，它们都存在重复运算<code>JAVASCRIPT</code>的问题。</li>
</ul>
</li>
</ul>
</li>
<li><p><code>ETags</code>配置<code>Entity</code>标签。</p>

<ul>
<li><p><code>ETags</code>用来判断浏览器缓存里的元素是否和原来服务器上的一致。</p>

<ul>
<li><p>与<code>last-modified date</code>相比更灵活。</p>

<pre><code>&gt;如某个文件在1秒内修改了10次，`ETags`可以综合`Inode`(文件的索引节点`inode`数)，`MTime`(修改时间)和`Size`来精准的进行判断，避开`UNIX`记录`MTime`只能精确到秒的问题。服务器集群使用，可取后两个参数。使用`ETags`减少`Web`应用带宽和负载
</code></pre></li>
</ul>
</li>
</ul>
</li>
<li><p>权衡DNS查找次数</p>

<ul>
<li>减少主机名可以节省响应时间。但同时也会减少页面中并行下载的数量。

<ul>
<li><code>IE</code>浏览器在同一时刻只能从同一域名下载两个文件。当在一个页面显示多张图片时，<code>IE</code>用户的图片下载速度就会受到影响。</li>
</ul>
</li>
</ul>
</li>
<li><p>通过Keep-alive机制减少TCP连接。</p></li>
<li><p>通过CDN减少延时。</p></li>
<li><p>平行处理请求（参考BigPipe）。</p></li>
<li><p>通过合并文件或者Image Sprites减少HTTP请求。</p></li>
<li><p>减少重定向（ HTTP 301和40x/50x）。</p></li>
</ul>
</blockquote>

<h3>类型转换专题</h3>

<hr />

<blockquote><ul>
<li>把数字转换成字符串。

<ul>
<li>应用<code>""+1</code>，效率是最高。

<ul>
<li>性能上来说：<code>""+字符串</code>><code>String()</code>><code>.toString()</code>><code>new String()</code>。

<ul>
<li><code>String()</code>属于内部函数，所以速度很快。</li>
<li><code>.toString()</code>要查询原型中的函数，所以速度略慢。</li>
<li><code>new String()</code>最慢。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>浮点数转换成整型。

<ul>
<li>错误使用使用<code>parseInt()</code>。

<ul>
<li><code>parseInt()</code>是用于将<code>字符串</code>转换成<code>数字</code>，而不是<code>浮点数</code>和<code>整型</code>之间的转换。</li>
</ul>
</li>
<li>应该使用<code>Math.floor()</code>或者<code>Math.round()</code>。

<ul>
<li><code>Math</code>是内部对象，所以<code>Math.floor()</code>其实并没有多少查询方法和调用的时间，速度是最快的。</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>

<h3>逻辑判断优化</h3>

<hr />

<blockquote><ul>
<li><code>switch</code>语句。

<ul>
<li>若有一系列复杂的<code>if-else</code>语句，可以转换成单个<code>switch</code>语句则可以得到更快的代码，还可以通过将<code>case</code>语句按照最可能的到最不可能的顺序进行组织，来进一步优化。</li>
</ul>
</li>
</ul>
</blockquote>

<h3>内存专题</h3>

<hr />

<blockquote><ul>
<li><p><code>JAVASCRIPT</code>的内存回收机制</p>

<ul>
<li>以Google的<code>V8</code>引擎为例，在<code>V8</code>引擎中所有的<code>JAVASCRIPT</code>对象都是通过<code>堆</code>来进行内存分配的。当我们在代码中<code>声明变量</code>并<code>赋值</code>时，<code>V8</code>引擎就会在<code>堆内存</code>中分配一部分给这个<code>变量</code>。如果已申请的<code>内存</code>不足以存储这个<code>变量</code>时，<code>V8</code>引擎就会继续申请<code>内存</code>，直到<code>堆</code>的大小达到了<code>V8</code>引擎的内存上限为止（默认情况下，<code>V8</code>引擎的<code>堆内存</code>的大小上限在<code>64位系统</code>中为<code>1464MB</code>，在<code>32位系统</code>中则为<code>732MB</code>）。</li>
<li>另外，<code>V8</code>引擎对<code>堆内存</code>中的<code>JAVASCRIPT</code>对象进行<code>分代管理</code>。

<ul>
<li>新生代。

<ul>
<li>新生代即存活周期较短的<code>JAVASCRIPT</code>对象，如临时变量、字符串等</li>
</ul>
</li>
<li>老生代。

<ul>
<li>老生代则为经过多次垃圾回收仍然存活，存活周期较长的对象，如主控制器、服务器对象等。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>垃圾回收算法。</p>

<ul>
<li>垃圾回收算法一直是编程语言的研发中是否重要的​​一环，而<code>V8</code>引擎所使用的垃圾回收算法主要有以下几种。

<ul>
<li><code>Scavange</code>算法：通过复制的方式进行内存空间管理，主要用于新生代的内存空间；</li>
<li><code>Mark-Sweep</code>算法和<code>Mark-Compact</code>算法：通过标记来对堆内存进行整理和回收，主要用于老生代对象的检查和回收。</li>
</ul>
</li>
</ul>
</li>
<li><p>对象进行回收。</p>

<ul>
<li><p><code>引用</code>。</p>

<ul>
<li><p>当函数执行完毕时，在函数内部所声明的对象<code>不一定</code>就会被销毁。</p></li>
<li><p>引用(<code>Reference</code>)是<code>JAVASCRIPT</code>编程中十分重要的一个机制。</p></li>
<li><ul>
<li><p>是指<code>代码对对象的访问</code>这一抽象关系，它与<code>C/C++</code>的指针有点相似，但并非同物。引用同时也是<code>JAVASCRIPT</code>引擎在进行<code>垃圾回收</code>中最关键的一个机制。</p>

<p>var val = &lsquo;hello world&rsquo;;
function foo() {
return function() {</p>

<pre><code>return val;
</code></pre>

<p>};
}
global.bar = foo();</p></li>
</ul>
</li>
<li><ul>
<li>当代码执行完毕时，对象<code>val</code>和<code>bar()</code>并没有被回收释放，<code>JAVASCRIPT</code>代码中，每个<code>变量</code>作为单独一行而不做任何操作，<code>JAVASCRIPT</code>引擎都会认为这是对<code>对象</code>的访问行为，存在了对<code>对象的引用</code>。为了保证<code>垃圾回收</code>的行为不影响程序逻辑的运行，<code>JAVASCRIPT</code>引擎不会把正在使用的<code>对象</code>进行回收。所以判断<code>对象</code>是否正在使用中的标准，就是是否仍然存在对该<code>对象</code>的<code>引用</code>。

<ul>
<li><code>JAVASCRIPT</code>的<code>引用</code>是可以进行<code>转移</code>的，那么就有可能出现某些引用被带到了全局作用域，但事实上在业务逻辑里已经不需要对其进行访问了，这个时候就应该被回收，但是<code>JAVASCRIPT</code>引擎仍会认为程序仍然需要它。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>


<p><code>IE</code>下闭包引起跨页面内存泄露。</p>

<p><code>JAVASCRIPT</code>的内存泄露处理</p>

<ul>
<li><p>给<code>DOM</code>对象添加的属性是一个对象的引用。</p>

<p>var MyObject = {};document.getElementByIdx_x(&lsquo;myDiv&rsquo;).myProp = MyObject;</p>

<pre><code>解决方法：在window.onunload事件中写上:
</code></pre>

<p>document.getElementByIdx_x(&lsquo;myDiv&rsquo;).myProp = null;</p></li>
<li><p>DOM对象与JS对象相互引用。</p>

<p>function Encapsulator(element) {</p>

<pre><code>this.elementReference = element;
element.myProp = this;
</code></pre>

<p>} new Encapsulator(document.getElementByIdx_x(&lsquo;myDiv&rsquo;));</p>

<pre><code>解决方法：在onunload事件中写上:
</code></pre>

<p>document.getElementByIdx_x(&lsquo;myDiv&rsquo;).myProp = null;</p></li>
<li><p>给DOM对象用attachEvent绑定事件。</p>

<p>function doClick() {} element.attachEvent(&ldquo;onclick&rdquo;, doClick);</p>

<pre><code>解决方法：在onunload事件中写上:
</code></pre>

<p>element.detachEvent(&lsquo;onclick&rsquo;, doClick);</p></li>
<li><p>从外到内执行appendChild。这时即使调用removeChild也无法释放。</p>

<p>var parentDiv = document.createElement_x(&ldquo;div&rdquo;);
var childDiv = document.createElement_x(&ldquo;div&rdquo;);
document.body.appendChild(parentDiv);
parentDiv.appendChild(childDiv);</p>

<pre><code>解决方法：从内到外执行appendChild:
</code></pre>

<p>var parentDiv = document.createElement_x(&ldquo;div&rdquo;);
var childDiv = document.createElement_x(&ldquo;div&rdquo;);
parentDiv.appendChild(childDiv);
document.body.appendChild(parentDiv);</p></li>
<li><p>反复重写同一个属性会造成内存大量占用(但关闭IE后内存会被释放)。</p>

<p>for(i = 0; i &lt; 5000; i++) {</p>

<pre><code>hostElement.text = "asdfasdfasdf";
</code></pre>

<p>}</p>

<pre><code>这种方式相当于定义了5000个属性，解决方法：无。
</code></pre></li>
</ul>


<p><code>内存</code>不是<code>缓存</code>。</p>

<ul>
<li>不要轻易将<code>内存</code>当作<code>缓存</code>使用。</li>
<li>如果是很重要的资源，请不要直接放在<code>内存</code>中，或者制定<code>过期机制</code>，自动销毁<code>过期缓存</code>。</li>
</ul>


<p><code>CollectGarbage</code>。</p>

<ul>
<li><code>CollectGarbage</code>是<code>IE</code>的一个特有属性,用于释放内存的使用方法,将该变量或引用对象设置为<code>null</code>或<code>delete</code>然后在进行释放动作，在做<code>CollectGarbage</code>前,要必需清楚的两个必备条件:（引用）。

<ul>
<li>一个对象在其生存的上下文环境之外，即会失效。</li>
<li>一个全局的对象在没有被执用(引用)的情况下，即会失效</li>
</ul>
</li>
</ul>
</blockquote>

<h3>事件优化</h3>

<hr />

<blockquote><ul>
<li>使用事件代理

<ul>
<li>当存在多个元素需要注册事件时，在每个元素上绑定事件本身就会对性能有一定损耗。</li>
<li>由于DOM Level2事件模 型中所有事件默认会传播到上层文档对象，可以借助这个机制在上层元素注册一个统一事件对不同子元素进行相应处理。</li>
</ul>
</li>
</ul>


<p>捕获型事件先发生。两种事件流会触发DOM中的所有对象，从document对象开始，也在document对象结束。</p>

<pre><code>    &lt;ul id="parent-list"&gt;
        &lt;li id="post-1"&gt;Item 1
        &lt;li id="post-2"&gt;Item 2
        &lt;li id="post-3"&gt;Item 3
        &lt;li id="post-4"&gt;Item 4
        &lt;li id="post-5"&gt;Item 5
        &lt;li id="post-6"&gt;Item 6
    &lt;/li&gt;&lt;/ul&gt;
    // Get the element, add a click listener...
    document.getElementById("parent-list").addEventListener("click",function(e) {
        // e.target is the clicked element!
        // If it was a list item
        if(e.target &amp;&amp; e.target.nodeName == "LI") {
            // List item found!  Output the ID!
            console.log("List item ",e.target.id.replace("post-")," was clicked!");
        }
    });
</code></pre></blockquote>

<h3>数组专题</h3>

<hr />

<blockquote><ul>
<li>当需要使用数组时，可使用<code>JSON</code>格式的语法

<ul>
<li>即直接使用如下语法定义数组：<code>[parrm,param,param...]</code>,而不是采用<code>new Array(parrm,param,param...)</code>这种语法。使用<code>JSON</code>格式的语法是引擎直接解释。而后者则需要调用<code>Array</code>的构造器。</li>
</ul>
</li>
<li>如果需要遍历数组，应该先缓存数组长度，将数组长度放入局部变量中，避免多次查询数组长度。

<ul>
<li>根据字符串、数组的长度进行循环，而通常这个长度是不变的，比如每次查询<code>a.length</code>，就要额外进行一个操作，而预先把<code>var len=a.length</code>，则每次循环就少了一次查询。</li>
</ul>
</li>
</ul>
</blockquote>

<h3>同域跨域</h3>

<hr />

<blockquote><ul>
<li>避免跳转

<ul>
<li>同域：注意避免反斜杠 “/” 的跳转；</li>
<li>跨域：使用Alias或者mod_rewirte建立CNAME（保存域名与域名之间关系的DNS记录）</li>
</ul>
</li>
</ul>
</blockquote>

<h3>性能测试工具</h3>

<hr />

<blockquote><ul>
<li><p>js性能优化和内存泄露问题及检测分析工具</p></li>
<li><ul>
<li>性能优化ajax工具<code>diviefirebug</code></li>
<li>[web性能分析工具YSlow]

<ul>
<li><code>performance</code>性能评估打分，右击箭头可看到改进建议。</li>
<li><code>stats</code>缓存状态分析，传输内容分析。</li>
<li><code>components</code>所有加载内容分析，可以查看传输速度，找出页面访问慢的瓶颈。</li>
<li><code>tools</code>可以查看js和css，并打印页面评估报告。</li>
</ul>
</li>
<li>内存泄露检测工具<code>sIEve</code>

<ul>
<li><code>sIEve</code>是基于<code>IE</code>的内存泄露检测工具，需要下载运行，可以查看dom孤立节点和内存泄露及内存使用情况。

<ol>
<li>列出当前页面内所有dom节点的基本信息(html id style 等)</li>
<li>页面内所有dom节点的高级信息 (内存占用,数量,节点的引用)</li>
<li>可以查找出页面中的孤立节点</li>
<li>可以查找出页面中的循环引用</li>
<li>可以查找出页面中产生内存泄露的节点</li>
</ol>
</li>
</ul>
</li>
<li>内存泄露提示工具<code>leak monitor</code>

<ul>
<li><code>leak monitor</code>在安装后，当离开一个页面时，比如关闭窗口，如果页面有内存泄露，会弹出一个文本框进行即时提示。</li>
</ul>
</li>
<li>代码压缩工具

<ul>
<li>YUI压缩工具</li>
<li>Dean Edwards Packer</li>
<li>JSMin</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><p><code>Blink/Webkit</code>浏览器</p>

<ul>
<li><p>在<code>Blink/Webkit</code>浏览器中（<code>Chrome</code>, <code>Safari</code>, <code>Opera</code>），我们可以借助其中的<code>Developer Tools</code>的<code>Profiles</code>工具来对我们的程序进行内存检查。</p>

<pre><code>Developer Tools - Profiles
</code></pre></li>
</ul>
</li>
</ul>
</li>
<li><p><code>Node.js</code>中的内存检查</p>

<ul>
<li><p>在<code>Node.js</code>中，我们可以使用<code>node-heapdump</code>和<code>node-memwatch</code>模块进​​行内存检查。</p>

<p>var heapdump = require(&lsquo;heapdump&rsquo;);
var fs = require(&lsquo;fs&rsquo;);
var path = require(&lsquo;path&rsquo;);
fs.writeFileSync(path.join(__dirname, &lsquo;app.pid&rsquo;), process.pid);</p></li>
</ul>


<p>在业务代码中引入<code>node-heapdump</code>之后，我们需要在某个运行时期，向<code>Node.js</code>进程发送<code>SIGUSR2</code>信号，让<code>node-heapdump</code>抓拍一份堆内存的快照。</p>

<pre><code>   $ kill -USR2 (cat app.pid)

这样在文件目录下会有一个以`heapdump-&lt;sec&gt;.&lt;usec&gt;.heapsnapshot`格式命名的快照文件，我们可以使用浏览器的`Developer Tools`中的`Profiles`工具将其打开，并进行检查。
</code></pre></li>
<li><p>分析浏览器提供的Waterfall图片来思考优化入口。</p></li>
<li><p>新的测试手段（Navigation, Resource, 和User timing。</p></li>
</ul>
</blockquote>

<h3>循环专题</h3>

<hr />

<blockquote><ul>
<li><p>循环是一种常用的流程控制。</p>

<ul>
<li><p><code>JAVASCRIPT</code>提供了三种循环。</p>

<ul>
<li><p><code>for(;;)</code>。</p>

<ul>
<li><p>推荐使用for循环，如果循环变量递增或递减，不要单独对循环变量赋值，而应该使用嵌套的<code>++</code>或<code>–-</code>运算符。</p></li>
<li><p>代码的可读性对于for循环的优化。</p></li>
<li><p>用<code>-=1</code>。</p></li>
<li><p>从大到小的方式循环（这样缺点是降低代码的可读性）。</p>

<p>/<strong>效率低</strong>/
var divs = document.getElementsByTagName(&ldquo;div&rdquo;);
for(var i = 0; i &lt; divs.length; i++){</p>

<pre><code>...
</code></pre>

<p>}
/<strong>效率高，适用于获取DOM集合，如果纯数组则两种情况区别不到</strong>/
var divs = document.getElementsByTagName(&ldquo;div&rdquo;);
for(var i = 0, len = divs.length; i &lt; len; i++){</p>

<pre><code>...
</code></pre>

<p>}
/<strong>在IE6.0下，for(;;)循环在执行中，第一种情况会每次都计算一下长度，而第二种情况却是在开始的时候计算长度，并把其保存到一个变量中，所以其执行效率要高点，所以在我们使用for(;;)循环的时候，特别是需要计算长度的情况，我们应该开始将其保存到一个变量中。</strong>/</p></li>
</ul>
</li>
<li><p><code>while()</code>。</p>

<ul>
<li><code>for(;;)</code>、<code>while()</code>循环的性能基本持平。</li>
</ul>
</li>
<li><p><code>for(in)</code>。</p>

<ul>
<li>在这三种循环中<code>for(in)</code>内部实现是构造一个所有元素的列表，包括<code>array</code>继承的属性，然后再开始循环，并且需要查询hasOwnProperty。所以<code>for(in)</code>相对<code>for(;;)</code>循环性能要慢。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>选择正确的方法</p>

<ul>
<li><p>避免不必要的属性查找。</p>

<ul>
<li><p>访问<code>变量</code>或<code>数组</code>是<code>O(1)</code>操作。</p></li>
<li><p>访问<code>对象</code>上的<code>属性</code>是一个<code>O(n)</code>操作。</p>

<pre><code>对象上的任何属性查找都要比访问变量或数组花费更长时间，因为必须在原型链中对拥有该名称的属性进行一次搜索，即属性查找越多，执行时间越长。所以针对需要多次用到对象属性，应将其存储在局部变量。
</code></pre></li>
</ul>
</li>
<li><p>优化循环。</p>

<ul>
<li>减值迭代。

<ul>
<li>大多数循环使用一个从0开始，增加到某个特定值的迭代器。在很多情况下，从最大值开始，在循环中不断减值的迭代器更加有效。</li>
</ul>
</li>
<li>简化终止条件。

<ul>
<li>由于每次循环过程都会计算终止条件，故必须保证它尽可能快，即避免属性查找或其它O(n)的操作。</li>
</ul>
</li>
<li>简化循环体。

<ul>
<li>循环体是执行最多的，故要确保其被最大限度地优化。确保没有某些可以被很容易移出循环的密集计算。</li>
</ul>
</li>
<li>使用后测试循环。

<ul>
<li>最常用的for和while循环都是前测试循环，而如do-while循环可以避免最初终止条件的计算，因些计算更快。</li>
</ul>
</li>
</ul>


<blockquote><pre><code>        for(var i = 0; i &lt; values.length; i++) {
            process(values[i]);
        }
</code></pre>

<p>优化1：简化终止条件</p>

<pre><code>for(var i = 0, len = values.length; i &lt; len; i++) {
    process(values[i]);
}
</code></pre>

<p>优化2：使用后测试循环（注意：使用后测试循环需要确保要处理的值至少有一个）</p></blockquote></li>
<li><p>展开循环。</p>

<ul>
<li>当循环的次数确定时，消除循环并使用多次函数调用往往更快。</li>
<li>当循环的次数不确定时，可以使用Duff装置来优化。

<ul>
<li>Duff装置的基本概念是通过计算迭代的次数是否为8的倍数将一个循环展开为一系列语句。</li>
</ul>
</li>
</ul>


<blockquote><pre><code>// Jeff Greenberg for JS implementation of Duff's Device
// 假设：values.length 0
function process(v) {
    alert(v);
}
var values = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17];
var iterations = Math.ceil(values.length / 8);
var startAt = values.length % 8;
var i = 0;
do {
    switch(startAt) {
        case 0 : process(values[i++]);
        case 7 : process(values[i++]);
        case 6 : process(values[i++]);
        case 5 : process(values[i++]);
        case 4 : process(values[i++]);
        case 3 : process(values[i++]);
        case 2 : process(values[i++]);
        case 1 : process(values[i++]);
    }
    startAt = 0;
}while(--iterations 0);
</code></pre>

<p>如上展开循环可以提升大数据集的处理速度。接下来给出更快的Duff装置技术，将do-while循环分成2个单独的循环。（注：这种方法几乎比原始的Duff装置实现快上40%。）</p></blockquote>

<pre><code>// Speed Up Your Site(New Riders, 2003)
function process(v) {
    alert(v);
}     
var values = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17];
var iterations = Math.floor(values.length / 8);
var leftover = values.length % 8;
var i = 0;
if(leftover 0) {
    do {
        process(values[i++]);
    }while(--leftover 0);
}     
do {
    process(values[i++]);
    process(values[i++]);
    process(values[i++]);
    process(values[i++]);
    process(values[i++]);
    process(values[i++]);
    process(values[i++]);
    process(values[i++]);
}while(--iterations 0);
</code></pre>

<blockquote><p>针对大数据集使用展开循环可以节省很多时间，但对于小数据集，额外的开销则可能得不偿失。</p></blockquote></li>
</ul>
</li>
<li><p>避免在循环中使用<code>try-catch</code>。</p>

<ul>
<li><p><code>try-catch-finally</code>语句在catch语句被执行的过程中会动态构造变量插入到当前域中，对性能有一定影响。</p></li>
<li><p>如果需要异常处理机制，可以将其放在循环外层使用。</p></li>
<li><ul>
<li><p>循环中使用try-catch</p>

<p>for ( var i = 0; i &lt; 200; i++) {
try {} catch (e) {}
}</p></li>
</ul>
</li>
<li><ul>
<li><p>循环外使用try-catch</p>

<pre><code>    try {
      for ( var i = 0; i &lt; 200; i++) {}
    } catch (e) {}
</code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>


<p>避免遍历大量元素：</p>

<ul>
<li><p>避免对全局<code>DOM</code>元素进行遍历，如果<code>parent</code>已知可以指定<code>parent</code>在特定范围查询。</p>

<p>var elements = document.getElementsByTagName( &lsquo;*&rsquo; );
for (i = 0; i &lt; elements.length; i++) {
if (elements[i].hasAttribute( &lsquo;selected&rsquo; )) {}
}</p>

<pre><code>如果已知元素存在于一个较小的范围内，
</code></pre>

<p>var elements = document.getElementById( &lsquo;canvas&rsquo; ).getElementsByTagName ( &lsquo;*&rsquo; );
for (i = 0; i &lt; elements.length; i++) {
if (elements[i].hasAttribute( &lsquo;selected&rsquo; )) {}
}</p></li>
</ul>
</blockquote>

<h3>原型优化</h3>

<hr />

<blockquote><ul>
<li>通过原型优化方法定义。

<ul>
<li>如果一个方法类型将被频繁构造，通过方法原型从外面定义附加方法，从而避免方法的重复定义。</li>
<li>可以通过外部原型的构造方式初始化值类型的变量定义。（这里强调值类型的原因是，引用类型如果在原型中定义，一个实例对引用类型的更改会影响到其他实例。）

<ul>
<li>这条规则中涉及到<code>JAVASCRIPT</code>中原型的概念，构造函数都有一个<code>prototype</code>属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。可以把那些不变的属性和方法，直接定义在<code>prototype</code>对象上。

<ul>
<li>可以通过对象实例访问保存在原型中的值。</li>
<li>不能通过对象实例重写原型中的值。</li>
<li>在实例中添加一个与实例原型同名属性，那该属性就会屏蔽原型中的属性。</li>
<li>通过delete操作符可以删除实例中的属性。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>

<h3>运算符专题</h3>

<hr />

<blockquote><ul>
<li>使用运算符时，尽量使用<code>+＝</code>，<code>－＝</code>、<code>*＝</code>、<code>\=</code>等运算符号，而不是直接进行赋值运算。</li>
<li><code>位运算</code>。

<ul>
<li>当进行数学运算时<code>位运算</code>较快，<code>位运算</code>操作要比任何<code>布尔运算</code>或<code>算数运算</code>快，如<code>取模</code>，<code>逻辑与</code>和<code>逻辑或</code>也可以考虑用<code>位运算</code>来替换。</li>
</ul>
</li>
</ul>
</blockquote>

<h3>重绘专题</h3>

<hr />

<blockquote><ul>
<li><p>减少页面的<code>重绘</code>。</p>

<ul>
<li><p>减少页面<code>重绘</code>虽然本质不是<code>JAVASCRIPT</code>优化，但<code>重绘</code>往往是由<code>JAVASCRIPT</code>引起的，而<code>重绘</code>的情况直接影响页面性能。</p>

<p>var str = &ldquo;<div>这是一个测试字符串</div>&rdquo;;
/<strong>效率低</strong>/
var obj = document.getElementsByTagName(&ldquo;body&rdquo;);
for(var i = 0; i &lt; 100; i++){</p>

<pre><code>obj.innerHTML += str + i;
</code></pre>

<p>}
/<strong>效率高</strong>/
var obj = document.getElementsByTagName(&ldquo;body&rdquo;);
var arr = [];
for(var i = 0; i &lt; 100; i++){</p>

<pre><code>arr[i] = str + i;
</code></pre>

<p>}obj.innerHTML = arr.join(&ldquo;&rdquo;);</p></li>
</ul>


<p>一般影响页面重绘的不仅仅是innerHTML，如果改变元素的样式，位置等情况都会触发页面重绘，所以在平时一定要注意这点。</p></li>
<li><p>使用HTML5和CSS3的一些新特性。</p></li>
<li><p>避免在HTML里面缩放图片。</p></li>
<li><p>避免使用插件。</p></li>
<li><p>确保使用正确的字体大小。</p></li>
<li><p>决定当前页面是不是能被访问。</p></li>
</ul>
</blockquote>

<h3>字符串专题</h3>

<hr />

<blockquote><ul>
<li>对字符串进行循环操作。

<ul>
<li>替换、查找等操作，使用正则表达式。

<ul>
<li>因为<code>JAVASCRIPT</code>的循环速度较慢，而正则表达式的操作是用<code>C</code>写成的<code>API</code>，性能比较好。</li>
</ul>
</li>
</ul>
</li>
<li>字符串的拼接。

<ul>
<li>字符串的拼接在我们开发中会经常遇到，所以我把其放在首位，我们往往习惯的直接用<code>+=</code>的方式来拼接字符串，其实这种拼接的方式效率非常的低，我们可以用一种巧妙的方法来实现字符串的拼接，那就是利用数组的<code>join</code>方法，具体请看我整理的：<a href="http://kang.cool/modules/web_develop_standard/index.html">Web前端开发规范文档</a>中的<code>javaScript书写规范</code>倒数第三条目。</li>
<li>不过也有另一种说法，通常认为需要用<code>Array.join</code>的方式，但是由于<code>SpiderMonkey</code>等引擎对字符串的“<code>+</code>”运算做了优化，结果使用<code>Array.join</code>的效率反而不如直接用“<code>+</code>”，但是如果考虑<code>IE6</code>，则其他浏览器上的这种效率的差别根本不值一提。具体怎么取舍，诸君自定。</li>
</ul>
</li>
</ul>
</blockquote>

<h3>作用域链和闭包优化</h3>

<hr />

<blockquote><ul>
<li><p>作用域。</p>

<ul>
<li><p>作用域(<code>scope</code>)是<code>JAVASCRIPT</code>编程中一个重要的<code>运行机制</code>，在<code>JAVASCRIPT</code>同步和异步编程以及<code>JAVASCRIPT</code>内存管理中起着至关重要的作用。</p></li>
<li><p>在<code>JAVASCRIPT</code>中，能形成作用域的有如下几点。</p>

<ul>
<li><p>函数的调用</p></li>
<li><p>with语句</p>

<ul>
<li><code>with</code>会创建自已的作用域，因此会增加其中执行代码的作用域的长度。</li>
</ul>
</li>
<li><p>全局作用域。</p>

<p>以下代码为例：</p>

<p>var foo = function() {
var local = {};
};
foo();
console.log(local); //=undefined</p>

<p>var bar = function() {
local = {};
};
bar();
console.log(local); //={}</p></li>
</ul>


<p>/<strong>这里我们定义了foo()函数和bar()函数，他们的意图都是为了定义一个名为local的变量。在foo()函数中，我们使用var语句来声明定义了一个local变量，而因为函数体内部会形成一个作用域，所以这个变量便被定义到该作用域中。而且foo()函数体内并没有做任何作用域延伸的处理，所以在该函数执行完毕后，这个local变量也随之被销毁。而在外层作用域中则无法访问到该变量。而在bar()函数内，local变量并没有使用var语句进行声明，取而代之的是直接把local作为全局变量来定义。故外层作用域可以访问到这个变量。</strong>/</p>

<pre><code>local = {};
// 这里的定义等效于
global.local = {};
</code></pre></li>
</ul>
</li>
<li><p>作用域链</p>

<ul>
<li><p>在<code>JAVASCRIPT</code>编程中，会遇到多层函数嵌套的场景，这就是典型的作用域链的表示。</p>

<p>function foo() {
var val = &lsquo;hello&rsquo;;
function bar() {</p>

<pre><code>function baz() {
  global.val = 'world;'
};
baz();
console.log(val); //=hello
</code></pre>

<p>};
bar();
};
foo();</p>

<pre><code>/**在`JAVASCRIPT`中，变量标识符的查找是从当前作用域开始向外查找，直到全局作用域为止。所以`JAVASCRIPT`代码中对变量的访问只能向外进行，而不能逆而行之。baz()函数的执行在全局作用域中定义了一个全局变量val。而在bar()函数中，对val这一标识符进行访问时，按照从内到外的查找原则：在bar函数的作用域中没有找到，便到上一层，即foo()函数的作用域中查找。然而，使大家产生疑惑的关键就在这里：本次标识符访问在foo()函数的作用域中找到了符合的变量，便不会继续向外查找，故在baz()函数中定义的全局变量val并没有在本次变量访问中产生影响。**/
</code></pre></li>
</ul>
</li>
<li><p>减少作用域链上的查找次数</p>

<ul>
<li><p><code>JAVASCRIPT</code>代码在执行的时候，如果需要访问一个变量或者一个函数的时候，它需要遍历当前执行环境的作用域链，而遍历是从这个作用域链的前端一级一级的向后遍历，直到全局执行环境。</p>

<p>/<strong>效率低</strong>/
for(var i = 0; i &lt; 10000; i++){</p>

<pre><code>var but1 = document.getElementById("but1");
</code></pre>

<p>}
/<strong>效率高</strong>/
/<strong>避免全局查找</strong>/
var doc = document;
for(var i = 0; i &lt; 10000; i++){</p>

<pre><code>var but1 = doc.getElementById("but1");
</code></pre>

<p>}
/<strong>上面代码中，第二种情况是先把全局对象的变量放到函数里面先保存下来，然后直接访问这个变量，而第一种情况是每次都遍历作用域链，直到全局环境，我们看到第二种情况实际上只遍历了一次，而第一种情况却是每次都遍历了，而且这种差别在多级作用域链和多个全局变量的情况下还会表现的非常明显。在作用域链查找的次数是O(n)。通过创建一个指向document的局部变量，就可以通过限制一次全局查找来改进这个函数的性能。</strong>/</p></li>
</ul>
</li>
<li><p>闭包</p>

<ul>
<li><p><code>JAVASCRIPT</code>中的标识符查找遵循从内到外的原则。</p>

<pre><code>    function foo() {
      var local = 'Hello';
      return function() {
        return local;
      };
    }
    var bar = foo();
    console.log(bar()); //=Hello

    /**这里所展示的让外层作用域访问内层作用域的技术便是闭包(Closure)。得益于高阶函数的应用，使foo()函数的作用域得到`延伸`。foo()函数返回了一个匿名函数，该函数存在于foo()函数的作用域内，所以可以访问到foo()函数作用域内的local变量，并保存其引用。而因这个函数直接返回了local变量，所以在外层作用域中便可直接执行bar()函数以获得local变量。**/
</code></pre>

<ul>
<li><p>闭包是<code>JAVASCRIPT</code>的高级特性，因为把带有​​内部变量引用的函数带出了函数外部，所以该作用域内的变量在函数执行完毕后的并不一定会被销毁，直到内部变量的引用被全部解除。所以闭包的应用很容易造成内存无法释放的情况。</p></li>
<li><p>良好的闭包管理。</p>

<ul>
<li><p>循环事件绑定、私有属性、含参回调等一定要使用闭包时，并谨慎对待其中的细节。</p>

<ul>
<li><p>循环绑定事件，我们假设一个场景：有六个按钮，分别对应六种事件，当用户点击按钮时，在指定的地方输出相应的事件。</p>

<p>var btns = document.querySelectorAll(&lsquo;.btn&rsquo;); // 6 elements
var output = document.querySelector(&lsquo;#output&rsquo;);
var events = [1, 2, 3, 4, 5, 6];
// Case 1
for (var i = 0; i &lt; btns.length; i++) {
btns[i].onclick = function(evt) {</p>

<pre><code>output.innerText += 'Clicked ' + events[i];
</code></pre>

<p>};
}
/<strong>这里第一个解决方案显然是典型的循环绑定事件错误，这里不细说，详细可以参照我给一个网友的回答；而第二和第三个方案的区别就在于闭包传入的参数。</strong>/
// Case 2
for (var i = 0; i &lt; btns.length; i++) {
btns[i].onclick = (function(index) {</p>

<pre><code>return function(evt) {
  output.innerText += 'Clicked ' + events[index];
};
</code></pre>

<p>})(i);
}
/<strong>第二个方案传入的参数是当前循环下标，而后者是直接传入相应的事件对象。事实上，后者更适合在大量数据应用的时候，因为在JavaScript的函数式编程中，函数调用时传入的参数是基本类型对象，那么在函数体内得到的形参会是一个复制值，这样这个值就被当作一个局部变量定义在函数体的作用域内，在完成事件绑定之后就可以对events变量进行手工解除引用，以减轻外层作用域中的内存占用了。而且当某个元素被删除时，相应的事件监听函数、事件对象、闭包函数也随之被销毁回收。</strong>/
// Case 3
for (var i = 0; i &lt; btns.length; i++) {
btns[i].onclick = (function(event) {</p>

<pre><code>return function(evt) {
  output.innerText += 'Clicked ' + event;
};
</code></pre>

<p>})(events[i]);}</p></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>避开闭包陷阱</p>

<ul>
<li>闭包是个强大的工具，但同时也是性能问题的主要诱因之一。不合理的使用闭包会导致内存泄漏。</li>
<li>闭包的性能不如使用内部方法，更不如重用外部方法。

<ul>
<li>由于<code>IE 9</code>浏览器的<code>DOM</code>节点作为<code>COM</code>对象来实现，<code>COM</code>的<code>内存管理</code>是通过引用计数的方式，引用计数有个难题就是循环引用，一旦<code>DOM</code>引用了闭包(例如<code>event handler</code>)，闭包的上层元素又引用了这个<code>DOM</code>，就会造成循环引用从而导致内存泄漏。</li>
</ul>
</li>
</ul>
</li>
<li><p>善用函数</p>

<ul>
<li><p>使用一个匿名函数在代码的最外层进行包裹。</p>

<pre><code> ;(function() {
   // 主业务代码
 })();
</code></pre></li>
</ul>
</li>
</ul>


<p>有的甚至更高级一点：</p>

<pre><code>    ;(function(win, doc, $, undefined) {
      // 主业务代码
    })(window, document, jQuery);
</code></pre>

<p>甚至连如RequireJS, SeaJS, OzJS 等前端模块化加载解决方案，都是采用类似的形式：</p>

<pre><code>    /**RequireJS**/
    define(['jquery'], function($) {
      // 主业务代码
    });
    /**SeaJS**/
    define('module', ['dep', 'underscore'], function($, _) {
      // 主业务代码
    });
</code></pre>

<p>被定义在全局作用域的对象，可能是会一直存活到进程退出的，如果是一个很大的对象，那就麻烦了。比如有的人喜欢在JavaScript中做模版渲染：</p>

<pre><code>    &lt;?php
      $db = mysqli_connect(server, user, password, 'myapp');
      $topics = mysqli_query($db, "SELECT * FROM topics;");
    ?&gt;
    &lt;!doctype html&gt;
    &lt;html lang="en"&gt;
    &lt;head&gt;
      &lt;meta charset="UTF-8"&gt;
      &lt;title&gt;你是猴子请来的逗比么？&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
      &lt;ul id="topics"&gt;&lt;/ul&gt;
      &lt;script type="text/tmpl" id="topic-tmpl"&gt;
        &lt;li class="topic"&gt;
          &lt;h1&gt;&lt;%=title%&gt;&lt;/h1&gt;
          &lt;p&gt;&lt;%=content%&gt;&lt;/p&gt;
        &lt;/li&gt;
      &lt;/script&gt;
      &lt;script type="text/javascript"&gt;
        var data = &lt;?php echo json_encode($topics); ?&gt;;
        var topicTmpl = document.querySelector('#topic-tmpl').innerHTML;
        var render = function(tmlp, view) {
          var complied = tmlp
            .replace(/\n/g, '\\n')
            .replace(/&lt;%=([\s\S]+?)%&gt;/g, function(match, code) {
              return '" + escape(' + code + ') + "';
            });
          complied = [
            'var res = "";',
            'with (view || {}) {',
              'res = "' + complied + '";',
            '}',
            'return res;'
          ].join('\n');
          var fn = new Function('view', complied);
          return fn(view);
        };
        var topics = document.querySelector('#topics');
        function init()
          data.forEach(function(topic) {
            topics.innerHTML += render(topicTmpl, topic);
          });
        }
        init();
      &lt;/script&gt;
    &lt;/body&gt;
    &lt;/html&gt;
</code></pre>

<p>在从数据库中获取到的数据的量是非常大的话，前端完成模板渲染以后，data变量便被闲置在一边。可因为这个变量是被定义在全局作用域中的，所以<code>JAVASCRIPT</code>引擎不会将其回收销毁。如此该变量就会一直存在于老生代堆内存中，直到页面被关闭。可是如果我们作出一些很简单的修改，在逻辑代码外包装一层函数，这样效果就大不同了。当UI渲染完成之后，代码对data的引用也就随之解除，而在最外层函数执行完毕时，<code>JAVASCRIPT</code>引擎就开始对其中的对象进行检查，data也就可以随之被回收。</p></blockquote>

<h2>#</h2>
</div>

  
  <section>
    <h1>Comments</h1>
    <div id="disqus_thread"><div id="disqus_thread"></div>
<script type="text/javascript">
  var disqus_shortname = 'mirreal';
  var disqus_identifier = 'http://blog.mirreal.net/note/perf.html';
  var disqus_url = 'http://blog.mirreal.net/note/perf.html';
  //var disqus_developer = 1;
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>
  
</article>

       <footer role="contentinfo" class="copyright">
    	<p>
		Copyright &copy; 2018 - <span><a href="http://mirreal.net/">Patrick Ran</a></span>
	</p>
    </footer>

  </div>

</body>
</html>

